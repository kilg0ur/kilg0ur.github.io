<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Entity Framework Core | Kilgour Notes</title><meta name="author" content="kilgour"><meta name="copyright" content="kilgour"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Entity Framework CoreEntity Framework Core(简称EF Core)是.Net Core中的ORM框架，它可以让开发人员以面向对象的方式进行数据库的操作，从而大大的提升了开发的效率。 1、什么是ORM?ORM（object relational mapping，对象关系映射）. 对象：指的就是C#中的对象，而“关系”指的就是关系数据库，“映射”:指的就是在关系">
<meta property="og:type" content="article">
<meta property="og:title" content="Entity Framework Core">
<meta property="og:url" content="http://www.kilgour.top/2024/06/23/%E8%80%81%E7%8E%8B-5%E3%80%81Entity-Framework-Core/index.html">
<meta property="og:site_name" content="Kilgour Notes">
<meta property="og:description" content="Entity Framework CoreEntity Framework Core(简称EF Core)是.Net Core中的ORM框架，它可以让开发人员以面向对象的方式进行数据库的操作，从而大大的提升了开发的效率。 1、什么是ORM?ORM（object relational mapping，对象关系映射）. 对象：指的就是C#中的对象，而“关系”指的就是关系数据库，“映射”:指的就是在关系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover9.jpeg">
<meta property="article:published_time" content="2024-06-23T11:19:00.000Z">
<meta property="article:modified_time" content="2024-06-28T01:47:23.334Z">
<meta property="article:author" content="kilgour">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover9.jpeg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/logo.png"><link rel="canonical" href="http://www.kilgour.top/2024/06/23/%E8%80%81%E7%8E%8B-5%E3%80%81Entity-Framework-Core/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Entity Framework Core',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-28 09:47:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/panarama.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover9.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Kilgour Notes"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/logo.png"/><span class="site-name">Kilgour Notes</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Entity Framework Core</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-23T11:19:00.000Z" title="发表于 2024-06-23 19:19:00">2024-06-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-28T01:47:23.334Z" title="更新于 2024-06-28 09:47:23">2024-06-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>143分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Entity Framework Core"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Entity-Framework-Core"><a href="#Entity-Framework-Core" class="headerlink" title="Entity Framework Core"></a>Entity Framework Core</h1><p><code>Entity Framework Core</code>(简称<code>EF Core</code>)是<code>.Net Core</code>中的<code>ORM</code>框架，它可以让开发人员以面向对象的方式进行数据库的操作，从而大大的提升了开发的效率。</p>
<h1 id="1、什么是ORM"><a href="#1、什么是ORM" class="headerlink" title="1、什么是ORM?"></a>1、什么是<code>ORM</code>?</h1><p><code>ORM</code>（<code>object relational mapping</code>，对象关系映射）.</p>
<p>对象：指的就是<code>C#</code>中的对象，而“关系”指的就是关系数据库，“映射”:指的就是在关系数据库和<code>c#</code>对象之间搭建一座桥梁，<strong>能够让对象模型与关系数据库的表结构之间进行相互转换</strong>。我们知道，在<code>.Net</code>中可以通过<code>Ado.net</code>链接数据库然后执行<code>SQL</code>语句来从操作数据库中的数据。而<code>ORM</code>可以让我们通过操作<code>C#</code>对象的方式来操作数据库，比如，使用<code>ORM</code>，可以通过创建<code>C#</code>对象的方式把数据插入到数据库中，而不需要编写<code>Insert</code>语句。如下伪代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserInfo userInfo = <span class="keyword">new</span> UserInfo()&#123;UserName=<span class="string">&quot;laowang&quot;</span>,Password = <span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">orm.Save(userInfo);</span><br></pre></td></tr></table></figure>



<p>当然，如果想进行查询，可以使用如下方式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserInfo userInfo = orm.UserInfo.Single(u=&gt;u.id &gt; <span class="number">2</span> || u.UserName.Contains(<span class="string">&quot;wang&quot;</span>))</span><br><span class="line">  <span class="built_in">string</span> userName = userInfo.UserName <span class="comment">// 直接获取了UserName这个属性</span></span><br><span class="line">  <span class="built_in">string</span> roleNames = userInfo.RoleInfo.RoleName <span class="comment">// 获取了用户具有的角色名称，进行了join关联的查询</span></span><br></pre></td></tr></table></figure>

<p>通过以上的伪代码，我们可以看到，这里直接写一个<code>linq</code>查询就可以了，不用写<code>select 查询的SQL</code>语句，非常简单，<code>ORM</code>框架会将其转换成对应的<code>SQL</code>语句。</p>
<p>在这里我们还需要注意的一点就是：**<code>Entity Framework Core 这个ORM框架</code>只是对<code>ADO.NET</code>的封装，<code>ORM</code>底层仍然是通过<code>ADO.NET</code>访问数据库的。** <code>Dapper</code> </p>
<p><code>EF Core</code>是微软官方推出的<code>ORM</code>框架。<code>EF Core</code>不仅可以操作<code>SQLServer</code>数据库，还可以操作<code>MySQL,Oracle</code>等数据。除了<code>EF Core</code>这个<code>ORM</code>框架之外，在<code>.Net Core</code>中还可以使用<code>Dapper,NHibernate Core</code>等第三方的<code>ORM</code>框架。但是由于<code>EF Core</code>是微软官方推出的，并且<code>EF Core</code>体现的是面向对象模型的编程方式，更加先进，所以<code>EF Core</code>的市场占有率比较高。</p>
<h2 id="1-1-开发思想的转变"><a href="#1-1-开发思想的转变" class="headerlink" title="1.1   开发思想的转变"></a>1.1   开发思想的转变</h2><p>以前，开发项目，调研完需求以后，就开始设计数据库。</p>
<p>但是现在的主流开发方式是先分析业务，然后设计模型，并且指定模型之间的关系，最后在生成对应的数据库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202406191746525.png" alt="916"></p>
<p>什么是业务呢？</p>
<p>例如：对大家比较熟悉的购物网站来说，最关键的业务就是，搜索商品，展示商品，用户登录，下订单购买。</p>
<p>当然，这里还可以针对以上的业务最进一步的划分。</p>
<p>例如：针对网站的管理员，可以发布商品，修改商品的信息，删除商品信息。</p>
<p>针对老用户可以进行登录，那么针对新用户就必须提供注册的功能，</p>
<p>用户登录以后，可以将商品放入购物车，当然也可以将购物车中的商品删除，最后进行支付。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202406191750410.png" alt="042"></p>
<p>下面，我们就可以针对上面的三个模块进行数据模型的设计。</p>
<p>什么是数据模型？</p>
<p>数据大家都理解。</p>
<p>所谓的模型就是总结事物的规律。使用这个规律来定义这个事物，所以说模型就是一种可以描述复杂事物的一种方式方法。</p>
<p>例如：描述一下苹果，也就是给苹果建模。</p>
<p>我们可以通过【化学成分】来描述苹果，也可以通过【味道】来描述苹果，还可以通过【外貌特征】聊描述苹果。</p>
<p>以上不同角度的描述都是正确的，问题是我们应该选择哪一个角度来描述苹果呢？</p>
<p>这就需要结合业务来分析了。</p>
<p>如果是化学家，需要通过化学成分这个角度来描述苹果（建立苹果的化学成分的模型），如果是摄影师就需要通过外貌特征来描述苹果，如果是美食家就需要通过味道来描述苹果。</p>
<p>针对上面我们提到的业务，我们应该怎样进行描述，也就是怎样进行建模呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202406191746078.png" alt="758"></p>
<p>下面就可以建立关系了：用户与角色是多对多，用户与购物车是1对1关系，用户与订单是1对多也就是一个用户可以下多个订</p>
<p>以上就是我们常说的基于模型驱动的开发，而不是数据库驱动的开发。</p>
<h1 id="2、EF-Core性能问题"><a href="#2、EF-Core性能问题" class="headerlink" title="2、EF Core性能问题"></a>2、<code>EF Core</code>性能问题</h1><p>关于<code>EF Core</code>有的人认为性能比较差，给出的解释是：<code>EF Core</code>是把<code>C#</code>对象的操作转换成<code>SQL</code>语句，由于<code>SQL</code>语句是自动生成的，所以说<code>EF Core</code>就可能会产生性能比较低的操作。这是很多人认为“<code>EF Core</code>”性能差的原因。</p>
<p>但是这种说法是错误的。</p>
<p>具体的原因：</p>
<p>第一：如果开发人员对<code>EF Core</code>有了比较深入的了解以后，也是可以写出性能比较高的代码，而且”<code>EF Core</code>“也提供了性能优化的相关功能，可以帮助开发人员对程序进行性能优化。</p>
<p>第二：<code>EF Core</code>也可以直接执行<code>SQL</code>语句，这样在一些性能瓶颈的环节，或者说需要写复杂的<code>SQL</code>语句的应用场景，开发人员仍然可以直接编写优化后的<code>SQL</code>语句。</p>
<p>非常重要的一点是，我们使用<code>EF Core</code>进行开发的效率是非常高的，比手写<code>SQL</code>语句能更快地完成代码的编写。在进行系统开发的时候，程序的运行效率并不是唯一的考量因素，我们需要综合考虑性能、开发效率、可维护性等多个维度的因素。使用<code>EF Core</code>可以帮助开发人员更快地完成项目，这就是非常大的优势；对于性能瓶颈环节，开发人员可以再使用<code>EF Core</code>进行优化；对于使用<code>EF Core</code>优化后性能还较差的环节，开发人员还可以把<code>EF Core</code>代码改为直接执行<code>SQL</code>语句.这样我们就可以在开发效率和程序运行效率之间做好平衡。</p>
<h1 id="3、EF-Core基本使用"><a href="#3、EF-Core基本使用" class="headerlink" title="3、EF Core基本使用"></a>3、<code>EF Core</code>基本使用</h1><p>前面我们讲过<code>EF Core</code>支持所有主流的数据库，包括<code>Microsoft SQL Server、Oracle、MySQL</code>等。</p>
<p>但这里我们主要使用的还是<code>SQL Server</code>.因为<code>Microsoft SQL Server</code>是微软自己的产品，因此<code>EF Core</code>对<code>Microsoft SQL Server</code>的支持非常全面，<code>bug</code>也非常少，有一些新特性只有在<code>Microsoft SQL Server</code>中才支持。当然<code>Microsoft SQL Server</code>服务器的成本是相对比较高的，因此对于成本敏感的项目，也可以使用<code>MySQL</code>等数据库。无论用哪种数据库，<code>EF Core</code>的用法几乎是一模一样的。</p>
<p>下面我们就来看一下<code>EF Core</code>的基本使用</p>
<p><code>EF Core</code>用于将对象和数据库中的表进行映射，因此在进行<code>EF Core</code>开发的时候，需要创建<code>C#</code>类（也叫作实体类）和数据库表两项内容。在经典的<code>EF Core</code>使用场景下，由开发人员编写实体类，然后<code>EF Core</code>可以根据实体类生成数据库表.所以这里我们也采用这种开发方式。</p>
<p>这里我们做的案例通过向数据库中添加一本书。</p>
<p><strong>第一步：先新建一个控制台的项目，在该项目中创建一个<code>Book</code>实体类、</strong>代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 主键</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 书的名称</span></span><br><span class="line">       <span class="keyword">public</span> DateTime PubTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">// 出版日期</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">double</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;   <span class="comment">// 书的价格</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? AuthorName &#123; <span class="keyword">get</span>;<span class="keyword">set</span> &#125;<span class="comment">// 作者名称</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：为项目安装<code>NuGe</code>t包<code>Microsoft.EntityFrameworkCore.SqlServer</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.EntityFrameworkCore.SqlServer</span><br></pre></td></tr></table></figure>

<p>我们先创建一个实现了<code>IEntityTypeConfiguration</code>接口的实体类的配置类<code>BookEntityConfig</code>，它用于配置实体类和数据库表的对应关系.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookEntityConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Book</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Book&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Books&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>IEntityTypeConfiguration</code>接口是一个泛型的接口，这里我们指定的泛型参数类型是<code>Book</code>这个实体类，表示对该实体类进行配置，然后在所实现的<code>Configure</code>这个方法中对<code>Book</code>这个实体类与数据库中的表之间的关系做详细的配置。其中<code> builder.ToTable(&quot;T_Books&quot;)</code>这行代码表示的是<code>Book</code>这个实体类对应的是数据库中的<code>T_Books</code>这张表(表的名称可以根据自己的习惯随意的定义)。</p>
<p>当然，这里有同学可能会想？数据表中是有字段的，而且每个字段都是有类型的，但是这里我们并没有创建<code>T_Books</code>表中的字段，并且也没有给字段指定类型，这时候<code>EF Core</code>将会默认把属性的名字作为表的列名，而且会根据属性的类型来推断出数据库中各个字段的数据类型。</p>
<p><strong>第三步：创建一个继承自<code>DbContext</code>类的<code>TestDbContext</code>类</strong>(这个类名根据自己的习惯进行命名，但是一定要继承<code>DbContext</code>类)，完成数据库的链接</p>
<p><code>TestDbContext</code>类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> DbSet&lt;Book&gt; Books &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=Test;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">          optionsBuilder.UseSqlServer(connStr);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">          modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>TestDbContext</code>这个类中，我们首先定义了<code>Books</code>属性，它的类型是<code>DbSet&lt;Book&gt;</code>泛型。**<code>Books</code>这个属性对应的就是数据库中的<code>T_Books</code>表，对<code>Books</code>的操作会反映到数据库的<code>T_Books</code>表中。**</p>
<p>当然，由于我们这里只有一个<code>Book</code>实体类，所以只创建了一个<code>DbSet</code>，如果项目中有多个实体类，对应的就需要创建多个<code>DbSet</code>.</p>
<p>在所对应的<code>OnConfiguring</code>方法中，对程序所要链接的数据库进行配置，指定了数据库连接字符串。</p>
<p><strong>在<code>OnModelCreating</code>这个方法中，我们加载了当前程序集下实现了<code>IEntityTypeConfiguration</code>接口的类，也就是<code>BookEntityConfig</code>类(该类在当前项目所对应的程序集中)，这样才能在数据库中创建<code>T_Books</code>这个数据表。</strong></p>
<p><strong>第四步：完成”迁移”操作</strong></p>
<p>通过前3步，已经完成了主要的<code>C#</code>代码，下面我们要操作的就是创建对应的数据库与数据表。</p>
<p>在传统软件开发的流程中，数据库表的创建是由开发人员手工完成的，而在使用<code>EF Core</code>的时候，我们可以从实体类的定义中自动生成数据库表。这样开发人员可以专注于实体类模型的创建，而创建数据库表这样的事情就交给<code>EF Core</code>完成。<strong>这种先创建实体类再生成数据库表的开发模式叫作“模型驱动开发”，</strong>区别于先创建数据库表后创建实体类的“数据驱动开发”。<code>EF Core</code>这种根据实体类生成数据库表的操作也被叫作“迁移”（migration）。</p>
<p>为了能够完成迁移的操作，需要安装包<code>Microsoft.EntityFrameworkCore.Tools</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.EntityFrameworkCore.Tools</span><br></pre></td></tr></table></figure>

<p>如果不安装以上包，在通执行<code>Add-Migration</code>等迁移命令的时候会提示错误信息“无法将Add-Migration项识别为<code>cmdlet</code>、函数、脚本文件或可运行程序的名称。”</p>
<p><strong>下面我们就可以在“程序包管理器控制台”中执行<code>Add-Migration</code>进行迁移。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration InitialCreate</span><br></pre></td></tr></table></figure>

<p>在<code>Add-Migration</code>命令后面，我们一般都会带上一个有意义的参数，参数的名字可以根据自己的情况来确定。</p>
<p>为什么要带上参数呢？</p>
<p>由于项目比较复杂，实体类不能一次都创建完,或者 说后期又需要增加新的模块，这样就需要创建新的实体类，<code>EF Core</code>也会根据我们所创建的新的实体类生成对应的表。如果某个实体类不需要了， 或者某个实体类中的某个属性不需要了，<code>EF Core</code>也会进行“回滚”的操作，对应的会删除数据库中对应的表，或者是表中的某个字段。也就说，<strong>每次实体模型发生变化后，都需要进行迁移操作</strong>，为了能够区分每次迁移的操作，所以才会在<code>Add-Migration</code>命令后面添加上一个参数。这样后期需要回滚的时候，也可以根据这个参数名字回滚到对应的步骤。</p>
<p>在执行<code>Add-Migration InitialCreate</code>命令的时候，有可能会出现如下的错误：</p>
<p><code>Build failed</code></p>
<p>这时候，需要重新生成解决方法，把项目重新生成一下，看一下代码中是否有错误。</p>
<p><strong>同时还要注意的一点就是不能将<code>Program.cs</code>中的默认代码删除，如果删除了，不会自动生成<code>main</code>函数，这时候也会出现错误。</strong></p>
<p>执行完以上的命令后，在项目中会出现<code>Migrations</code>文件夹。</p>
<p>在该文件夹中先看一下<code>20230311094632_InitialCreate.cs</code>文件，其他文件后面再进行讲解</p>
<p>这个文件中包含用来创建数据库表的表名、列名、列数据类型、主键等的代码。</p>
<p>上面文件代码还没有执行，它们需要被执行后才会创建数据库，以及对应的表，因此我们接着在【程序包管理器控制台】中执行<code>Update-database</code>命令编译并且执行上面文件中的数据库迁移代码。</p>
<p><strong>第五步：查看<code>SQLServer</code>数据库</strong></p>
<p>我们可以看到<code>Test</code>数据库以及<code>T_Books</code>表已经创建好了。数据表<code>T_Books</code>的结构与实体类中的配置也是一样的。</p>
<p>同时我们可以看到还有一张表<code>__EFMigrationsHistory</code>，记录了迁移的历史记录。<code>EF Core</code>就是基于这张表得知当前执行了哪些迁移的操作，所以这张表不要删除及修改。该表中的<code>ProductVersion</code>字段表示<code>EF Core</code>的版本</p>
<h1 id="4、EF-Core基本使用2"><a href="#4、EF-Core基本使用2" class="headerlink" title="4、EF Core基本使用2"></a>4、<code>EF Core</code>基本使用2</h1><p>了解了<code>EF Core</code>的基本使用以后，下面我们在创建一个实体类 <code>Person</code>，将其映射成对应的表。复习一下上一小节中所讲解的内容。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是所创建的实体类</p>
<p>下面创建<code>PersonConfig.cs</code>类，实现<code>IEntityTypeConfiguration</code>这个泛型接口。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Person</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>TestDbContext</code>类这个类中，创建<code>DbSet</code>类型的属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Book&gt; Books &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Person&gt; Persons &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p> 下面完成迁移的操作，先执行<code>Add-Migration</code>这个命令，生成对应的迁移代码（在执行这个命令之前，最好重新生成项目，看一下代码有没有错误）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration AddPerson</span><br></pre></td></tr></table></figure>

<p>前面我们讲过<code>Add-Migration</code>命令后面一定要跟上一个参数。</p>
<p>执行完上面的<code>Add-Migration</code>命令后，查看<code>Migrations</code>目录下面会多出一个<code>20230311131014_AddPerson.cs</code>文件，由于创建<code>T_Persons</code>这张表。</p>
<p>最后执行<code>Update-database</code>命令编译上面文件中的代码，并且执行，从而完成数据库的迁移。</p>
<p>看一下<code>Test</code>数据库，发现在该数据库下面创建了<code>T_Persons</code>表，同时对应的字段与实体类中属性的配置一样。</p>
<p>同时在<code>__EFMigrationsHistory</code>表中也记录了这次迁移的历史记录。</p>
<p>以上的操作还是新增一个实体类，然后将其映射成表的操作。</p>
<p>如果，是对已经具有的某个实体类，修改其中的属性应该怎样操作呢？</p>
<p>例如，在<code>Person</code>这个实体类中，新增一个<code>Birthday</code>属性，应该怎样处理呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="keyword">public</span> DateTime  Birthday &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>现在，在<code>Person</code>类中新增了一个<code>Birthday</code>属性。</p>
<p><code>PersonConfig.cs</code>这个文件中的代码不需要修改</p>
<p><code>TestDbContext.cs</code>这个文件中的代码也不需要修改。</p>
<p>下面执行<code>Add-Migration AddBirthday </code>生成迁移的代码</p>
<p>在<code>Migrations</code>文件夹下面有多了一个文件，叫做<code>20230311133051_AddBirthday.cs</code>，</p>
<p>打开这个文件，可以看到其中的代码，就是在表中增加一个<code>Birthday</code>字段。</p>
<p>最后执行<code>Update-database</code>命令，执行迁移的代码</p>
<p>查询数据库(这里最好将数据库刷新一下，这样才会更新)，发现<code>T_Persons</code>表中，新增了一个<code>Birthday</code>列。</p>
<p>同时，在<code>EFMigrationsHistory</code>表中也记录了这一次的迁移操作。</p>
<h1 id="5、EF-Core基本使用3"><a href="#5、EF-Core基本使用3" class="headerlink" title="5、EF Core基本使用3"></a>5、<code>EF Core</code>基本使用3</h1><p>现在虽然将实体模型映射成了对应的表，但是我们仔细观察一下表的结构就会发现还是有一定的问题的。</p>
<p>就拿<code>T_Books</code>这张表的结构，我们发现<code>Title</code>这个字段的类型是<code>nvarchar(MAX)</code>，并且是允许为空。</p>
<p>为什么会出现这种情况呢？</p>
<p>因为，我们在创建实体类<code>Book</code>的时候，没有对其<code>Title</code>这个属性做过多的约束，所以才会出现这种情况。</p>
<p><code>Title</code>这个属性的类型是<code>string</code>,没有指定长度，并且是可空类型，所以该属性对应的表中的<code>Title</code>这个字段的时候就变成了<code>nvarch(Max)</code>,也就是<code>c#</code>中的<code>string</code>类型对应表中的<code>nvarch</code>类型，由于<code>Title</code>这个属性没有指定长度，对应的表中的<code>Title</code>字段就是<code>Max</code>，表示最大的长度，同时<code>Title</code>这个字段是可空类型，原因就是我们指定的<code>Title</code>这个属性就是可以为空的。</p>
<p>现在，我们要做的就是在将实体类中的属性映射成对应的表中字段的时候，做一下限制。</p>
<p>例如<code>T_Books</code>表中<code>Title</code>这个字段把它修改 为<code>nvarch(50)</code>,不可为空。</p>
<p>把<code>AuthorName</code>这个字段修改为<code>nvarch(50)，不可为空</code>。</p>
<p>这里需要修改<code>BookEntityConfig.cs</code> 类中的<code>Configure</code>方法，修改后的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookEntityConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Book</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Book&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Books&quot;</span>);</span><br><span class="line">           builder.Property(x =&gt; x.Title).HasMaxLength(<span class="number">50</span>).IsRequired();</span><br><span class="line">           builder.Property(x=&gt;x.AuthorName).HasMaxLength(<span class="number">20</span>).IsRequired();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>HasMaxLength(50)</code>用来配置属性的最大长度为50，<code>IsRequired</code>用来配置属性的值为“不可为空”。</p>
<p>完成上面的修改后，再执行<code>Add-Migration ModifyTitle_AuthorName</code> </p>
<p>以上命令执行完毕以后，在在【程序包管理器控制台】中,会出现如下的警告信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy.</span><br></pre></td></tr></table></figure>

<p>由于我们把现有的<code>Title</code>的字段长度从<code>MAX</code>修改为了50，因此可能会造成数据库中旧数据的丢失，<code>Add-Migration</code>命令给出了<code>“An operation was scaffolded that may result in the loss of data.”</code>这个警告消息。</p>
<p>这时候，在<code>Migrations</code>这个文件夹中会增加一个<code>20230311142012_ModifyTitle_AuthorName.cs</code>文件，该文件中包含了修改<code>T_Books</code>表中的<code>Title,AuthorName</code>字段的长度。</p>
<p>在这里我们可以不用关心这个警告，在【程序包管理器控制台】中输入并执行<code>Update-database</code>命令.</p>
<p>当然，大家在以后的实体模型设计的时候，尽量确定好对应的属性类型和长度等。</p>
<p>可以看到，<code>T_Books</code>表的结构已经发生了改变(注意：为了能够看到最新的表的结构，最好刷新一下数据库)</p>
<p>从上面的操作可以看到，<strong>每次需要把对实体类的改动同步到数据库中的时候，就可以执行<code>Add-Migration</code>和<code>Update-database</code>命令</strong>。</p>
<p>至此，<code>EF Core</code>中实体类的定义以及根据实体类生成数据库修改操作的迁移已经完成。下面我们开始使用定义好的实体类对数据库数据进行操作。</p>
<h1 id="6、EF-Core数据的增删改查"><a href="#6、EF-Core数据的增删改查" class="headerlink" title="6、EF Core数据的增删改查"></a>6、<code>EF Core</code>数据的增删改查</h1><h2 id="6-1-数据的插入"><a href="#6-1-数据的插入" class="headerlink" title="6.1  数据的插入"></a>6.1  数据的插入</h2><p><code>TestDbContext</code>类中的<code>Books</code>属性对应数据库中的<code>T_Books</code>表，<code>Books</code>属性是<code>DbSet&lt;Book&gt;</code>类型的。因此我们只要创建<code>Book</code>对象，并且给该对象中属性赋值，然后在添加到<code>Books</code>这个对应的<code>DSet</code>中，但是要注意的是<code>Books</code>这个<code>DbSet</code>中的数据只是修改了内存中的数据，最后还需要调用异步方法<code>SaveChangesAsync</code>把修改保存到数据库。其实<code>DbContext</code>中也有同步的保存方法<code>SaveChanges</code>，但是采用异步方法通常能提升系统的并发处理能力，因此我们推荐使用异步方法</p>
<p>代码如下所示：修改<code>Program.cs</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ConsoleApp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (TestDbContext ctx = <span class="keyword">new</span> TestDbContext()) <span class="comment">// 创建TestDbContext对象</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 集合初始化器的写法</span></span><br><span class="line">    <span class="keyword">var</span> book1 = <span class="keyword">new</span> Book() &#123; Title = <span class="string">&quot;C#入门到精通&quot;</span>, AuthorName = <span class="string">&quot;laowang&quot;</span>, Price = <span class="number">50</span>, PubTime = <span class="keyword">new</span> DateTime(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">3</span>) &#125;;</span><br><span class="line">    <span class="keyword">var</span> book2 = <span class="keyword">new</span> Book() &#123; Title = <span class="string">&quot;C#高级&quot;</span>, AuthorName = <span class="string">&quot;张三&quot;</span>, Price = <span class="number">60</span>, PubTime = <span class="keyword">new</span> DateTime(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">3</span>) &#125;;</span><br><span class="line">    <span class="keyword">var</span> book3 = <span class="keyword">new</span> Book() &#123; Title = <span class="string">&quot;.Net Core&quot;</span>, AuthorName = <span class="string">&quot;李四&quot;</span>, Price = <span class="number">80</span>, PubTime = <span class="keyword">new</span> DateTime(<span class="number">2022</span>, <span class="number">6</span>, <span class="number">6</span>) &#125;;</span><br><span class="line">    ctx.Books.Add(book1);</span><br><span class="line">    ctx.Books.Add(book2);</span><br><span class="line">    ctx.Books.Add(book3);</span><br><span class="line">  <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>TestDbContext</code>的父类<code>DbContext</code>实现了<code>IDisposable</code>接口，因此<code>TestDbContext</code>对象需要使用using代码块进行资源的释放。</p>
<p>以上就完成了数据的插入操作。</p>
<p>在数据插入的时候，我们只有调用了<code>SaveChangesAsync</code>这个方法才会将数据真正的插入到数据库。而该方法返回值是一个整数，表示影响的行数，也就是向数据库中插入数据的条数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line">   person.Age = <span class="number">18</span>;</span><br><span class="line">   person.Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">   person.Birthday = <span class="keyword">new</span> DateTime(<span class="number">2008</span>, <span class="number">12</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">   person2.Age = <span class="number">19</span>;</span><br><span class="line">   person2.Name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">   person2.Birthday = <span class="keyword">new</span> DateTime(<span class="number">2007</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   ctx.Persons.Add(person);</span><br><span class="line">   ctx.Persons.Add(person2);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">int</span> i=   <span class="keyword">await</span> ctx.SaveChangesAsync(); <span class="comment">// 这里打印的结果是2，表示插入了两条记录。</span></span><br><span class="line">   Console.WriteLine(i);</span><br></pre></td></tr></table></figure>

<p>同时，当数据插入成功以后，对应的<code>person</code>对象中<code>Id</code>属性的值是数据库中所插入记录的主键<code>Id</code>值。</p>
<h2 id="6-2-数据查询"><a href="#6-2-数据查询" class="headerlink" title="6.2 数据查询"></a>6.2 数据查询</h2><p><code>Books</code>属性和数据库中的<code>T_Books</code>表对应，<code>Books</code>属性是<code>DbSet&lt;Book&gt;</code>类型的，而<code>DbSet</code>实现了<code>IEnumerable&lt;T&gt;</code>接口，因此我们可以使用<code>LINQ</code>操作对<code>DbSet</code>进行数据查询.</p>
<p>查询所有的书</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;打印所有的书&quot;</span>);</span><br><span class="line"> <span class="keyword">var</span> books = ctx.Books; </span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)</span><br><span class="line">  &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">$&quot;书名=<span class="subst">&#123;book.Title&#125;</span>,价格=<span class="subst">&#123;book.Price&#125;</span>,作者=<span class="subst">&#123;book.AuthorName&#125;</span>,出版日期=<span class="subst">&#123;book.PubTime.ToShortDateString()&#125;</span>&quot;</span>); <span class="comment">// ToShortDateString:只展示年月日</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>查询价格大于50的书</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;Book&gt; books= ctx.Books.Where(b =&gt; b.Price &gt; <span class="number">50</span>); </span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;书名=<span class="subst">&#123;book.Title&#125;</span>,价格=<span class="subst">&#123;book.Price&#125;</span>,作者=<span class="subst">&#123;book.AuthorName&#125;</span>,出版日期=<span class="subst">&#123;book.PubTime.ToShortDateString()&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上使用了<code>where</code>方法进行过滤，它返回的是<code>IQueryable</code>，但是它继承了<code>IEnumerable</code>，当然，我们为了省事，一般都是写成<code>var</code></p>
<p><code>EF Core</code>会将我们写的<code>Linq</code>最终转换成<code>Sql</code>语句。</p>
<p>查询编号为3的书</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = ctx.Books.Where(b=&gt;b.Id==<span class="number">3</span>).FirstOrDefault(); <span class="comment">//  var book = ctx.Books.FirstOrDefault(b =&gt; b.Id == 3); 以上过滤也可以省略Where方法</span></span><br><span class="line">    <span class="keyword">if</span> (book == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;没有查询到&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;书名=<span class="subst">&#123;book.Title&#125;</span>,价格=<span class="subst">&#123;book.Price&#125;</span>,作者=<span class="subst">&#123;book.AuthorName&#125;</span>,出版日期=<span class="subst">&#123;book.PubTime.ToShortDateString()&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>OrderBy</code>方法对数据进行排序</p>
<p>按照书的价格进行降序排序</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> books =  ctx.Books.OrderByDescending(b =&gt; b.Price);</span><br><span class="line">   <span class="keyword">foreach</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine(<span class="string">$&quot;书名=<span class="subst">&#123;book.Title&#125;</span>,价格=<span class="subst">&#123;book.Price&#125;</span>,作者=<span class="subst">&#123;book.AuthorName&#125;</span>,出版日期=<span class="subst">&#123;book.PubTime.ToShortDateString()&#125;</span>&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用<code>GroupBy</code>方法对数据进行分组.</p>
<p>根据作者的名字进行分组，然后输出每一组中的数据条数及最高价格.(这里需要先向表中增加一条同名作者的记录，方便测试)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> groups = ctx.Books.GroupBy(b =&gt; b.AuthorName).Select(g =&gt; <span class="keyword">new</span> &#123; AuthorName = g.Key, BooksCount = g.Count(), MaxPrice = g.Max(b =&gt; b.Price) &#125;);</span><br><span class="line">   <span class="keyword">foreach</span>(<span class="keyword">var</span> g <span class="keyword">in</span> groups)</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine(<span class="string">$&quot;作者:<span class="subst">&#123;g.AuthorName&#125;</span>,书的数量:<span class="subst">&#123;g.BooksCount&#125;</span>,最高价格:<span class="subst">&#123;g.MaxPrice&#125;</span>&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-修改和删除数据"><a href="#6-3-修改和删除数据" class="headerlink" title="6.3 修改和删除数据"></a>6.3 修改和删除数据</h2><p>修改数据：</p>
<p>如果要对数据进行修改，我们首先需要把要修改的数据查询出来，然后对查询出来的数据进行修改，再执行<code>SaveChangesAsync</code>保存修改即可.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = ctx.Books.FirstOrDefault(b =&gt; b.Id == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">if</span> (book != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      book.Title = <span class="string">&quot;.Net 全栈开发&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br></pre></td></tr></table></figure>

<p>同样，要对数据进行删除，我们要先把待删除的数据查询出来，然后调用<code>DbSet</code>或者<code>DbContext</code>的<code>Remove</code>方法把数据删除，再执行<code>SaveChangesAsync</code>方法保存结果到数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = ctx.Books.FirstOrDefault(b =&gt; b.Id == <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (book != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ctx.Books.Remove(book); <span class="comment">// 或者是 ctx.Remove(book);</span></span><br><span class="line">        <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，无论是上面的修改数据的代码还是删除数据的代码，都是要先执行数据的查询操作，把数据查询出来，再执行修改或者删除操作。这样在<code>EF Core</code>的底层其实发生了先执行<code>Select</code>的<code>SQL</code>语句，然后执行<code>Update</code>或者<code>Delete</code>的<code>SQL</code>语句。</p>
<h1 id="7、实体类配置"><a href="#7、实体类配置" class="headerlink" title="7、实体类配置"></a>7、实体类配置</h1><h2 id="7-1-规则说明"><a href="#7-1-规则说明" class="headerlink" title="7.1  规则说明"></a>7.1  规则说明</h2><p>通过前面的学习，我们知道作为<code>ORM</code>框架，<code>EF Core</code>要完成实体类与数据库表的映射，以及实体类的属性与数据库表的列映射</p>
<p>在<code>BookEntityConfig.cs</code>这个文件中，在其对应的<code>Configure</code>方法中，通过<code> builder.ToTable(&quot;T_Books&quot;);</code>这行代码，实现了将类型<code>DbSet&lt;Book&gt;</code>类型的<code>Books</code>属性与<code>T_Books</code>表进行了映射。</p>
<p>但是如果我们不添加<code>builder.ToTable(&quot;T_Books&quot;);</code>这行代码，默认的表名就是<code>Books</code>，也就是与<code>DbSet&lt;Book&gt;</code>类型对应的<code>Books</code>属性同名。这其实就是<code>EF Core</code>的默认规则。</p>
<p>当然，在很多情况下使用默认的规则是完全可以的，如果默认的规则不满足需求的时候，我们可以显示的指定相应的规则。</p>
<p>下面我们看一下关于<code>EF Core</code>中主要的一些默认约定的规则。</p>
<p>第一：数据表的名称会与<code>DbSet</code>类型的属性同名。</p>
<p>第二：数据表中的字段的名字与实体类中属性名字一致，并且字段的类型采用的是和实体类中属性类型兼容的类型。比如在<code>SQLServer</code>中，<code>nvarchar</code>对应的<code>string</code>,<code>bigint</code>对应的是<code>long</code>类型。</p>
<p>第三：数据表中的字段是否允许为空，取决于对应的实体类属性的可空性。</p>
<p>例如，<code>Person</code>类中的<code>Name</code>属性,这里指定了属性是可空的，对应的表中的<code>Name</code>字段也是允许为空的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>第四：名字为<code>Id</code>的属性为主键，如果主键为<code>short</code>、<code>int</code>或者<code>long</code>类型，则主键默认采用自动增长类型的列。</p>
<h2 id="7-2-Data-Annotation"><a href="#7-2-Data-Annotation" class="headerlink" title="7.2 Data Annotation"></a>7.2 <code>Data Annotation</code></h2><p>在前面的可成中，我们对实体类进行配置的时候，都是将相关的配置代码写到了一个实现了<code>IEntityTypeConfiguration</code>接口的文件中，这种配置方式我们一般叫做<code>Fluent API``。当然，在``EF Core</code>中还有另外的一种针对实体类进行配置的方式，就是可以使用<code>.Net</code>提供的<code>Attribute</code>对实体类以及对应的属性进行标注，通过这种标注的方式来完成对实体类的配置。例如，我们可以通过<code>[Table(&quot;T_Books&quot;)]</code>,把实体类对应的表名配置为<code>T_Books</code>,</p>
<p>通过<code>[Required]</code>，我们可以把属性对应的数据库表字段配置为“不可为空”；通过<code>[MaxLength(20)]</code>，我们可以把属性对应的数据库表字段配置为“最大长度为20”，”[Key]”表示主键， 这种通过标注的方式来完成的配置，我们称作为<code>Data Annotaion(数据注释)</code></p>
<p>在项目中创建创建<code>Student.cs</code>类，该类中定义的属性如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Table(<span class="string">&quot;T_Students&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        [<span class="meta">MaxLength(20)</span>]</span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? StuName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        [<span class="meta">MaxLength(50)</span>]</span><br><span class="line">        [<span class="meta">Required</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Address &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>Student</code>这个实体类中添加了<code>[Table]</code>，并且给属性添加了<code>[MaxLength],</code>[Required]&#96;.</p>
<p>这里需要注意的一点就是，既然这里我们采用了标注的这种方式来完成配置，就不需要再创建一个实现了<code>IEntityTypeConfiguration</code>泛型接口的类来完成配置了。</p>
<p>下面修改<code>TestDbContext.cs</code>类文件中的代码，</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> DbSet&lt;Book&gt; Books &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> DbSet&lt;Person&gt; Persons &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> DbSet&lt;Student&gt; Students &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，添加了<code>Students</code>这个<code>DbSet</code>类型的属性。表示<code>T_Students</code>这个数据表与当前的<code>Students</code>属性建立了映射的关系。</p>
<p>下面执行数据迁移的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration AddStudent</span><br><span class="line"></span><br><span class="line"> Update-database</span><br></pre></td></tr></table></figure>

<p>完成数据迁移的操作以后，刷新数据库<code>Test</code>，可以看到在该数据库中创建了<code>T_Students</code>表，同时表中的字段以及字段的类型按照相应的配置也已经创建好了。</p>
<p>通过对比，我们发现<code>Data Annotation</code>这种方式更加的简单，只需要在实体类以及对应的属性上添加<code>Attribute</code>就可以了，我们不再单独的写配置类了，但是<code>Fluent API</code>是微软官方推荐的使用方式</p>
<p>主要有两点原因：</p>
<p>第一：<code>Fluent API</code>这种方式体现了职责分明。实体类中只定义属性，不涉及到数据库配置相关的内容，针对数据库相关的配置都单独的放到配置类中，这样方便进行管理。</p>
<p>第二：<code>Fluent API</code>功能更强大，<code>Fluent API</code>几乎实现了<code>Data Annotation</code>所有的功能，而<code>Data Annotation</code>则不支持<code>Fluent API</code>的一些功能。</p>
<p><code>Data Annotation</code>和<code>Fluent API</code>是可以一起使用的。如果同样的内容用这两种方式都配置了，那么<code>Fluent API</code>的优先级高于<code>Data Annotation</code>的优先级。比如一个实体类上既添加了<code>[Table(&quot;TableFromAttribute&quot;)]</code>，又设置了<code>ToTable(&quot;TableFromFluent&quot;)</code>，那么<code>EF Core</code>认为配置的数据库表名是<code>TableFromFluent</code>。</p>
<p>关于实体类的配置在开发社区有两种方案：</p>
<p>第一：混合方案：优先使用<code>Data Annotation</code>，因为<code>Data Annotation</code>的使用更简单。在<code>Data Annotation</code>无法实现的地方，再使用<code>Fluent API</code>进行配置。但是个人不建议采用这种方式，容易造成混乱。</p>
<p>第二：单一方案：只使用<code>Fluent API</code>。</p>
<p>后面我们使用的配置方式也是<code>Fluent API</code>这种方式。</p>
<p>在下一小节中，我们再来看一下关于<code>Fluent API</code>中的其他的一些基本配置。</p>
<h2 id="7-3-Fluent-API基本配置"><a href="#7-3-Fluent-API基本配置" class="headerlink" title="7.3 Fluent API基本配置"></a>7.3 <code>Fluent API</code>基本配置</h2><p>在这一小节中，我们只是看一下关于<code>Fluent API</code>的一些基本的配置，不在做演示。</p>
<p><strong>1、排除属性</strong></p>
<p>默认情况下，一个实体类的所有属性都会映射到数据库表中作为表的字段，如果想让<code>EF Core</code>忽略一个属性，就可以用<code>Ignore</code>配置。比如下面的代码表示把<code>Person</code>实体类中的<code>Age</code>属性排除：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Person</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">        builder.Ignore(b =&gt; b.Age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、字段名</strong></p>
<p>默认情况下数据表中的字段名与实体类中的属性名是一样的，如果想不一样，可以通过<code>HasColumnName</code>方法来进行配置一个不同的字段名。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">         <span class="comment">/* builder.Ignore(b =&gt; b.Age);*/</span></span><br><span class="line">         builder.Property(b =&gt; b.Id).HasColumnName(<span class="string">&quot;person_id&quot;</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们将<code>Id</code>修改成了<code>person_id</code>.</p>
<p><strong>3、 字段类型</strong></p>
<p><code>EF Core</code>默认会根据实体类的属性类型、最大长度等确定字段的数据类型，我们可以使用<code>HasColumnType</code>为列指定数据类型。比如<code>EF Core</code>在<code>SQL Server</code>数据库中对于<code>string</code>类型的属性，默认生成<code>nvarchar</code>类型的字段，我们可以通过下面的代码把列的数据类型改为<code>varchar</code>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">          <span class="comment">/* builder.Ignore(b =&gt; b.Age);*/</span></span><br><span class="line">          <span class="comment">/* builder.Property(b =&gt; b.Id).HasColumnName(&quot;person_id&quot;);*/</span></span><br><span class="line">          builder.Property(b =&gt; b.Name).HasColumnType(<span class="string">&quot;varchar(100)&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>4、主键</strong></p>
<p>在<code>EF Core</code>中默认会将<code>Id</code>属性作为主键，当然我们也可以让其他的属性作为主键，这时候就需要使用<code>HasKey</code>方法来进行配置，如下所示所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">           <span class="comment">/* bulilder.Ignore(b =&gt; b.Age);*/</span></span><br><span class="line">           <span class="comment">/* builder.Property(b =&gt; b.Id).HasColumnName(&quot;person_id&quot;);*/</span></span><br><span class="line">          <span class="comment">/* builder.Property(b =&gt; b.Name).HasColumnType(&quot;varchar(100)&quot;);*/</span></span><br><span class="line">          builder.HasKey(x =&gt; x.Age); <span class="comment">// 这里是让Age属性作为主键。</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>在实际应用中还是建议将<code>Id</code>作为主键。</p>
<p><strong>5、设置默认值</strong></p>
<p>这里我们也可以设置属性的默认值，对应的映射到的字段中也会有默认值。</p>
<p>设置默认值需要使用到<code>HasDefaultValue</code>方法，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">    <span class="comment">/* builder.Ignore(b =&gt; b.Age);*/</span></span><br><span class="line">    <span class="comment">/* builder.Property(b =&gt; b.Id).HasColumnName(&quot;person_id&quot;);*/</span></span><br><span class="line">    <span class="comment">/* builder.Property(b =&gt; b.Name).HasColumnType(&quot;varchar(100)&quot;);*/</span></span><br><span class="line">    <span class="comment">/* builder.HasKey(x =&gt; x.Age);*/</span></span><br><span class="line">    builder.Property(b =&gt; b.Age).HasDefaultValue(<span class="number">18</span>); </span><br></pre></td></tr></table></figure>

<p>在上面的代码中，将<code>Age</code>属性的默认值设置为18.</p>
<p><strong>6、索引</strong></p>
<p><code>EF Core</code>中可以用<code>HasIndex</code>方法配置索引,如果下面代码所示</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">           <span class="comment">/* builder.Ignore(b =&gt; b.Age);*/</span></span><br><span class="line">           <span class="comment">/* builder.Property(b =&gt; b.Id).HasColumnName(&quot;person_id&quot;);*/</span></span><br><span class="line">           <span class="comment">/* builder.Property(b =&gt; b.Name).HasColumnType(&quot;varchar(100)&quot;);*/</span></span><br><span class="line">           <span class="comment">/* builder.HasKey(x =&gt; x.Age);*/</span></span><br><span class="line">           builder.HasIndex(x =&gt; x.Name); <span class="comment">// 为Name添加索引</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以将多个属性设置为复合索引</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">           <span class="comment">/* builder.Ignore(b =&gt; b.Age);*/</span></span><br><span class="line">           <span class="comment">/* builder.Property(b =&gt; b.Id).HasColumnName(&quot;person_id&quot;);*/</span></span><br><span class="line">           <span class="comment">/* builder.Property(b =&gt; b.Name).HasColumnType(&quot;varchar(100)&quot;);*/</span></span><br><span class="line">           <span class="comment">/* builder.HasKey(x =&gt; x.Age);*/</span></span><br><span class="line">           <span class="comment">/*builder.Property(b =&gt; b.Age).HasDefaultValue(18);*/</span></span><br><span class="line">           builder.HasIndex(x =&gt; <span class="keyword">new</span> &#123;x.Name,x.Age &#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>构建复合索引就是给<code>HasIndex</code>方法传递一个匿名类对象，在该匿名类对象中指定构建复合索引所需要的多个属性即可。</p>
<p>在默认情况下，<code>EF Core</code>中定义的索引不是聚集索引，我们可以使用<code>IsClustered</code>方法把索引设置为聚集索引。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">           <span class="comment">/* builder.Ignore(b =&gt; b.Age);*/</span></span><br><span class="line">           <span class="comment">/* builder.Property(b =&gt; b.Id).HasColumnName(&quot;person_id&quot;);*/</span></span><br><span class="line">           <span class="comment">/* builder.Property(b =&gt; b.Name).HasColumnType(&quot;varchar(100)&quot;);*/</span></span><br><span class="line">           <span class="comment">/* builder.HasKey(x =&gt; x.Age);*/</span></span><br><span class="line">           <span class="comment">/*builder.Property(b =&gt; b.Age).HasDefaultValue(18);*/</span></span><br><span class="line">           <span class="comment">/*builder.HasIndex(x =&gt; new &#123;x.Name,x.Age &#125;);*/</span></span><br><span class="line">           builder.HasIndex(x =&gt; x.Name).IsClustered(); <span class="comment">// 聚集索引</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>如果是唯一所索引，使用<code>IsUnique</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.HasIndex(x =&gt; x.Name).IsUnique();</span><br></pre></td></tr></table></figure>

<p>关于索引不太了解的同学，请看一下数据库相关的课程。</p>
<p><strong>7、方法重载</strong></p>
<p>在使用<code>Fluent API</code>的时候还有一点需要注意，<code>Fluent API</code>中的很多方法都有多个重载方法.</p>
<p>例如<code>HasIndex</code>,设置索引可以有如下两种方式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.HasIndex(x =&gt; x.Name);</span><br><span class="line">           builder.HasIndex(<span class="string">&quot;Name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同样地，用来获取实体类属性的<code>Property</code>方法也有多个重载方法，例如：把<code>Id</code>属性对应的数据表中的字段定义为<code>person_id</code>，有两种方式。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.Property(b =&gt; b.Id).HasColumnName(<span class="string">&quot;person_id&quot;</span>);</span><br><span class="line">           builder.Property(<span class="string">&quot;Id&quot;</span>).HasColumnName(<span class="string">&quot;person_id&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里个人建议使用<code>lambda</code>表达式的写法，</p>
<p>因为这样可以利用<code>C#</code>的强类型检查机制，如果属性名字被写错了，编译器会报错。如果用<code>Property(&quot;Number&quot;)</code>这种写法，我们的拼写错误是没有那么容易被发现的。</p>
<p>以上这些特性根据自己的实际情况来使用。</p>
<p>更多关于<code>Fluent API</code>可以参考文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://learn.microsoft.com/zh-cn/ef/core/modeling/entity-properties?source=recommendations&amp;tabs=data-annotations%2Cwithout-nrt</span><br></pre></td></tr></table></figure>

<h1 id="8、数据库迁移原理"><a href="#8、数据库迁移原理" class="headerlink" title="8、数据库迁移原理"></a>8、数据库迁移原理</h1><p>通过使用<code>Add-Migration</code>和<code>Update-database</code>两个命令，我们对于<code>EF Core</code>的数据库迁移有了基本的了解.</p>
<p>在这一小节中，我们来看一下迁移的一些原理。</p>
<p>我们知道<code>Migrations</code>文件夹下的内容都是数据库迁移生成的代码，这些代码记录了对数据库的修改操作，一般情况下我们无须手工修改这些代码，而且每次执行<code>Add-Migration</code>命令之后，在<code>Migrations</code>文件夹下面都会生成两个文件，一个文件的名字是<code>数字_迁移名字.cs</code>，另外一个文件的名字是”<code>数字_迁移名字.Designer.cs</code>“.而我们将每一次执行<code>Add-Migration</code>命令称作一次<code>迁移</code>。这些以数字开头的一组文件就对应了一次迁移，这些迁移开头的数字就是迁移的历史版本号，这些历史版本号是递增的，因此我们根据这些历史的版本号就知道数据库进行了哪些迁移。</p>
<p><strong>当然，我们并不是修改了一个属性就进行迁移，而是根据实际情况，完成了某个功能或者是某个模块对应的实体类修改后，才会进行一次的迁移操作。</strong></p>
<p>下面我们再来看一下迁移脚本文件中的代码。</p>
<p>先看一下<code>20230311094632_InitialCreate.cs</code>这个文件，在这个文件中有两个方法，分别是<code>UP</code>和<code>Down</code>方法。</p>
<p>我们看到<code>20230311094632_InitialCreate.cs</code>这个文件中<code>UP</code>方法中的代码就是调用了<code>CreateTable</code>方法，创建了<code>T_Books</code>这个表，并且定义了实体类中的属性与表中字段之间的对应关系。而<code>Down</code>方法中则调用了<code>DropTable</code>这个方法把<code>T_Books</code>表删除，相当于一个回滚的操作。</p>
<p>下面我们再来看一下<code>20230311131014_AddPerson.cs</code>这个文件，该 文件中的<code>UP</code>方法中创建了<code>T_Persons</code>这张表，<code>Down</code>方法删除了<code>T_Persons</code>这个表，还有一个文件是<code>20230311133051_AddBirthday.cs</code>（这个版本号比上一个文件大，表示最新的操作），在它的<code>UP</code>方法中向<code>T_Persons</code>表中添加了<code>Birthday</code>这个字段，而<code>Down</code>方法中从<code>T_Person</code>这张表中删除了<code>Birthday</code>这个字段。</p>
<p>下面我们再来看一下<code>20230311094632_InitialCreate.Designer.cs</code>这个<code>Designer</code>文件。</p>
<p>这个文件中使用了<code>partial</code>这个关键字定义了部分类，其实<code>20230311094632_InitialCreate.cs</code>这个文件中也是通过<code>partial定义的部分类</code>，这样共同构成了一个完整的<code>InitialCreate</code>类。</p>
<p>在<code>20230311094632_InitialCreate.Designer.cs</code>这个文件中，我们可以看到有如下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DbContext(typeof(TestDbContext))</span>]</span><br></pre></td></tr></table></figure>

<p>表示迁移脚本是有哪个<code>DbContext</code>来执行。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Migration(<span class="string">&quot;20230311094632_InitialCreate&quot;</span>)</span>]</span><br></pre></td></tr></table></figure>

<p>表示<code>DbContext</code>要执行的迁移脚本的版本号。</p>
<p>在下面的<code>BuildTargetModel</code>方法中，完成的主要工作就是通过<code>HasColumnType</code>这个方法确定了实体类中属性最终所生成的与之对应的字段类型。例如：<code>Title</code>这个属性最终生成的字段的类型是<code>nvarchar(max)</code>.</p>
<p><code>TestDbContextModelSnapshot.cs</code>这个文件中定义了所有属性所对应的表中字段的类型，是否为空等信息。</p>
<p>注意：</p>
<p>如果解决方案中有多个项目，在执行<code>Add-Migration</code>等命令的时候，一定要确认在【程序包管理器控制台】中选中的是要迁移的项目。</p>
<h1 id="9、其他数据库迁移命令"><a href="#9、其他数据库迁移命令" class="headerlink" title="9、其他数据库迁移命令"></a>9、其他数据库迁移命令</h1><p>除了<code>Add-migration、Update-database</code>这两个常用命令之外，<code>EF Core</code>还提供了其他一些数据库迁移命令。这些命令被使用的机会相对来讲比较少，这里只介绍常用的功能。</p>
<p><strong>(1) <code>Update-database</code>其他参数</strong></p>
<p>在使用<code>Update-database</code>这个命令的时候，我们可以在后面添加参数。所添加的参数是<strong>迁移文件的版本号</strong>，这样就可以回滚到所写的版本号迁移脚本对应的状态。注意：这个命令只是把当前链接的数据库进行回滚，迁移的脚本文件不会删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Update-database 20230311131014_AddPerson</span><br></pre></td></tr></table></figure>

<p>通过以上命令，我们可以看到混滚到了<code>AddPerson</code>这个状态，对应的<code>Test</code>数据库中的<code>__EFMigrationsHistory</code>中只保留了<code>20230311094632_InitialCreate</code>和<code>20230311131014_AddPerson</code>这两个状态。同时，我们可以看到在<code>T_Persons</code>表中已经没有了<code>Birthday</code>这个字段，因为添加<code>Birthday</code>这个字段是有<code>20230311133051_AddBirthday.cs</code>这个迁移脚本文件完成的，现在回滚到它之前的<code>20230311131014_AddPerson</code>这个状态，所以<code>Birthday</code>这个字段就被删除了，同时<code>T_Students</code>表也被删除了。</p>
<p>但是，我们查看<code>Migrations</code>文件夹的时候，发现所有的迁移脚本文件还是存在的。</p>
<p>如果这时候，我们又执行了<code>Update-database</code>这个命令，但是这时候我们没有给该命令添加任何的参数，它会执行所有的数据库迁移脚本文件，这样数据库中又创建了对应的表和字段。</p>
<p><strong>(2)  删除脚本文件</strong></p>
<p>如果某个迁移的脚步文件不需要了，可以将其删除。但是在删除的时候一定要注意，不要直接手动将<code>Migrations</code>文件夹下的脚步文件删除，这样有可能会破坏脚本文件之间的历史关系。</p>
<p>最好通过<code>Remove-migration</code>命令来进行删除。</p>
<p>使用该命令的时候，它后面不需要添加参数。</p>
<p>执行一次该命令就可以将最后一次生成的迁移脚本文件，如果想把所有的迁移脚本文件都删除，可以多次执行该命令。</p>
<p>大家可以自己演示。</p>
<p><strong>(3)生成<code>SQL</code>脚本</strong></p>
<p>当我们执行了<code>Update-database</code>这个命令以后会执行迁移脚本文件来修改数据库中的内容，例如新建表，创建字段或者是删除字段等操作。</p>
<p>但是，这种方式只是适合开发环境，也就是我们在开发项目的时候使用该命令。但是在生产环境中，是不允许是使用该命令的。也就是不能直接针对生产环境的数据库进行操作。因为很多公司要求对生产环境中的数据库进行操作需要进行审核，一般都是有数据库管理员审核一下对应的<code>SQL</code>脚本，发现没有问题了，才会进行操作。而<code>Update-database</code>这个命令是不满足这种需求的。而且，大部分公司的开发环境也是不能直接链接生产环境中的数据库的。</p>
<p>为了满足以上的需求，<code>EF Core</code>中提供了<code>Script-Migration</code>命令来根据迁移脚本文件生成<code>SQL</code>脚本，但是这个<code>SQL</code>脚本并没有执行，有数据库管理员审核通过了，才会在生产环境中执行</p>
<p>我们可以在【程序包管理控制】中直接输入<code>Script-Migration</code>命令，执行该命令后会生成一个完整的<code>SQL</code>脚本文件。</p>
<p>审核这个<code>SQL</code>脚本文件没有问题以后，可以直接拷贝到<code>SQLServer</code>中进行执行。</p>
<p><strong>现在有一个问题：我们仅仅是在<code>Person</code>这个实体类中添加了<code>Birthday</code>属性</strong></p>
<p>如果执行<code>Script-Migration</code>命令，我们可以看到所生成的<code>SQL</code>脚本中包含了<code>CREATE TABLE [T_Persons]</code>的操作，也就是创建<code>Person</code>这个实体类对应的<code>T_Persons</code>这张表，但是问题是，数据库中已经有<code>T_Persons</code>这张表了，在执行<code>Create Table</code>的操作不合适。</p>
<p>那么应该怎样进行处理呢？</p>
<p>可以输入如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Script-Migration AddPerson AddBirthday</span><br></pre></td></tr></table></figure>

<p>第一个参数表示的是当前版本(<code>AddPerson</code>是迁移脚本文件名，注意这里不用写历史编号)到最新版本<code>AddBirthday</code>的<code>SQL</code>脚本。</p>
<p><code>AddPerson</code>这个版本对应的<code>迁移脚本</code>中只是创建了<code>T_Persons</code>这个表，并且创建了对应的<code>Id,Name,Age</code>字段</p>
<p><code>AddBirthday</code>这个版本中创建了<code>Birthday</code>字段。</p>
<p>这时候生成的<code>SQL</code>脚本，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [T_Persons] <span class="keyword">ADD</span> [Birthday] datetime2 <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0001-01-01T00:00:00.0000000&#x27;</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [__EFMigrationsHistory] ([MigrationId], [ProductVersion])</span><br><span class="line"><span class="keyword">VALUES</span> (N<span class="string">&#x27;20230311133051_AddBirthday&#x27;</span>, N<span class="string">&#x27;7.0.3&#x27;</span>);</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line">GO</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面的<code>SQL</code>脚本，我们可以看到修改了<code>T_Person</code>表，向该表中添加了<code>Birthday</code>这个字段，同时会向<code>EFMigrationsHistory</code>表中插入一条历史记录。</p>
<p>但是要注意的是，该<code>SQL</code>脚本并没有执行，可以拷贝到<code>SQLServer</code>中执行。</p>
<p>以上就是比较常用的数据库迁移命令。</p>
<h1 id="10、反向工程"><a href="#10、反向工程" class="headerlink" title="10、反向工程"></a>10、反向工程</h1><p>我们在使用<code>EF Core</code>的时候，推荐代码优先的使用方式，这种方式我们称作<code>Code First</code>,也就是先创建实体类，然后根据实体类生成数据库与表。</p>
<p>但是在实际的项目开发中，我们也会遇到数据库和表已经存在了的情况，例如公司中会有一些旧的项目，需要升级。而这些旧项目对应的数据库中已经有相应的表了，这时候我们就需要根据已经存在的数据表生成实体类，这种开发的方式称作<code>DB First</code>.</p>
<p>但是，大家在做新项目的时候，还是建议使用<code>Code First</code>这种开发方式</p>
<p>重新创建一个项目进行演示。</p>
<p>当然，在新创建的项目中也要安装<code>EF Core</code>所需要的包。</p>
<p>这里我们可以通过一种简单的方式安装<code>EF Core</code>的包，可以单击第一次创建的项目，从打开的文件中将如下的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.EntityFrameworkCore.SqlServer&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;7.0.3&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.EntityFrameworkCore.Tools&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;7.0.3&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">PrivateAssets</span>&gt;</span>all<span class="tag">&lt;/<span class="name">PrivateAssets</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">IncludeAssets</span>&gt;</span>runtime; build; native; contentfiles; analyzers; buildtransitive<span class="tag">&lt;/<span class="name">IncludeAssets</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">PackageReference</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>拷贝到新的项目中，当然这里需要单击新项目名称，在打开的文件中添加如上的配置。这样就可以在新项目中安装以上的包了。</p>
<p>下面，在【程序包管理器控制台】中执行如下的命令（注意：这里在【程序包管理器控制台】中一定要选择新创建的项目名称）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scaffold-DbContext &#x27;server=.;database=Test;uid=sa;password=123456;TrustServerCertificate=true&#x27;</span><br><span class="line">Microsoft.EntityFrameworkCore.SqlServer</span><br></pre></td></tr></table></figure>

<p>执行完以上的命令以后，就可以看到在项目中创建了对应的实体类与<code>DbContext</code>.(<code>TestContext.cs</code>)</p>
<p>打开<code>TestContext.cs</code>文件可以看到在该文件中创建了对应的<code>DbSet</code>,在<code>OnModelCreating</code>方法中完成了表的创建以及字段的创建。这里没有帮我们创建一个实现了<code>IEntityTypeConfiguration</code>接口的文件。其实通过这一一点，我们也能够体会出，这种<code>DB First</code>开发方式不太友好的地方，就是<code>OnModelCreating</code>方法会变得比较臃肿。</p>
<p>同时这种开发方式生成的实体类也不太符合我们的需求。数据表的名称是<code>T_实体类名称的复数形式</code>，而反向工程操作以后生成的类型是<code>TBook</code>这样的类名，而不是我们希望的<code>Book</code>这样的类名。因此反向工程生成的代码还需要我们手动修改。</p>
<p>综上所述，反向工程只是适合老项目中已经有表了，现在需要根据表创建对应的实体类，当然还需要修改一下创建的实体类。</p>
<p>否则，无论是在老项目中添加新模块，还是进行新项目的开发，建议大家都使用<code>Code First</code>这种开发方式。</p>
<h1 id="11、查看EF-Core生成的SQL语句"><a href="#11、查看EF-Core生成的SQL语句" class="headerlink" title="11、查看EF Core生成的SQL语句"></a>11、查看<code>EF Core</code>生成的<code>SQL</code>语句</h1><p>通过前面的学习我们知道，使用了<code>EF Core</code>以后，一般情况下就不需要编写<code>SQL</code>语句了。在程序开发过程中，我们只需要写<code>c#</code>代码对实体类进行操作就可以了。这是因为<code>EF Core</code>会把我们写的<code>C#</code>代码转换成与之对应的<code>SQL</code>语句，然后在有<code>ADO.NET Core</code>交给数据库执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202406242056712.png" alt="1"></p>
<p>所以说<code>EF Core</code>并不是取代<code>Ado.net </code>的，两者是一种合作的关系。</p>
<p>作为开发人员虽然使用了<code>EF Core</code>以后一般情况下不需要写<code>SQL</code>语句了，但是还是很有必要关注<code>EF Core</code>实现的<code>SQL</code>语句到底是怎样的。</p>
<p>比如说：当程序出性能问题以后，开发人员需要检查<code>EF Core</code>生成的<code>SQL</code>语句是否有性能缺陷，再比如说，当程序出现了<code>Bug</code>以后，我们需要检查一下<code>EF Core</code>生成的<code>SQL</code>语句是否和自己的预期是一致的。</p>
<p>下面我们就来看一下查看<code>EF Core</code>生成<code>SQL</code>语句的方式。</p>
<p><strong>（1）使用简单日志查看<code>SQL</code>语句</strong></p>
<p>自<code>EF Core</code>5.0 以后增加了一种”简单日志”的方式来查看程序所执行的<code>SQL</code>语句。</p>
<p>使用方式是在<code>DbContext</code>对应的<code>OnConfiguring</code>方法中调用<code>optionsBuilder</code>类的<code>LogTo</code>方法。给该方法传递一个参数为<code>String</code>的委托即可。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=Test;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">           optionsBuilder.UseSqlServer(connStr);</span><br><span class="line">           optionsBuilder.LogTo(Console.WriteLine);<span class="comment">// 在控制台中打印所要执行的SQL语句，注意，这里的WriteLine不要加小括号</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>下面查看如下代码所生成的<code>SQL</code>语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = ctx.Books.Where(b =&gt; b.Id == <span class="number">3</span>).FirstOrDefault();</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，最终在控制台中查看到了最终所生成的<code>SQL</code>语句。</p>
<p><strong>（2）使用<code>SQL Server Profiler</code>工具查看当前数据库所执行的<code>SQL</code>语句。</strong></p>
<p>选择<code>SQL Server</code>数据库中的<code>工具菜单中的SQL Servder Profiler</code></p>
<p>注意：该工具不仅可以查看当前我们自己程序所执行的<code>sql</code>语句，也可以看到其他开发人员链接我们数据库所执行的<code>sql</code>语句。</p>
<p>总结：<code>EF Core</code>就是把<code>C#</code>代码（例如以上所写的查询代码）转换成<code>SQL</code>语句的框架。</p>
<h1 id="12、一对多关系配置"><a href="#12、一对多关系配置" class="headerlink" title="12、一对多关系配置"></a>12、一对多关系配置</h1><p>在进行项开发的时候，很少有一张表是单独存在的，大部分表之间都是有关系的。作为一个<code>ORM</code>框架，<code>EF CORE</code>不仅能够帮助开发人员简化单张表的处理，在处理表之间的关系上也非常强大。<code>EF Core</code>支持有一对多，多对多，一对一等。</p>
<p>下面我们先来看一下一对多关系的配置。</p>
<p>一对多是比较常见的表之间的关系。比如文章和评论的关系就是一对多的关系，也就是一篇文章对应多条评论。</p>
<p>下面我们就通过文章和评论两个实体类来讲解一对多关系的配置。</p>
<p>首先定义文章的实体类<code>Article</code>和评论的实体类<code>Comment</code>,如下代码所示：</p>
<p><code>Article</code>实体类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Article</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 主键</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 文章标题</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 文章内容</span></span><br><span class="line">       <span class="keyword">public</span> List&lt;Comment&gt; Comments &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;Comment&gt;();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>Comment</code>实体类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Comment</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 主键</span></span><br><span class="line">       <span class="keyword">public</span> Article? Article &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 评论属于哪篇文章</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Message &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125; <span class="comment">// 评论内容</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的实体类中，我们可以看到文章的实体类<code>Article</code>中定义了一个<code>Comment</code>类型的<code>List</code>属性，因为一篇文章可能有多条评论。</p>
<p>在评论的实体<code>Comment</code>中定义了一个<code>Article</code>类型的属性，因为一条评论只能属于一篇文章。</p>
<p>在<code>EF Core</code>中实体类之间关心的配置采用如下的模式：<code>HasXXX().WithYYY(...)</code>的形式。关于<code>XXX,YYY</code>有<code>One</code>和<code>Many</code>两个可选值。</p>
<p>假如我们在<code>A</code>这个实体类中配置<code>builder.HasOne&lt;B&gt;(...).WithMany(...)</code> 表示<code>A和B</code>是“一对多”的关系，也就是一个<code>A</code>实体类的对象对应一个<code>B</code>实体类对象，而一个<code>B</code>实体类的对象有多个<code>A</code>实体类的对象与之对应；</p>
<p>如果在<code>A</code>实体类中配置<code>builder.HasOne&lt;B&gt;(…).WithOne(…)</code>就表示A和B是“一对一”的关系，也就是一个A实体类的对象对应一个B实体类的对象，而一个B实体类的对象也有一个A实体类的对象与之对应.</p>
<p>如果在<code>A</code>实体类中配置<code>builder.HasMany&lt;B&gt;(…).WithMany (…)</code>就表示A和B是“多对多”的关系，也就是一个A实体类的对象对应多个B实体类的对象，而一个B实体类的对象也有多个A实体类的对象与之对应。</p>
<p>了解了配置关系以后，下面我们开始完成<code>Article</code>实体类与<code>Comment</code>实体类之间一对多关系的配置。</p>
<p>配置具体关系之前，在新创建的项目中先安装<code>EF Core</code>所需要的包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">   &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.SqlServer&quot; Version=&quot;7.0.3&quot; /&gt;</span><br><span class="line">   &lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.Tools&quot; Version=&quot;7.0.3&quot;&gt;</span><br><span class="line">     &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;</span><br><span class="line">     &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;</span><br><span class="line">   &lt;/PackageReference&gt;</span><br><span class="line"> &lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure>

<p>下面创建<code>ArticleConfig</code>类实现<code>IEntityTypeConfiguration&lt;Article&gt;</code>泛型接口，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ArticleConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Article</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Article&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Articles&quot;</span>);</span><br><span class="line">            builder.Property(a =&gt; a.Content).IsRequired();</span><br><span class="line">            builder.Property(a =&gt; a.Title).IsRequired().HasMaxLength(<span class="number">255</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面创建<code>CommentConfig</code>类实现<code>IEntityTypeConfiguration&lt;Comment&gt;</code>泛型接口。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommentConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Comment</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Comment&gt; builder</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          builder.ToTable(<span class="string">&quot;T_Comments&quot;</span>);</span><br><span class="line">          builder.Property(c =&gt; c.Message).IsRequired();</span><br><span class="line">          builder.HasOne&lt;Article&gt;(c=&gt;c.Article).WithMany(a=&gt;a.Comments).IsRequired(); <span class="comment">//IsRequired表示Comment中的Article属性是不可以为空的</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，对于一对多的关系配置，主要通过如下代码完成</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.HasOne&lt;Article&gt;(c=&gt;c.Article).WithMany(a=&gt;a.Comments).IsRequired();<span class="comment">// 简单理解：我有一篇文章，文章有多条评论</span></span><br></pre></td></tr></table></figure>

<p>因为这个关系的配置写在了<code>Comment</code>实体类的配置中，所以这行代码的意思就是”一条评论对应一篇文章，一篇文章有多条评论”。</p>
<p><code>HasOne&lt;Article&gt;(c=&gt;c.Article)</code>中的<code>Lambda</code>表达式<code>c=&gt;c.Article</code>表示<code>Comment</code>类的Article属性是指向Article实体类型的</p>
<p><code>WithMany(a=&gt;a.Comments)</code>表示一个<code>Article</code>对应多个<code>Comment</code>，并且在<code>Article</code>中可以通过<code>Comments</code>属性访问到相关的Comment对象。</p>
<p>下面创建<code>DbContext</code>对象。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestContext</span>: <span class="title">DbContext</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> DbSet&lt;Article&gt; Articles &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="keyword">public</span> DbSet&lt;Comment&gt; Comments &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=Test;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">          optionsBuilder.UseSqlServer(connStr);</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">          modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面进行数据库迁移的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration createInit</span><br><span class="line"> Update-database</span><br></pre></td></tr></table></figure>

<p>注意：在<code>[程序包管理器控制台]中，默认项目选择当前的项目</code></p>
<p>下面返回数据库中，查看生成的表。</p>
<p>其中<code>T_Comments</code>表的<code>ArticleId</code>列是一个指向<code>T_Articles</code>表<code>Id</code>列的外键。</p>
<p>下面，我们编写代码测试数据的插入。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 一对多关系;</span><br><span class="line"></span><br><span class="line">Article article = <span class="keyword">new</span> Article();</span><br><span class="line">article.Title = <span class="string">&quot;.net 发展历史&quot;</span>;</span><br><span class="line">article.Content = <span class="string">&quot;.net经过不断地发展，可以进行跨平台开发&quot;</span>;</span><br><span class="line">Comment comment1 = <span class="keyword">new</span> Comment() &#123;Message=<span class="string">&quot;支持&quot;</span> &#125;;</span><br><span class="line">Comment comment2 = <span class="keyword">new</span> Comment() &#123; Message = <span class="string">&quot;太好了&quot;</span> &#125;;</span><br><span class="line">Comment comment3 = <span class="keyword">new</span> Comment() &#123; Message = <span class="string">&quot;OK&quot;</span> &#125;;</span><br><span class="line">article.Comments.Add(comment1); <span class="comment">// 将Comment对象添加到Article对象的`Comments`属性中（也就是List集合中）</span></span><br><span class="line">article.Comments.Add(comment2);</span><br><span class="line">article.Comments.Add(comment3);</span><br><span class="line"><span class="keyword">using</span> (TestContext ctx=<span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    ctx.Articles.Add(article);</span><br><span class="line">    <span class="comment">// ctx.Comments.Add(comment1);</span></span><br><span class="line">    <span class="comment">// ctx.Comments.Add(comment2);</span></span><br><span class="line">    <span class="comment">// ctx.Comments.Add(comment3); // 这里不需要将comment对象添加到DbContext对象中。</span></span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中我们可以可以看到，只要把创建的<code>Comment</code>类的对象添加到<code>Article</code>对象的<code>Comments</code>属性的<code>List</code>中，然后把<code>Article</code>对象添加到<code>ctx.Articles</code>中，就可以把相关联的<code>Comment</code>对象添加到数据库中，不需要显式为<code>Comment</code>对象的<code>Article</code>属性赋值（当前赋值也不会出错），也不需要显式地把新创建的<code>Comment</code>类型的对象添加到上下文中，因为我们的关系配置可以让<code>EF Core</code>自动完成这些工作。</p>
<h1 id="13、关联数据的获取"><a href="#13、关联数据的获取" class="headerlink" title="13、关联数据的获取"></a>13、关联数据的获取</h1><p><code>EF Core</code>的关系配置不仅能帮助我们简化数据的插入，也可以简化关联数据的获取。如下代码，把编号为1的文章以及对应的评论查询出来。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestContext ctx = <span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    Article? a = <span class="keyword">await</span> ctx.Articles.FirstOrDefaultAsync(a =&gt; a.Id == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a.Title);</span><br><span class="line">        <span class="keyword">foreach</span> (Comment item <span class="keyword">in</span> a.Comments)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>这里我们使用了异步的方法<code>FirstOrDefaultAsync</code>获取编号是1的文章，然后再获取该文章对应的评论。</p>
<p>但是，执行程序的时候，发现文章的标题展示出来了，但是该文章对应的评论没有展示出来。</p>
<p>原因是什么呢？</p>
<p>下面查看一下以上代码所生成的<code>SQL</code>语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP(<span class="number">1</span>) [t].[Id], [t].[Content], [t].[Title]</span><br><span class="line"><span class="keyword">FROM</span> [T_Articles] <span class="keyword">AS</span> [t]</span><br><span class="line"><span class="keyword">WHERE</span> [t].[Id] <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="number">1</span> <span class="keyword">AS</span> <span class="type">bigint</span>)</span><br></pre></td></tr></table></figure>

<p>通过所生成的<code>SQL</code>语句，可以看到只是查询了<code>T_Articles</code>表，并没有查询关联的<code>T_Comments</code>表。也就是说在生成的<code>SQL</code>语句中没有使用<code>join</code>语句关联查询<code>T_Comments</code>表，因此我们无法获取<code>Comments</code>属性中的数据。</p>
<p>要想关联<code>T_Comments</code>表进行查询，需要使用到<code>Include</code>方法，如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore; <span class="comment">// 引入命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (TestContext ctx = <span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 查询文章，同时包含文章具有的评论内容。</span></span><br><span class="line">    Article? a = <span class="keyword">await</span> ctx.Articles.Include(a=&gt;a.Comments).FirstOrDefaultAsync(a =&gt; a.Id == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a.Title);</span><br><span class="line">        <span class="keyword">foreach</span> (Comment item <span class="keyword">in</span> a.Comments)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(item.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>Include</code>方法是定义在<code>Microsoft.EntityFrameworkCore;</code>命名空间中的扩展方法，所以在使用这个方法之前，需要再代码中添加该命名空间的引用。</p>
<p>运行程序，可以看到编号为1的文章以及该文章具有的评论都查询出来了。</p>
<p>生成的<code>SQL</code>语句，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [t0].[Id], [t0].[Content], [t0].[Title], [t1].[Id], [t1].[ArticleId], [t1].[Message]</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> TOP(<span class="number">1</span>) [t].[Id], [t].[Content], [t].[Title]</span><br><span class="line">    <span class="keyword">FROM</span> [T_Articles] <span class="keyword">AS</span> [t]</span><br><span class="line">    <span class="keyword">WHERE</span> [t].[Id] <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="number">1</span> <span class="keyword">AS</span> <span class="type">bigint</span>)</span><br><span class="line">) <span class="keyword">AS</span> [t0]</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> [T_Comments] <span class="keyword">AS</span> [t1] <span class="keyword">ON</span> [t0].[Id] <span class="operator">=</span> [t1].[ArticleId]</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> [t0].[Id]</span><br></pre></td></tr></table></figure>

<p>通过生成的<code>SQL</code>语句我们可以看到,<code>C#</code>代码被翻译成了<code>Left Join</code>语句对<code>T_Articles</code>和<code>T_Comments</code>表进行了关联查询。</p>
<p>问题：查询编号为3的评论以及该评论对应的文章信息。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comment? cmt = <span class="keyword">await</span> ctx.Comments.FirstOrDefaultAsync(c =&gt; c.Id == <span class="number">3</span>);</span><br><span class="line"> <span class="keyword">if</span> (cmt != <span class="literal">null</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     Console.WriteLine(cmt.Message); <span class="comment">// 可以查询出编码为3的评论</span></span><br><span class="line">   </span><br><span class="line"> &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们先查询了编号为3的评论内容。这里是可以查询出来的。</p>
<p>下面查询该评论对应的文章。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comment? cmt = <span class="keyword">await</span> ctx.Comments.FirstOrDefaultAsync(c =&gt; c.Id == <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmt != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(cmt.Message);</span><br><span class="line">        Console.WriteLine(cmt.Article!.Id +<span class="string">&quot;,&quot;</span>+cmt.Article.Title); <span class="comment">// 这里出错，cmt.Article为null,所以无法获取Id,Title属性</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里也是需要<code>Include</code>方法，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用了Include方法</span></span><br><span class="line">Comment? cmt = <span class="keyword">await</span> ctx.Comments.Include(c=&gt;c.Article).FirstOrDefaultAsync(c =&gt; c.Id == <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmt != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(cmt.Message); </span><br><span class="line">        Console.WriteLine(cmt.Article!.Id +<span class="string">&quot;,&quot;</span>+cmt.Article.Title);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看一下生成的<code>SQL</code>语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">TOP</span>(<span class="params"><span class="number">1</span></span>) [t].[Id], [t].[ArticleId], [t].[Message], [t0].[Id], [t0].[Content], [t0].[Title]</span></span><br><span class="line"><span class="function">FROM [T_Comments] AS [t]</span></span><br><span class="line"><span class="function">INNER JOIN [T_Articles] AS [t0] ON [t].[ArticleId]</span> = [t0].[Id]</span><br><span class="line">WHERE [t].[Id] = CAST(<span class="number">3</span> AS bigint)</span><br></pre></td></tr></table></figure>

<p>这里生成了<code>inner join</code>关联查询。</p>
<h1 id="14、额外设置外键字段"><a href="#14、额外设置外键字段" class="headerlink" title="14、额外设置外键字段"></a>14、额外设置外键字段</h1><p>这里我们又一个需求:</p>
<p>查询编号为3的评论对应的文章编号，注意这里我们只需要文章编号。</p>
<p>这里，我们可以采用上一小节的做法，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comment? cmt = <span class="keyword">await</span> ctx.Comments.Include(c =&gt; c.Article).FirstOrDefaultAsync(c =&gt; c.Id == <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span> (cmt != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     </span><br><span class="line">      Console.WriteLine(cmt.Article!.Id );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到到以上的代码与我们上一小节中写的代码是一样的，只不过这里仅仅打印的是文章的编号。</p>
<p>虽然实现了我们的要求，但是这种实现方式是有问题的，我们来看一下上面代码所生成的<code>SQL</code>语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP(<span class="number">1</span>) [t].[Id], [t].[ArticleId], [t].[Message], [t0].[Id], [t0].[Content], [t0].[Title]</span><br><span class="line"><span class="keyword">FROM</span> [T_Comments] <span class="keyword">AS</span> [t]</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> [T_Articles] <span class="keyword">AS</span> [t0] <span class="keyword">ON</span> [t].[ArticleId] <span class="operator">=</span> [t0].[Id]</span><br><span class="line"><span class="keyword">WHERE</span> [t].[Id] <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="number">3</span> <span class="keyword">AS</span> <span class="type">bigint</span>)</span><br></pre></td></tr></table></figure>

<p>我们看到在上面的<code>sql</code>语句中，进行了链接查询，也就是说，这里还查询了<code>T_Articles</code>表，但问题是，在<code>T_Comments</code>这张表中，有一个<code>ArticleId</code>,这是与<code>T_Articles</code>表进行关联的外键。我们在创建<code>Comment</code>这个实体类的时候，创建了<code>Article</code>属性，它的类型是<code>Article</code>,在映射成数据的表的时候，根据<code>Article</code>这个属性会在<code>T_Comments</code>表中创建一个<code>ArticleId</code>外键，与对应的<code>T_Articles</code>表进行关联。</p>
<p>了解这些内容以后，我们就可以想到，这里我们要获取编号为3的这条评论对应的文章编号，没有必要去关联<code>T_Articles</code>表，直接就可以从<code>T_Comments</code>表中查询出<code>ArticleId</code>,问题是怎样实现呢？</p>
<p>如果，我们有单独获取外键列值的需求，我们可以在实体类中显式声明一个外键属性。</p>
<p>比如，我们在<code>Comment</code>类增加一个<code>long</code>类型的<code>ArticleId</code>属性，然后在关系配置中通过<code>HasForeignKey(c=&gt;c.ArticleId)</code>指定这个属性为外键就可以了。</p>
<p><code>Comment</code>类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Comment</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 主键</span></span><br><span class="line">      <span class="keyword">public</span> Article? Article &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 评论属于哪篇文章</span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span>? Message &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125; <span class="comment">// 评论内容</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">long</span> ArticleId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 文章编号，作为外键，注意与数据表中的外键字段名称一致。上面定义的Articel属性作为外键，在映射成表的时候，生成的外键字段就是ArticleId,正好与我们新添加的ArticleId属性同名，所以就不要对表进行再次迁移了。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>CommentConfig.cs</code>类中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Comment&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Comments&quot;</span>);</span><br><span class="line">           builder.Property(c =&gt; c.Message).IsRequired();</span><br><span class="line">           builder.HasOne&lt;Article&gt;(c=&gt;c.Article).WithMany(a=&gt;a.Comments).IsRequired().HasForeignKey(c=&gt;c.ArticleId); <span class="comment">// 这里添加了HasForeignKey，指定了使用ArticleId属性作为外键</span></span><br><span class="line">           </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>由于，数据表的结构没有修改过，所以这里不需要迁移数据表的操作(因为在数据表<code>T_Comments</code>中，外键字段就是<code>ArticleId</code>)。</p>
<p>直接进行查询就可以了，下面修改前面所写的代码，如下所示，</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comment? cmt = <span class="keyword">await</span> ctx.Comments.FirstOrDefaultAsync(c =&gt; c.Id == <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">if</span> (cmt != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     </span><br><span class="line">      Console.WriteLine(cmt.ArticleId );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中不需要使用<code>Include</code>方法来关联<code>Article</code>，直接查询<code>Comments</code>，然后打印<code>ArticleId</code></p>
<p>然后再来看一下所生成的<code>SQL</code>语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP(<span class="number">1</span>) [t].[Id], [t].[ArticleId], [t].[Message]</span><br><span class="line"><span class="keyword">FROM</span> [T_Comments] <span class="keyword">AS</span> [t]</span><br><span class="line"><span class="keyword">WHERE</span> [t].[Id] <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="number">3</span> <span class="keyword">AS</span> <span class="type">bigint</span>)</span><br></pre></td></tr></table></figure>

<p>通过以上生成的<code>SQL</code>语句，我们可以看到这里没有在<code>关联</code>，<code>T_Articles</code>表。只是查询了<code>T_Comments</code>表，这样查询的效率得到了提升。</p>
<p>当然，采用这种方式我们需要额外再维护一个外键属性，增加了开发复杂度，因此一般情况下我们不需要这样声明。除非以前的写法确实影响到了性能。</p>
<p>这里我们还可以对以上查询做进一步的优化。这里我们只需要查询<code>ArticleId，但是通过上面的sql</code>语句，我们可以看到，这里将<code>Id,Message</code>字段也查询出来了，但是这些并不是我们需要的，所以可以对以上的代码做进一步的优化。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这里使用了Select投影，这里指定了匿名类，所以变量cmt的类型只能是用var来修饰  </span></span><br><span class="line"><span class="keyword">var</span> cmt = <span class="keyword">await</span> ctx.Comments.Select(c =&gt; <span class="keyword">new</span> &#123;Id=c.Id,AId=c.ArticleId &#125;).FirstOrDefaultAsync(c =&gt; c.Id == <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (cmt != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">        Console.WriteLine(cmt.AId );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，通过<code>Select</code>方法完成了投影的操作，也就是只查询<code>Id,和ArticleId</code>,这里为什么还有指定<code>Id</code>呢？因为在<code>FirstOrDefaultAsync</code>方法中进行过滤的时候使用到了<code>Id</code>.通过这里使用了<code>Select</code>投影，这里指定了匿名类，所以变量<code>cmt</code>的类型只能是用var来修饰  .</p>
<p>执行以上代码，生成的<code>SQL</code>语句如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SELECT <span class="title">TOP</span>(<span class="params"><span class="number">1</span></span>) [t].[Id], [t].[ArticleId] AS [AId]</span></span><br><span class="line"><span class="function">FROM [T_Comments] AS [t]</span></span><br><span class="line"><span class="function">WHERE [t].[Id]</span> = CAST(<span class="number">3</span> AS bigint</span><br></pre></td></tr></table></figure>

<p>通过以上<code>SQL</code>语句，我们可以看到这里只查询了<code>Id,``ArticleId</code>.</p>
<p>通过以上两个知识点的讲解，我们可以总结出：</p>
<p>在使用<code>EF Core</code>的过程中如果出现了性能问题，可以进行优化，</p>
<p>由于<code>EF Core</code>是有微软官方推出的，所以<code>EF Core</code>所生成的大部分查询的<code>SQL</code>语句的性能都比较高，有少部分<code>SQL</code>语句性能可能不尽如意，但是也影响不大，除非一些特殊的<code>SQL</code>语句可能影响性能了，这时候才进行优化，看一下生成的<code>SQL</code>语句，如果不满足性能需求，这时候只能自己写<code>SQL</code>语句。</p>
<h1 id="15、单向导航属性"><a href="#15、单向导航属性" class="headerlink" title="15、单向导航属性"></a>15、单向导航属性</h1><p>在前面我们所创建的<code>Article</code>类中声明了<code>Comments</code>属性指向了<code>Comment</code>类，在<code>Comment</code>类中声明了<code>Article</code>属性指向了<code>Article</code>类。</p>
<p>这样我们不仅可以通过<code>Comment</code>类的<code>Article</code>属性获取评论对应的文章信息，也可以通过<code>Article</code>类中的<code>Comments</code>属性获取文章对应的所有评论信息。这样的关心叫做<code>双向导航</code>。</p>
<p>所以说：双向导航让我们可以通过任何一方的对象获取到对方的信息。</p>
<p>但是，在有些情况下我们不方便声明双向导航。</p>
<p>如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202406242057163.png" alt="2 (1)"></p>
<p>通过上图，我们可以看到，这里有很多的的实体类都与<code>User</code>实体类相关，如果是双向导航，我们还需要在<code>User</code>实体类中创建对应的多个属性。这样会导致<code>User</code>这个实体非常的臃肿。所以这里我们没有必要在<code>User</code>实体类中在创建导航属性了，只是在其他的实体类中创建导航属性，指向<code>User</code>这个实体类就可以了。</p>
<p>，例如<code>请假单</code>这个实体类中，不仅有<code>请假员工</code>这个属性指向了<code>User</code>实体了，同时还有<code>审批人</code>这个属性指向<code>User</code>这个实体类，这样的话，在<code>User</code>实体类中就没有必要在创建属性指向<code>请假单</code>实体类了，像这种情况就是单向导航。</p>
<p>这种单向导航属性的配置比较简单，只要在<code>WithMany</code>方法中不指定属性就可以了。</p>
<p>下面就以<code>用户与请假单</code>两个实体类举例。</p>
<p>这里我们重新创建项目，同时，拷贝<code>EF Core</code>需要的包。</p>
<p>创建<code>User</code>实体类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们可以看到在<code>User</code>这个实体类中没有创建指向<code>请假单</code>实体类的属性。</p>
<p>下面我们再来创建<code>请假单</code>实体类<code>Leave</code>,代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Leave</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="keyword">public</span> User? Requester &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125; <span class="comment">// 申请者</span></span><br><span class="line">      <span class="keyword">public</span> User? Approver &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125; <span class="comment">// 审批者</span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span>? Remarks &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125; <span class="comment">// 原因说明</span></span><br><span class="line">      <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;   <span class="comment">// 开始日期</span></span><br><span class="line">      <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;  <span class="comment">// 结束日期</span></span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">int</span> Status &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125; <span class="comment">// 状态，通过还是驳回</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Leave</code>类中有<code>Requester,Approver</code>两个<code>User</code> 类型的属性，它们都是单向导航属性。</p>
<p>下面创建<code>TestDbContext.cs</code> 类。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 创建Users与Leaves</span></span><br><span class="line">       <span class="keyword">public</span> DbSet&lt;Leave&gt; Leaves &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=Test;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">           optionsBuilder.UseSqlServer(connStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">           modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面创建<code>User</code>类的配置类<code>UserConfig.cs</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">User</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;User&gt; builder</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          builder.ToTable(<span class="string">&quot;T_Users&quot;</span>);</span><br><span class="line">          builder.Property(u=&gt;u.Name).IsRequired().HasMaxLength(<span class="number">100</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面我们在创建<code>Leave</code>类的配置<code>LeaveConfig.cs</code>，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Leave&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Leaves&quot;</span>);</span><br><span class="line">            builder.HasOne&lt;User&gt;(u =&gt; u.Requester).WithMany();</span><br><span class="line">            builder.HasOne&lt;User&gt;(u=&gt;u.Approver).WithMany();</span><br><span class="line">            builder.Property(b=&gt;b.Remarks).HasMaxLength(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Requester、Approver</code>这两个属性都是单向导航属性，因为<code>WithMany</code>方法中没有传递参数，当然也没有合适的参数给<code>WithMany</code>方法，毕竟<code>User</code>类中没有指向<code>Leave</code>类的属性。</p>
<p>下面进行数据迁移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration Init</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>注意：在【程序包管理器控制台】中选择当前新创建的项目，在执行以上数据库的迁移命令。</p>
<p>下面进行数据的插入</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx =<span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    User userInfo = <span class="keyword">new</span> User();</span><br><span class="line">    userInfo.Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    Leave leave = <span class="keyword">new</span> Leave();</span><br><span class="line">    leave.Requester = userInfo;</span><br><span class="line">    leave.From = <span class="keyword">new</span> DateTime(<span class="number">2022</span>,<span class="number">12</span>,<span class="number">9</span>);</span><br><span class="line">    leave.To = <span class="keyword">new</span> DateTime(<span class="number">2022</span>,<span class="number">12</span>,<span class="number">10</span>);</span><br><span class="line">    leave.Remarks = <span class="string">&quot;家里有事情，需要请假&quot;</span>;</span><br><span class="line">    leave.Status = <span class="number">0</span>;</span><br><span class="line">    ctx.Users.Add(userInfo);<span class="comment">// 也可以省略这行代码</span></span><br><span class="line">    ctx.Leaves.Add(leave);</span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们没有给<code>leave.Approver</code>属性赋值,因为以上的操作表示的是<code>张三</code>这个用户提交请假信息，还没有进行审批。</p>
<p>下面看一下数据查询的操作</p>
<p>例如:查询一下“张三”这个用户所有的请假单。</p>
<p>代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx =<span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">   User ?user = <span class="keyword">await</span> ctx.Users.FirstOrDefaultAsync(u =&gt; u.Name == <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>( <span class="keyword">var</span> u <span class="keyword">in</span> ctx.Leaves.Where(a =&gt; a.Requester == user))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(u.Remarks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>通过以上的代码，我们可以看到<code>User</code>实体类中没有指向<code>Leave</code>实体类的属性，如果要实现获取<code>一个用户的所有请假单</code>，我们可以直接通过<code>TestDbContext</code>对象去到<code>Leaves</code>这个<code>DbSet</code>中去查询。</p>
<p>如果，这里我们想查询一下编号为1的请假单对应的用户应该怎样查询？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx =<span class="keyword">new</span> TestDbContext())</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Leave? leave = <span class="keyword">await</span> ctx.Leaves.Include(a=&gt;a.Requester).FirstOrDefaultAsync(u=&gt;u.Id==<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (leave != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(leave.Requester.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们需要通过<code>Include</code>关联上<code>User</code>进行查询。</p>
<p>在实际项目开发中，对于主从结构的“一对多”表关系（文章表与评论表），我们一般是声明双向导航属性；对于其他的“一对多”表关系，我们则需要根据情况决定是使用单向导航属性还是使用双向导航属性，比如被很多表都引用的基础表，一般都是声明单向导航属性。</p>
<h1 id="16、关系配置在哪个实体类中"><a href="#16、关系配置在哪个实体类中" class="headerlink" title="16、关系配置在哪个实体类中"></a>16、关系配置在哪个实体类中</h1><p>在前面的案例中，我们讲过<code>Article</code>和<code>Comment</code>之间的关系是<code>一对多</code>的关系，也就是一个<code>Article</code>对应多个<code>Comment</code>；当然，我们也可以说<code>Comment</code>和<code>Article</code>之间的关系是<code>多对一</code>，也就是多个<code>Comment</code>对应一个<code>Article</code>.站在不同的角度，就有不同的说法，但是本质上它们指的是同一个东西。</p>
<p>因为，两张表之间的关系是可以配置在任何一端，比如前面我们所讲的<code>Article</code>和<code>Comment</code>类，我们就可以把它们的关系配置进行交换。</p>
<p>下面就具体的来演示一下。（重新创建一个项目）</p>
<p>在新创建的项目中，添加<code>EF Core</code>所需要的<code>包</code>。</p>
<p>在新创建的项目中，创建<code>Comment</code>类，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 关系配置在哪个实体类中</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Comment</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 主键</span></span><br><span class="line">        <span class="keyword">public</span> Article? Article &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 评论属于哪篇文章</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Message &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 评论内容</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> ArticleId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 文章编号，作为外键</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Article.cs</code>类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 关系配置在哪个实体类中</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Article</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 主键</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 文章标题</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 文章内容</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Comment&gt; Comments &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;Comment&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>CommentConfig.cs</code>类中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommentConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Comment</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Comment&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Comments&quot;</span>);</span><br><span class="line">           builder.Property(c=&gt;c.Message).IsRequired();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>ArticleConfig.cs</code>类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Article&gt; builder</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         builder.ToTable(<span class="string">&quot;T_Articles&quot;</span>);</span><br><span class="line">         builder.HasMany(a =&gt; a.Comments).WithOne(c =&gt; c.Article);<span class="comment">// 一篇文章有很多评论，而每条评论对应一篇文章</span></span><br><span class="line">         builder.Property(a=&gt;a.Content).IsRequired();</span><br><span class="line">         builder.Property(a=&gt;a.Title).IsRequired().HasMaxLength(<span class="number">255</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们把关系的配置从<code>CommentConfig</code>类中移动到了<code>ArticleConfig</code>类中。当然，由于配置的位置变了，我们把<code>CommentConfig</code>类中的<code>HasOne&lt;Article&gt;(c=&gt;c.Article).WithMany(a=&gt;a.Comments)</code>改成了<code>ArticleConfig</code>类中的<code>HasMany&lt;Comment&gt;(a=&gt;a.Comments).WithOne(c=&gt;c.Article)</code>。</p>
<p>创建<code>TestContext.cs</code>类，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestContext</span>:<span class="title">DbContext</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> DbSet&lt;Article&gt; Articles &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> DbSet&lt;Comment&gt; Comments &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=TestDB;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;<span class="comment">// 这里链接的是TestDB数据库。</span></span><br><span class="line">           optionsBuilder.UseSqlServer(connStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">           modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>数据库迁移（注意：在【程序包管理器控制台】中，选择当前新创建的项目）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration Init</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>执行数据库迁移后，重新执行代码，查看<code>TestDB</code>数据库，我们会发现数据库结构和之前的没有任何区别，也就是说这两种配置方式的效果是一样的。</p>
<p>当然，对于单向导航属性，我们只能把关系配置到一方,也就说针对单向导航属性，还是使用<code>HasOne(...).WithMany(...)</code>的方式。</p>
<p>因此，考虑到有单向导航属性的可能，我们一般都用<code>HasOne(…).WithMany(…)</code>这样的方式进行配置，而不是像本小节这样“反其道而行之”。</p>
<h1 id="18、一对一关系配置"><a href="#18、一对一关系配置" class="headerlink" title="18、一对一关系配置"></a>18、一对一关系配置</h1><p>实体类之间还可以有一对一关系，比如”采购申请”和”采购订单”，就是一对一关系。</p>
<p>在电商网站中，“订单”和“快递信息”这两个实体类之间也是一对一的关系：一个订单对应一个快递信息，一个快递信息对应一个订单。</p>
<p>下面我们来看一下<code>一对一关系</code>的配置。</p>
<p>首先，我们声明一个订单的实体类<code>Order</code>(这里我们简化了该实体类中的属性，实际中该实体类中的属性比较复杂)。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    </span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 商品名称</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Address &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 收货地址</span></span><br><span class="line">       <span class="keyword">public</span> Delivery? Delivery &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 快递信息</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面我们再创建一个快递信息的实体类<code>Delivery.cs</code> ,代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Delivery</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    </span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? CompanyName &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125; <span class="comment">// 快递公司</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Number &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 快递单号</span></span><br><span class="line">       <span class="keyword">public</span> Order? Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 订单</span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> OrderId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  <span class="comment">// 指向订单的外键</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过声明的两个属性，我们可以看到<code>Order</code>和<code>Delivery</code>两个类中分别声明了一个指向对象的属性，这样就构成了一对一的关系中。</p>
<p>在一对多的关系中，我们需要在“多”端有一个指向“一”端的列，因此除非我们需要显式地声明一个外键属性，否则<code>EF Core</code>会自动在多端的表中生成一个指向一端的外键列，不需要我们显式地声明外键属性。但是对于一对一关系，由于双方是“平等”的关系，外键列可以建在任意一方，因此<strong>我们必须显式地在其中一个实体类中声明一个外键属性</strong>。就像上面的实体类定义中，<code>Delivery</code>类中声明了一个外键属性<code>OrderId</code>，当然我们也可以改成在Order类中声明一个外键属性<code>DeliveryId</code>，效果是一样的。</p>
<p>下面对两个实体类进行配置。</p>
<p><code>OrderConfig.cs</code>文件中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Order</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Order&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Orders&quot;</span>);</span><br><span class="line">           builder.Property(o=&gt;o.Address).IsRequired();</span><br><span class="line">           builder.Property(o=&gt;o.Name).IsRequired();</span><br><span class="line">           builder.HasOne&lt;Delivery&gt;(o=&gt;o.Delivery).WithOne(d=&gt;d.Order).HasForeignKey&lt;Delivery&gt;(d=&gt;d.OrderId);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>和一对多关系类似，在一对一关系中，把关系放到哪一方的实体类的配置中都可以。这里把关系的配置放到了<code>Order</code>类的配置中。这里的配置同样遵守<code>HasXXX(…).WithYYY(…)</code>的模式，由于双方都是一端，因此使用<code>HasOne(…).WithOne(…)</code>进行配置。由于在一对一关系中，必须显式地指定外键配置在哪个实体类中，因此我们通过<code>HasForeignKey</code>方法声明外键对应的属性。</p>
<p>下面创建<code>DeliveryConfig.cs</code>这个配置类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeliveryConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Delivery</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Delivery&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Deliveries&quot;</span>);</span><br><span class="line">           builder.Property(b=&gt;b.CompanyName).IsRequired().HasMaxLength(<span class="number">20</span>);</span><br><span class="line">           builder.Property(b=&gt;b.Number).IsRequired().HasMaxLength(<span class="number">50</span>);    </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面创建<code>TestDbContext.cs</code>，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestContext</span>:<span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Order&gt; Orders &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Delivery&gt; Deliveries &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=TestDB;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">            optionsBuilder.UseSqlServer(connStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>下面进行数据的迁移操作（看一下所生成的数据表的结构）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration Init</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>下面进行数据的插入测试</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestContext ctx =<span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.Address = <span class="string">&quot;北京昌平区&quot;</span>;</span><br><span class="line">    order.Name = <span class="string">&quot;C# 高级&quot;</span>;</span><br><span class="line">    Delivery delivery = <span class="keyword">new</span> Delivery();</span><br><span class="line">    delivery.CompanyName = <span class="string">&quot;申通&quot;</span>;</span><br><span class="line">    delivery.Number = <span class="string">&quot;ST1000001&quot;</span>;</span><br><span class="line">    delivery.Order =order; <span class="comment">// 这里指定了关系</span></span><br><span class="line">    ctx.Deliveries.Add(delivery); <span class="comment">// 这样在进行添加delivery的时候，也会找到order 并且添加order</span></span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，指定如下的关系也是可以进行插入的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestContext ctx =<span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.Address = <span class="string">&quot;北京昌平区&quot;</span>;</span><br><span class="line">    order.Name = <span class="string">&quot;C# 基础入门&quot;</span>;</span><br><span class="line">    Delivery delivery = <span class="keyword">new</span> Delivery();</span><br><span class="line">    delivery.CompanyName = <span class="string">&quot;京东&quot;</span>;</span><br><span class="line">    delivery.Number = <span class="string">&quot;ST1000002&quot;</span>;</span><br><span class="line">    order.Delivery = delivery;</span><br><span class="line">    ctx.Orders.Add(order);</span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以直接采用如下的写法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestContext ctx =<span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.Address = <span class="string">&quot;北京昌平区&quot;</span>;</span><br><span class="line">    order.Name = <span class="string">&quot;C# 面向对象&quot;</span>;</span><br><span class="line">    Delivery delivery = <span class="keyword">new</span> Delivery();</span><br><span class="line">    delivery.CompanyName = <span class="string">&quot;京东&quot;</span>;</span><br><span class="line">    delivery.Number = <span class="string">&quot;ST1000002&quot;</span>;</span><br><span class="line">    order.Delivery = delivery;</span><br><span class="line">    ctx.Orders.Add(order);<span class="comment">// 添加了order</span></span><br><span class="line">    ctx.Deliveries.Add(delivery); <span class="comment">// 这里也添加了delivery</span></span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们将<code>order与delivery</code>都添加到对应的<code>DbSet</code>中，这种写法也可以。</p>
<p>这里就根据个人的习惯进行选择就可以了。</p>
<p>下面进行数据的查询</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span>  ctx.Orders.Where(o =&gt; o.Id == <span class="number">1</span>).Include(o =&gt; o.Delivery).FirstOrDefaultAsync();</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;商品名:&quot;</span>+result.Name+<span class="string">&quot;,订单号&quot;</span>+result.Delivery.Number);</span><br></pre></td></tr></table></figure>

<p>查询编号为1的订单的商品名称以及对应的订单号。</p>
<h1 id="19、多对多"><a href="#19、多对多" class="headerlink" title="19、多对多"></a>19、多对多</h1><p>多对多指的是A实体类的一个对象可以被多个B实体类的对象引用，B实体类的一个对象也可以被多个A实体类的对象引用。比如在学校里，一个老师对应多个学生，一个学生也有多个老师，因此老师和学生之间的关系就是多对多。下面我们就使用“学生-老师”这个例子实现多对多关系。</p>
<p>新创建一个项目来实现多对多的配置</p>
<p>注意：将<code>EF Core</code>所需要的包拷贝过来。</p>
<p>下面我们先声明学生类<code>Student</code>和老师类<code>Teacher</code>.</p>
<p><code>Student</code>类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> List&lt;Teacher&gt; Teachers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;=<span class="keyword">new</span> List&lt;Teacher&gt;() &#123; &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>Teacher</code>类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    </span><br><span class="line">       <span class="keyword">public</span> List&lt;Student&gt; Students &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;Student&gt;();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，学生类<code>Student</code>中有一个<code>List</code>类型的<code>Teachers</code>代表这个学生的所有老师，同样地，老师类<code>Teacher</code>中也有一个<code>List</code>类型的<code>Students</code>代表这个老师的所有学生。接下来，我们开始对学生和老师实体类进行配置</p>
<p>下面，我们开始对学生和老师实体类进行配置。</p>
<p>如下代码所示：</p>
<p><code>TeacherConfig.cs</code>文件中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TeacherConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Teacher</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Teacher&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Teachers&quot;</span>);</span><br><span class="line">           builder.Property(t =&gt; t.Name).IsRequired().HasMaxLength(<span class="number">20</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>StudentConfig.cs</code>文件中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StudentConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Student</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Student&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Students&quot;</span>);</span><br><span class="line">           builder.Property(s=&gt;s.Name).IsRequired().HasMaxLength(<span class="number">20</span>);</span><br><span class="line">           builder.HasMany&lt;Teacher&gt;(s =&gt; s.Teachers).WithMany(s =&gt; s.Students).UsingEntity(a =&gt; a.ToTable(<span class="string">&quot;T_Students_Teachers&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>同样地，多对多的关系配置可以放到任何一方的配置类中，这里把关系配置代码放到了<code>Student</code>类的配置中。这里同样采用的是<code>HasXXX(…).WithYYY(…)</code>的模式，由于是多对多，关系的两端都是“多”，因此关系配置使用的是<code>HasMany(…).WithMany(…)</code>。</p>
<p>一对多和一对一都只要在表中增加外键列即可，但是在多对多关系中，我们必须引入一张额外的数据库表保存两张表之间的对应关系。在<code>EF Core</code>中，使用<code>UsingEntity(j=&gt;j.ToTable (&quot;T_Students_Teachers&quot;))</code>的方式配置中间表（当然，这行代码也可以不用加，但是生成的中间表命名不符合咱们的规范，所以如果想给中间表起一个符合咱们自己要求的名字建议加上这行代码）。</p>
<p><code>TestContext.cs</code>文件中的配置代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestContext</span>:<span class="title">DbContext</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> DbSet&lt;Student&gt; Students &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> DbSet&lt;Teacher&gt; Teachers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=TestDB;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">           optionsBuilder.UseSqlServer(connStr);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">           modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>下面进行迁移，注意选择当前新项目。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration Init</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>查看数据库，可以看到数据库有一张额外的关系表<code>T_Students_Teachers</code>，这张表中有指向<code>T_Students</code>表的外键列<code>StudentsId</code>，也有指向<code>T_Teachers</code>表的外键列<code>TeachersId</code>。<code>T_Students_Teachers</code>表中保存了<code>T_Students</code>表和<code>T_Teachers</code>表中数据之间的对应关系，而我们不需要为这张关系表声明实体类。</p>
<p>下面进行数据的插入</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student &#123;Name = <span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student &#123;Name = <span class="string">&quot;老王&quot;</span> &#125;;</span><br><span class="line">Student s3 = <span class="keyword">new</span> Student &#123; Name = <span class="string">&quot;李四&quot;</span> &#125;;</span><br><span class="line">Student s4= <span class="keyword">new</span> Student &#123; Name = <span class="string">&quot;马六&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">Teacher t1 = <span class="keyword">new</span> Teacher &#123; Name = <span class="string">&quot;李老师&quot;</span> &#125;;</span><br><span class="line">Teacher t2 = <span class="keyword">new</span> Teacher &#123; Name = <span class="string">&quot;王老师&quot;</span> &#125;;</span><br><span class="line">Teacher t3 = <span class="keyword">new</span> Teacher &#123; Name = <span class="string">&quot;张老师&quot;</span> &#125;;</span><br><span class="line">t1.Students.Add(s1); <span class="comment">// s1.Teachers.Add(t1);// 这种形式也是可以的</span></span><br><span class="line">t1.Students.Add(s2);</span><br><span class="line">t2.Students.Add(s3);</span><br><span class="line">t2.Students.Add(s4);</span><br><span class="line">t3.Students.Add(s4);</span><br><span class="line">t3.Students.Add(s3);</span><br><span class="line">t3.Students.Add(s2);</span><br><span class="line"><span class="keyword">using</span>(TestContext ctx = <span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    ctx.AddRange(t1, t2, t3); <span class="comment">// ctx.Teachers.Add(t1) //也可以采用这种方式一个一个的添加</span></span><br><span class="line">    ctx.AddRange(s1, s2, s3,s4);</span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们是通过<code>AddRange</code>方法把多个对象批量的添加到了<code>DbContext</code>中。需要注意的是，<code>AddRange</code>方法只是通过循环调用<code>Add</code>方法把多个实体添加到<code>DbContext</code>中，是对<code>Add</code>方法的简化调用，在使用<code>SaveChangesAsync</code>的时候，这些数据任然是逐条的插入到数据库中的。</p>
<p>执行完以上的代码以后，查看数据库中的3张表。</p>
<p>下面进行查询的操作</p>
<p>(1)查询所有老师的信息，同时将每个老师所教学生信息也查询出来。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestContext ctx = <span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Teacher t <span class="keyword">in</span> ctx.Teachers.Include(t =&gt; t.Students))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;老师 <span class="subst">&#123;t.Name&#125;</span>&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (Student s <span class="keyword">in</span> t.Students)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;-------<span class="subst">&#123;s.Name&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2): 查询<code>王老师</code>所有学生(这里根据老师的编号来进行查询)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t =<span class="keyword">await</span> ctx.Teachers.Include(s=&gt;s.Students).Where(c =&gt; c.Id == <span class="number">2</span>).FirstOrDefaultAsync();</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="literal">null</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">foreach</span>(<span class="keyword">var</span> student <span class="keyword">in</span> t.Students)</span><br><span class="line">      &#123;</span><br><span class="line">          Console.WriteLine(student.Name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="20、基于关系的复杂查询"><a href="#20、基于关系的复杂查询" class="headerlink" title="20、基于关系的复杂查询"></a>20、基于关系的复杂查询</h1><p>在这一小节中，我们继续看一些关于基于关系的查询操作。</p>
<p>(1)查询一下评论中含有<code>好</code>字的文章。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> articles = ctx.Articles.Where(a =&gt; a.Comments.Any(c=&gt;c.Message.Contains(<span class="string">&quot;好&quot;</span>)));</span><br><span class="line">   <span class="keyword">foreach</span> (<span class="keyword">var</span> article <span class="keyword">in</span> articles)</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine(article.Id + <span class="string">&quot;,&quot;</span> + article.Title);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里没有使用<code>include</code>，因为在<code>where</code>中指定了<code>Comments</code>来进行查询。</p>
<p>在<code>Where</code>这个方法中，使用<code>Any</code>方法判断是否存在至少一条评论中包含<code>好</code>的文章。这里使用<code>Any</code>的目的是：如果一篇文章的评论中有多条评论都包含了<code>好</code>字，最终查询出的文章标题只有一个，相当于去重了。（这里可以修改表中的记录进行操作）。</p>
<p>下面我们看一下，上面查询所生成的<code>SQL</code>语句，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [t].[Id], [t].[Content], [t].[Title]</span><br><span class="line"><span class="keyword">FROM</span> [T_Articles] <span class="keyword">AS</span> [t]</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> [T_Comments] <span class="keyword">AS</span> [t0]</span><br><span class="line">    <span class="keyword">WHERE</span> [t].[Id] <span class="operator">=</span> [t0].[ArticleId] <span class="keyword">AND</span> ([t0].[Message] <span class="keyword">LIKE</span> N<span class="string">&#x27;%好%&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>通过上面的<code>SQL</code>语句，可以看到，我们所写的<code>C#</code>代码被<code>EF Core</code>翻译成了<code>Exists</code>加子查询的<code>SQL</code>语句。根据数据库的不同以及数据的特点，上面生成的<code>SQL</code>语句也许并不是性能最优的写法。所以将上面的查询修改成如下的形式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> articles = ctx.Comments.Where(c =&gt; c.Message!.Contains(<span class="string">&quot;好&quot;</span>)).Select(c=&gt;c.Article).Distinct();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> article <span class="keyword">in</span> articles)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(article.Title);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中使用<code>Where</code>方法获取所有包含<code>好</code>的评论，然后使用<code>select</code>方法获取评论对应的文章，并且使用<code>Distinct()</code>方法进行了去重的操作。</p>
<p>可以看到所生成的<code>sql</code>语句，同样的效果的代码被翻译成了使用<code>Join</code>查询的数据筛选。根据具体情况的不同，这种做法也许性能更好。</p>
<p>当然，对性能问题必须具体问题具体分析。</p>
<h1 id="21、IEnumerable与IQueryable"><a href="#21、IEnumerable与IQueryable" class="headerlink" title="21、IEnumerable与IQueryable"></a>21、<code>IEnumerable</code>与<code>IQueryable</code></h1><p>我们知道，可以使用<code>Linq</code>中的<code>Where</code>等方法可以对普通集合进行处理，比如下面的<code>C#</code>代码可以把<code>int</code>数组中大于5的数字查询出来。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">35</span>, <span class="number">23</span> &#125;;</span><br><span class="line">  IEnumerable&lt;<span class="built_in">int</span>&gt; items= nums.Where(i =&gt; i &gt; <span class="number">5</span>);</span><br><span class="line">   <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> items)</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们可以看一下<code>Where</code>方法的具体定义，关于该方法的<code>定义</code>，我们前面也看过，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);</span><br></pre></td></tr></table></figure>

<p><code>Where</code>方法是<code>IEnumerable</code>的扩展方法，同时返回的类型也是<code>IEnumerable</code>这个泛型接口。</p>
<p>下面我们再来看一下在<code>EF Core</code>中在<code>DbSet</code>类型上调用<code>Where</code>方法进行的数据筛选</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var articles = ctx.Comments.Where(c =&gt; c.Message!.Contains(<span class="string">&quot;好&quot;</span>)).Select(c=&gt;c.Article).Distinct();</span><br></pre></td></tr></table></figure>

<p>这时候<code>Where</code>方法的定义如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IQueryable</span>&lt;<span class="title">TSource</span>&gt; <span class="title">Where</span>&lt;<span class="title">TSource</span>&gt;(<span class="params"><span class="keyword">this</span> IQueryable&lt;TSource&gt; source, Expression&lt;Func&lt;TSource, <span class="built_in">bool</span>&gt;&gt; predicate</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这时候<code>Where</code>方法是<code>IQueryable</code>的扩展方法，同时返回的也是<code>IQueryable</code>的泛型接口。</p>
<p><code>IQueryable</code>其实就是一个继承了<code>IEnumerable</code>接口的接口。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IQueryable</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt;, <span class="title">IEnumerable</span>, <span class="title">IQueryable</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这就比较奇怪了，<code>IQueryable</code>接口就是继承自<code>IEnumerable</code>接口的，<code>IQueryable</code>中的<code>Where</code>方法除了参数和返回值的类型是<code>IQuerable</code>,其他用法和<code>IEnumerable</code>中的<code>Where</code>方法没有什么不同。那微软为什么还要推出一个<code>IQueryable</code>接口以及一个新的<code>Where</code>方法呢？</p>
<p>对于普通的集合,<code>Where</code>方法会在内存中对每条数据进行过滤，而<code>EF Core</code>如果也把全部数据都在内存中进行过滤的话，我们就需要把数据表中的所有数据都加载到内存中，然后在通过条件逐条进行过滤，如果数据表中的数据量非常大，就会有性能问题。</p>
<p><strong>因此，<code>EF Core</code>中的<code>Where</code>必须实现一套<code>把 Where 条件转换为SQL</code>语句的机制，让数据的筛选是在数据库服务器上执行。这样性能就会得到提升。</strong></p>
<p><code>KilgourNote:Iqueryable是将Linq语句中的筛选条件直接在服务器上进行筛选然后传给用户。而IEnumerable则是将整张表都拿到用户手上置于内存里再在用户内存里进行筛选。</code></p>
<p>所以说，微软针对<code>EF Core</code>的查询又创造了<code>IQueryable</code>类型，并且在<code>IQueryable</code>中定义了和<code>IEnumerable</code>中类似的<code>Where</code>等方法。</p>
<p>因此，在使用<code>EF Core</code>的时候，我们要尽量调用<code>IQueryable</code>中的<code>方法</code>。而不是直接调用<code>IEnumerable</code>中的方法。</p>
<p>下面，我们再来看一个例子体会一下。</p>
<p><code>IQueryable</code>数据查询（查询评论中包含<code>好</code>字的评论）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> messages = ctx.Comments.Where(c =&gt; c.Message!.Contains(<span class="string">&quot;好&quot;</span>));</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> msg <span class="keyword">in</span> messages)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(msg.Message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>生成的<code>SQL</code>语句如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT [t].[Id], [t].[ArticleId], [t].[Message]</span><br><span class="line">FROM [T_Comments] AS [t]</span><br><span class="line">WHERE [t].[Message] LIKE N&#x27;%好%&#x27;</span><br></pre></td></tr></table></figure>

<p>下面把上面的查询代码稍微修改一下，修改成<code>IEnumerable</code>的形式，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;Comment&gt; comments = ctx.Comments;</span><br><span class="line">    IEnumerable&lt;Comment&gt; cmts = comments.Where(c =&gt; c.Message!.Contains(<span class="string">&quot;好&quot;</span>));</span><br><span class="line">    <span class="keyword">foreach</span> (Comment cmt <span class="keyword">in</span> cmts)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(cmt.Message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们知道<code>ctx.Comments</code>的类型是<code>DbSet</code>类型.而<code>DbSet</code>类型也实现了<code>IEnumberable</code>类型。所以这里我们就强制性的将<code>comments</code>这个变量的类型定义成了<code>IEnumerable&lt;Comment&gt;</code>类型。</p>
<p>这样下面我们通过<code>comments.Where</code>进行过滤的时候，<code>Where</code>这个方法就是<code>IEnumerable</code>泛型接口类型的方法。</p>
<p>上面代码生成的<code>SQL</code>语句，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT [t].[Id], [t].[ArticleId], [t].[Message]</span><br><span class="line">FROM [T_Comments] AS [t]</span><br></pre></td></tr></table></figure>

<p>很明显，这里是将<code>T_Comments</code>表中所有的数据都加载到应用程序内存中，然后在内存中进行数据的过滤。</p>
<h1 id="22、IQueryable延迟执行"><a href="#22、IQueryable延迟执行" class="headerlink" title="22、IQueryable延迟执行"></a>22、<code>IQueryable</code>延迟执行</h1><p>在这一个小节中，我们看一下<code>IQueryable</code>另外的一个特性就是延迟执行的能力。</p>
<p>如下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> messages = ctx.Comments.Where(c =&gt; c.Message!.Contains(<span class="string">&quot;好&quot;</span>));</span><br><span class="line">  Console.WriteLine(messages);</span><br></pre></td></tr></table></figure>

<p>以上代码是查询评论中包含<code>好</code>的评论。</p>
<p>但是，我们通过查看<code>SQL Server Profile</code>发现并没有生成对应的<code>SQL</code>语句，而我们明明是执行了<code>Where</code>方法进行数据过滤的查询。</p>
<p>下面，我们再把代码修改一下，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> messages = ctx.Comments.Where(c =&gt; c.Message!.Contains(<span class="string">&quot;好&quot;</span>));</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> message <span class="keyword">in</span> messages)</span><br><span class="line">  &#123;</span><br><span class="line">      Console.WriteLine(message.Message);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们添加了一个<code>foreach</code>遍历</p>
<p>这时候，执行上面的程序，在控制台中打印了结果，并且在<code>SQL Server Profile</code>中也看到了对应的<code>SQL</code>语句。</p>
<p>也就是说，当执行<code>foreach</code>循环来获取数据的时候，才会生成<code>sql</code>语句交给数据库服务器执行。</p>
<p><strong>这就说明了<code>IQueryable</code>代表了”可以把查询放到数据库服务中执行”，但是它没有立即执行，只是“可以被执行”而已。</strong></p>
<p>这一点，我们可以从<code>IQueryable</code>它的英文含义中看出来，<code>IQueryable</code>的意思是”可查询的”，可以查询，但是没有执行查询，也就是说查询执行被延迟了。</p>
<p>那么问题是<code>IQueryable</code>是什么时候才会执行查询呢？</p>
<p><strong>一个原则是：调用<code>立即执行</code>方法的时候会立即执行查询，除了遍历<code>IQueryable</code>操作之外，还有<code>ToArray,ToList,Min,Max,Count</code>等立即执行方法。</strong></p>
<p>而<code>GroupBy,OrderBy,Include,Skip,Take</code>等方法是“非立即执行方法”，调用这些方法，不会执行查询。</p>
<p><strong>判断一个方法是否是立即执行方法的简单方式是：一个方法的返回值类型如果是<code>IQueryable</code>类型，这个方法一般就是非立即执行方法，否则这个方法就是立即执行方法。</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.Comments.Where(c =&gt; c.Message!.Contains(<span class="string">&quot;好&quot;</span>)).Count()</span><br></pre></td></tr></table></figure>

<p>以上方法返回的是一个整型，表示的就是一个<code>立即执行</code>的方法，立即执行，返回满足条件的数据条数。</p>
<p><code>EF Core</code>为什么要实现“<code>IQueryable</code>延迟执行”这样复杂的机制呢？因为我们可以先使用<code>IQueryable</code>拼接出复杂的查询条件，然后再去执行查询。</p>
<p>如下伪代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueryBooks</span>(<span class="params"><span class="built_in">string</span> searchWords, <span class="built_in">bool</span> searchAll, <span class="built_in">bool</span> orderByPrice, <span class="built_in">double</span> upperPrice</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> TestDbContext ctx = <span class="keyword">new</span> TestDbContext() </span><br><span class="line">    &#123;</span><br><span class="line">        IQueryable &lt; Book &gt; books = ctx.Books.Where(b =&gt; b.Price &lt;= upperPrice);</span><br><span class="line">    <span class="keyword">if</span> (searchAll)      <span class="comment">//匹配书名或作者名</span></span><br><span class="line">    &#123;</span><br><span class="line">        books = books.Where(b =&gt; b.Title.Contains(searchWords) ||</span><br><span class="line">                b.AuthorName.Contains(searchWords));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                <span class="comment">//只匹配书名</span></span><br><span class="line">    &#123;</span><br><span class="line">        books = books.Where(b =&gt; b.Title.Contains(searchWords));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (orderByPrice)   <span class="comment">//按照价格排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        books = books.OrderBy(b =&gt; b.Price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (Book b <span class="keyword">in</span> books)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;b.Id&#125;</span>,<span class="subst">&#123;b.Title&#125;</span>,<span class="subst">&#123;b.Price&#125;</span>,<span class="subst">&#123;b.AuthorName&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，下面的代码中定义了一个方法，这个方法用来根据给定的关键字<code>searchWords</code>查询匹配的书；如果<code>searchAll</code>参数是true，则书名或者作者名中含有给定的<code>searchWords</code>的都匹配，否则只匹配书名；如果<code>orderByPrice</code>参数为<code>true</code>，则把查询结果按照价格升序排序，否则就自然排序；<code>upperPrice参数代表价格上限</code></p>
<p>上面的代码，只有执行了<code>foreach</code>的时候才会执行查询。</p>
<p>根据上面的伪代码，我们可以看到，我们传递不同的参数会拼接成不同的<code>IQueryable</code>,因此最后执行查询的时候生成的<code>SQL</code>语句也是不同的。</p>
<p>如果不使用<code>EF Core</code>而使用<code>SQL</code>语句实现<code>根据不同参数执行不同SQL</code>的逻辑，我们需要手动拼接<code>SQL</code>语句，这个过程是比较麻烦的，而<code>EF Core</code>把“动态拼接生成查询逻辑”变得非常简单。</p>
<p>总结：<code>IQueryable</code>表示对一个数据库中的数据进行查询的时候，是一个延迟查询。我们可以调用非立即执行方法向<code>IQueryable</code>中添加查询逻辑，实现根据不同参数拼接不同的<code>IQueryable</code>,当执行立即执行方法的时候才会真正生成<code>SQL</code>语句执行查询。</p>
<h1 id="23、IQueryable复用性"><a href="#23、IQueryable复用性" class="headerlink" title="23、IQueryable复用性"></a>23、<code>IQueryable</code>复用性</h1><p>由于<code>IQueryable</code>是一个待查询的逻辑，因此它是可以被重复使用的。</p>
<p>如下代码所示：（一对多项目中演示）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IQueryable&lt;Comment&gt;comments = ctx.Comments.Where(c =&gt; c.Id &gt;=<span class="number">1</span>);</span><br><span class="line">   Console.WriteLine(comments.Count());</span><br><span class="line">   <span class="keyword">foreach</span> (<span class="keyword">var</span> comment <span class="keyword">in</span> comments.Where(c=&gt;c.Message.Contains(<span class="string">&quot;好&quot;</span>)))</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine(comment.Message);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的查询中，我们首先创建了一个编号大于1的评论的<code>IQueryable</code>对象，然后再调用<code>Count</code>方法执行了<code>IQueryable</code>对象获取满足条件的数据条数，最后对于<code>comments</code>变量调用<code>Where</code>方法进一步过滤获取评论内容中包含<code>好</code>字的评论内容。</p>
<p>看一下所生成的<code>SQL</code>语句，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> [T_Comments] <span class="keyword">AS</span> [t]</span><br><span class="line"><span class="keyword">WHERE</span> [t].[Id] <span class="operator">&gt;=</span> <span class="built_in">CAST</span>(<span class="number">1</span> <span class="keyword">AS</span> <span class="type">bigint</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [t].[Id], [t].[ArticleId], [t].[Message]</span><br><span class="line"><span class="keyword">FROM</span> [T_Comments] <span class="keyword">AS</span> [t]</span><br><span class="line"><span class="keyword">WHERE</span> [t].[Id] <span class="operator">&gt;=</span> <span class="built_in">CAST</span>(<span class="number">1</span> <span class="keyword">AS</span> <span class="type">bigint</span>) <span class="keyword">AND</span> ([t].[Message] <span class="keyword">LIKE</span> N<span class="string">&#x27;%好%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>通过以上的<code>SQL</code>语句，我们可以看到，执行<code>Count</code>进行统计的时候包含了<code>Id &gt;1</code>条件，下面执行评论内容中是否包含<code>好</code>字过滤的时候，也包含了<code>Id &gt;1</code>过滤的条件。</p>
<p>这就是说，后面的操作都包含了最开始的<code>IQueryable</code>指定的过滤条件，从而达到了复用<code>IQueryable</code>的目的。</p>
<p><code>IQueryable</code>让我们可以复用之前生成的查询逻辑</p>
<h1 id="24、分页查询"><a href="#24、分页查询" class="headerlink" title="24、分页查询"></a>24、分页查询</h1><p>如果数据表中的数据非常多，在把查询结果展现到页面上进行展示的时候，我们通常要对查询结果进行分页展示。</p>
<p>例如：每页显示10条数据，然后用户单击不同的页码的时候，展示不同的数据，第一页展示1-10的数据，当单击第2页的时候，展示11-20的数据。</p>
<p>在学习<code>Linq</code>的时候，我们知道可以使用<code>Skip(n)</code>方法实现<code>跳过n条数据</code>，可以使用<code>Take(n)</code>实现<code>获取最多n条数据</code>，这两个方法配合起来就可以实现分页获取数据。比如<code>Skip(3).Take(8)</code>就是<code>获取从第3条开始的最多8条数据</code>。</p>
<p>在<code>EF Core</code>中同样也支持这两个方法。</p>
<p>下面对<code>Student</code>表中的数据进行分页展示。（多对多项目中进行演示，并且向数据表中添加一些测试数据）</p>
<p>要求: 对姓名中不包含<code>张</code>姓的学生进行分页展示。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShowPage</span>(<span class="params"><span class="built_in">int</span> pageIndex,<span class="built_in">int</span> pageSize</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (TestContext ctx = <span class="keyword">new</span> TestContext())</span><br><span class="line">    &#123;</span><br><span class="line">        IQueryable&lt;Student&gt; students = ctx.Students.Where(s =&gt; !s.Name.Contains(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">        <span class="comment">// 总条数</span></span><br><span class="line">        <span class="built_in">long</span> count = students.LongCount();</span><br><span class="line">        <span class="comment">// 可以分多少页(22/7 得到的结果是3.xxx,这时候也是需要分4页，所以这里使用了天花板函数Celing，也就是向上取整，同时为了保证22/7得到小数(默认情况下整数相除，得到的还是整数),所以这里乘以了1.0,否则不会出现小数的情况)</span></span><br><span class="line">        <span class="built_in">long</span> pageCount =(<span class="built_in">long</span>) Math.Ceiling (count * <span class="number">1.0</span> / pageSize);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;页数:&quot;</span>+pageCount);</span><br><span class="line">        <span class="keyword">var</span> pages = students.Skip((pageIndex - <span class="number">1</span>)*pageSize).Take(pageSize);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> p <span class="keyword">in</span> pages)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(p.Name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ShowPage(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 展示第1页的两条数据</span></span><br><span class="line">ShowPage(<span class="number">2</span>,<span class="number">2</span>);  <span class="comment">// 展示第2页的两条数据</span></span><br><span class="line">ShowPage(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">// 展示第3页的两条数据</span></span><br></pre></td></tr></table></figure>

<p><code>ShowPage</code>方法的<code>pageIndex</code>参数代表页码，<code>pageSize</code>参数代表页大小。在<code>ShowPage</code>方法中，我们首先把查询规则<code>students</code>创建出来，然后使用<code>LongCount</code>方法获取满足条件的数据的总条数。使用<code>count×1.0÷pageSize</code>可以计算出数据总页数，考虑到有可能最后一页不满，因此我们用<code>Ceiling</code>方法获得整数类型的总页数。由于<code>pageInde</code>x的序号是从1开始的，因此我们要使用Skip方法跳过<code>(pageIndex−1)×pageSize</code>条数据，再获取最多<code>pageSize</code>条数据就可以获取正确的分页数据了。</p>
<p>以上也是使用了<code>IQueryable</code>的复用性的特点。</p>
<h1 id="25、IQueryable底层运行机制"><a href="#25、IQueryable底层运行机制" class="headerlink" title="25、IQueryable底层运行机制*"></a>25、<code>IQueryable</code>底层运行机制*</h1><p>我们知道，在<code>ADO.Net</code>中有<code>DataReader</code>和<code>DataTable</code>两种读取数据库查询结果的方式。<code>EF Core</code>底层也是通过<code>ADO.NET</code>来操作数据库。</p>
<p>如果查询的数据比较多，<code>DataTable</code>会把所有数据一次性的从数据库服务器加载到客户端程序的内存中，而<code>DataReader</code>则会分批次从数据库服务器读取数据,并不是一次性的把数据加载到客户端程序的内存中，<code>DataReader</code>的优点是客户端程序内存占用小，缺点是如果遍历读取数据并且进行处理的过程比较缓慢的话，会导致程序占用数据库链接的时间较长，从而降低数据库服务器的并发链接的能力。</p>
<p><code>DataTable</code>的优点是数据被快速的加载到客户端的内存中，因此不会较长时间地占用数据库链接，缺点是如果数据量比较大的话，客户端的内存会占用比较大。</p>
<p><code>IQueryable</code>遍历读取数据的时候，用的是类似<code>DataReader</code>的方式还是类似<code>DataTable</code>的方式呢？</p>
<p><code>IQueryable</code>内部的遍历是在调用<code>DataReader</code>进行数据读取的，因此，在遍历<code>IQueryable</code>的过程中，它需要一直占用一个数据库的链接。如果想一次性的把数据表中的数据读取到客户端程序的内存中，可以使用<code>IQueryable</code>的<code>ToArray,ToArrayAsync,ToList、ToListAsync</code>等方法。如下面的代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> books = <span class="keyword">await</span> ctx.Books.Take(<span class="number">50000</span>).ToListAsync();</span><br><span class="line"> <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> books)</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">   Console.WriteLine(b.Id + <span class="string">&quot;,&quot;</span> + b.Title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，就是读取前5万条记录，然后使用<code>ToListAsync</code>方法把读取到的数据一次性的加载到内存中，然后再遍历输出数据。</p>
<p>在遍历数据的过程中，如果我们关闭<code>SQL Server</code>服务器或者断开服务器的网络，程序是可以正常运行的，这说明<code>ToListAsync</code>方法把查询结果加载到客户端内存中了。</p>
<p>除非遍历<code>IQueryable</code>并且进行数据处理的过程很耗时，否则一般不需要一次性把查询结果读取到内存中。但是在以下场景下，一次性把查询结果读取到内存中就有必要了。</p>
<p><strong>第一：方法需要返回查询结果</strong></p>
<p>如果方法需要返回查询结果，并且在方法中销毁了<code>DbContext</code>对象，方法是不能返回<code>IQueryable</code>的。如下代码所示(多对多项目中演示)：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IQueryable&lt;Student&gt; <span class="title">QueryStudents</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (TestContext ctx =<span class="keyword">new</span> TestContext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.Students.Where(s =&gt; s.Id &gt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在遍历的时候调用QueryStudents方法。</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> student <span class="keyword">in</span> <span class="title">QueryStudents</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(student.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，会出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot access a disposed context instance</span><br></pre></td></tr></table></figure>

<p>表示无法访问已经释放的<code>context</code>实例对象。</p>
<p>因为当调用完<code>QueryStudents</code>方法后，已经将<code>TestContext</code>对象销毁了，而在执行<code>foreach</code>遍历的时候，是需要通过<code>TestContext</code>链接数据库，从数据库中获取数据的，但是由于<code>TestContext</code>已经销毁了，所以无法再链接上数据库。因此程序出错了。</p>
<p>如果在<code>QueryStudents</code>方法中，采用<code>ToList</code>等方法把数据一次性加载到内存中就可以了，因为这时候在遍历的时候，只是遍历内存中的数据，而不需要再通过<code>TestContext</code>链接数据库。</p>
<p>如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span>    IEnumerable&lt;Student&gt; <span class="title">QueryStudents</span>() <span class="comment">// 这里将方法的返回类型修改成了IEnumerable</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (TestContext ctx =<span class="keyword">new</span> TestContext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  ctx.Students.Where(s =&gt; s.Id &gt; <span class="number">0</span>).ToList(); <span class="comment">// 这里使用了ToList方法。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="function"><span class="keyword">var</span> student <span class="keyword">in</span> <span class="title">QueryStudents</span>())</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(student.Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二：多个<code>IQueryable</code>的遍历嵌套</strong></p>
<p>在遍历一个<code>IQueryable</code>的时候，我们可能需要同时遍历另外一个<code>IQueryable</code>.<code>IQueryable</code>底层是使用<code>DataReader</code>从数据库中读取查询结果的，<strong>而且很多数据库是不支持多个<code>DataReader</code>同时执行的。</strong></p>
<p>如下面代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestContext ctx =<span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> teachers = ctx.Teachers.Where(t=&gt;t.Id&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> teacher <span class="keyword">in</span> teachers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(teacher.Name);</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> student <span class="keyword">in</span> ctx.Students)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(student.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码会出现如下的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There is already an open DataReader associated with this Connection which must be closed first</span><br></pre></td></tr></table></figure>

<p>这个错误的含义就是因为两个<code>foreach</code>都在遍历<code>IQueryable</code>,导致同时有两个<code>DataReader</code>在执行。</p>
<p>虽然可以在连接字符串中通过设置<code>MultipleActiveResultSets=true</code>开启“允许多个<code>DataReader</code>执行”，但是只有<code>SQL Server</code>支持<code>MultipleActiveResultSets</code>选项，其他数据库有可能不支持。因此建议采用“把数据一次性加载到内存”以改造其中一个循环的方式来解决</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestContext ctx =<span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> teachers = ctx.Teachers.Where(t=&gt;t.Id&gt;<span class="number">0</span>).ToList(); <span class="comment">// 这里使用了ToList</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> teacher <span class="keyword">in</span> teachers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(teacher.Name);</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> student <span class="keyword">in</span> ctx.Students)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(student.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述，在进行日常开发的时候，我们直接遍历<code>IQueryable</code>即可。但是如果方法需要返回查询结果或者需要多个查询嵌套执行，就要考虑把数据一次性加载到内存的方式，当然一次性查询的数据不能太多，以免造成过高的内存消耗。</p>
<p><code>KilgourNote:IQueryable底层是依靠DataReader实现的，在服务器向用户传输数据的时候要一直保持连接。</code></p>
<h1 id="26、EF-Core中的异步方法"><a href="#26、EF-Core中的异步方法" class="headerlink" title="26、EF Core中的异步方法"></a>26、<code>EF Core</code>中的异步方法</h1><p>我们知道，异步编程通常能够提升系统的吞吐量，因此如果实现某个功能的方法既有同步方法又有异步方法，我们一般应该优先使用异步</p>
<p>方法。保存上下文中数据变更的方法既有同步的在<code>SaveChanges</code>，也有异步的<code>SaveChangesAsync</code>，同样<code>EF Core</code>中其他的很多操作也都既</p>
<p>有同步方法又有异步方法。这些异步方法大部分是定义在<code>Microsoft.EntityFrameworkCore</code>命名空间下的</p>
<p><code>EntityFrameworkQueryableExtensions</code>等类中的扩展方法，因此使用这些方法之前，请在代码中添加对<code>Microsoft.EntityFrameworkCore</code>命</p>
<p>名空间的引用。<code>IQueryable</code>的异步方法有<code>AllAsync、AnyAsync、AverageAsync、ContainsAsync、CountAsync、FirstAsync</code>、</p>
<p><code>FirstOrDefaultAsync、ForEachAsync、LongCountAsync、MaxAsync、MinAsync、SingleAsync、SingleOrDefaultAsync、SumAsync</code></p>
<p>等。这些方法都是<code>IQueryable</code>的扩展方法，同时都是立即执行的方法。</p>
<p>而<code>GroupBy、OrderBy、Join、Where</code>等这些非立即执行的方法则没有对应的异步方法，。</p>
<p><strong>原因：我们知道异步方法主要用于耗<code>IO</code>的操作，避免一个操作长期占用一个线程，造成线程的阻塞，从而降低了系统的并发量。</strong></p>
<p>而使用了异步操作以后，线程可以去处理其他的任务。例如：服务员不会等待你点完菜后才会去服务其他的客户，在你看菜单的时候，服务员可以服务其他的客户。所以，异步就是针对那些耗时操作，避免长期占用线程。</p>
<p>而<code>Count,First</code>等立即执行的方法，是要生成<code>sql</code>语句去操作数据库，是比较耗时<code>IO</code>操作,所以有异步方法。</p>
<p>而<code>GroupBy,OrderBy,Where</code>等方法，没有生成<code>sql</code>语句，没有去执行数据库的操作，没有消耗<code>IO</code>.这些方法的执行速度是非常快的。因而这些方法是不需要对应的异步方法的。</p>
<p>问题：遍历<code>IQueryable</code>的操作。如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestContext ctx =<span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> teachers = ctx.Teachers.Where(t=&gt;t.Id&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> teacher <span class="keyword">in</span> teachers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(teacher.Name);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是通过<code>foreach</code>遍历<code>IQueryable</code>,这是一个同步操作，是消耗<code>IO</code>的。</p>
<p>那么怎样进行异步的遍历<code>IQueryable</code>呢？</p>
<p>有两种方式：</p>
<p>第一种方式，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestContext ctx =<span class="keyword">new</span> TestContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> teachers = <span class="keyword">await</span> ctx.Teachers.Where(t=&gt;t.Id&gt;<span class="number">0</span>).ToListAsync(); <span class="comment">// 使用了await 与ToListAsync方法。</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> teacher <span class="keyword">in</span> teachers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(teacher.Name);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用了<code>ToListAsync</code>方法，在读取数据并且填充到<code>List</code>集合中的过程是采用<code>异步</code>方式完成的。而在遍历的时候是从<code>List</code>集合也就是内存中获取数据，这个过程就不涉及到<code>IO</code>的问题了。但是要注意的就是我们前面所讲的不要将太大的数据填充到内存中。</p>
<p>第二种方式，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> teachers =  ctx.Teachers.Where(t =&gt; t.Id &gt; <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">await</span> <span class="keyword">foreach</span> (<span class="keyword">var</span> t <span class="keyword">in</span> teachers.AsAsyncEnumerable()) <span class="comment">// 注意 foreach前面添加了await</span></span><br><span class="line">  &#123;</span><br><span class="line">      Console.WriteLine(t.Name);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里是通过<code>AsAsyncEnumerable方法</code>将<code>IEnumerable</code>转换成了异步的<code>IEnumerable</code>.</p>
<p>不过，一般情况下没有必要这么做，因为我们遍历的时候，内存中的数据也不是很大，速度也比较快。</p>
<p>如果后期在遍历数据的时候，确实出现了性能的瓶颈的时候，可以考虑以上的处理方式。</p>
<h1 id="27、EF-Core如何执行原生SQL语句"><a href="#27、EF-Core如何执行原生SQL语句" class="headerlink" title="27、EF Core如何执行原生SQL语句"></a>27、<code>EF Core</code>如何执行原生<code>SQL</code>语句</h1><p>尽管<code>EF Core</code>已经非常强大，但是在某些场景一下，<code>EF Core</code>中的方法可能无法满足我们的需求。因此在少数场景下，我们仍然需要再<code>EF Core</code>中执行原生的<code>SQL</code>语句。</p>
<p>本小节，我们就来看一下，如何在<code>EF Core</code>中执行原生的<code>SQL</code>语句。</p>
<p>在<code>EF Core</code>中执行原生的<code>SQL</code>语句，有<code>SQL</code>非查询语句，实体类<code>SQL</code>查询语句，任意<code>SQL</code>查询语句等几种用法。</p>
<p><code>KilgourNote:</code></p>
<ol>
<li>执行<code>SQL</code>非查询语句:<code>ExecuteSqlInterpolatedAsync(原生SQL语句)</code></li>
<li>执行实体类<code>SQL</code>查询语句:<code>FromSqlInterpolated(原生SQL语句)</code></li>
<li>执行任意<code>SQL</code>查询语句:<code>Ado.net</code>的方式或者是<code>Dapper</code>等轻量级的<code>ORM</code>框架</li>
</ol>
<h2 id="27-1-执行SQL非查询语句"><a href="#27-1-执行SQL非查询语句" class="headerlink" title="27.1  执行SQL非查询语句"></a>27.1  执行<code>SQL</code>非查询语句</h2><p>我们可以通过<code>dbCtx.Database.ExecuteSqlInterpolated</code>或者异步的<code>dbCtx.Database.ExecuteSqlInterpolatedAsync</code>方法执行原生的<code>SQL</code>非查询语句，下面举一个例子(在多对多项目中演示)。</p>
<p>下面执行的是一个<code>insert</code>语句，不是查询语句。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;请输入老师名称&quot;</span>);</span><br><span class="line">   <span class="built_in">string</span>? uname = Console.ReadLine();</span><br><span class="line">    <span class="keyword">await</span> ctx.Database.ExecuteSqlInterpolatedAsync(<span class="string">$&quot;insert into T_Teachers([Name]) values (<span class="subst">&#123; uname &#125;</span>)&quot;</span>);</span><br><span class="line"><span class="comment">//   Console.WriteLine(&quot;rows = &quot;,rows);</span></span><br></pre></td></tr></table></figure>

<p>通过上面的代码，我们可以看到<code>ExecuteSqlInterpolatedAsync</code>这个方法中使用了<code>&#123;uname&#125;</code>这样的插值方式为<code>SQL</code>语句提供参数值。</p>
<p>有同学可能会有疑问，这样字符串插值的方式不会有<code>SQL</code>注入攻击漏洞吗？答案是不会的，通过<code>SQL Server Profile</code>工具查看上面操作所生成的<code>SQL</code>语句，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">insert <span class="keyword">into</span> <span class="title">T_Teachers</span>(<span class="params">[Name]</span>) <span class="title">values</span> (<span class="params">@p0</span>)</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，我们所写的<code>&#123;uname&#125;</code>这种内插变量，被翻译成了<code>@p0</code>这样的参数，而不是简单的字符串拼接。</p>
<p>因此这样的操作不会有<code>SQL</code>注入攻击的漏洞。</p>
<p>下面我们再来看一个例子，来体会一下<code>ExecuteSqlInterpolatedAsync</code>方法的使用</p>
<p>这里我们执行一个<code>insert into ...select</code>语句，该语句的含义是：<code>先查询出数据，再把查询结果插入数据表中</code>.</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> ctx.Database.ExecuteSqlInterpolatedAsync(<span class="string">$&quot; insert into T_Teachers(Name) select Name from T_Teachers&quot;</span>);</span><br><span class="line"></span><br><span class="line"> Console.WriteLine(result);</span><br></pre></td></tr></table></figure>

<p>下面我们再来演示一下，看一下是否会有<code>SQL</code>注入攻击的问题。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> uname = <span class="string">&quot;;delete from T_Teachers;&quot;</span>;</span><br><span class="line">   <span class="built_in">int</span> rows = <span class="keyword">await</span> ctx.Database.ExecuteSqlInterpolatedAsync(<span class="string">$&quot;insert into T_Teachers([Name]) values (<span class="subst">&#123;uname&#125;</span>)&quot;</span>);</span><br><span class="line">   Console.WriteLine(rows);</span><br></pre></td></tr></table></figure>

<p>执行上面的代码，我们可以看到直接将<code>delete</code>语句插入到数据表中了。所以不存在<code>sql</code>注入的问题。</p>
<p>为什么没有<code>sql</code>注入的问题？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> uname = <span class="string">&quot;delete from T_Teachers;&quot;</span>;</span><br><span class="line">   <span class="built_in">string</span> sql = <span class="string">$&quot;insert into T_Teachers(Name) values (<span class="subst">&#123;uname&#125;</span>)&quot;</span>;</span><br><span class="line">   Console.WriteLine(sql);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们直接打印了<code>sql</code>变量，得到的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into T_Teachers(Name) values (delete from T_Teachers;)</span><br></pre></td></tr></table></figure>

<p>这里从执行结果上看，是进行了字符串的拼接，是有<code>sql</code>注入的。</p>
<p>但是，为什么作为<code>ExecuteSqlInterpolatedAsync</code>方法的参数以后，就不存在<code>sql</code>注入的问题呢？</p>
<p>我们把鼠标指向<code>ExecuteSqlInterpolatedAsync</code>方法上，可以看到它需要的参数类型是<code>FormattableString</code>类型。</p>
<p>下面把上面的代码，修改一下，修改成如下的形式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> uname = <span class="string">&quot;delete from T_Teachers;&quot;</span>;</span><br><span class="line">  FormattableString sql = <span class="string">$&quot;insert into T_Teachers(Name) values (<span class="subst">&#123;uname&#125;</span>)&quot;</span>;</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;Format:&quot;</span>+sql.Format);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;参数&quot;</span>+<span class="built_in">string</span>.Join(<span class="string">&quot;,&quot;</span>,sql.GetArguments()));</span><br></pre></td></tr></table></figure>

<p>这里我们将<code>sql</code>变量的类型修改成了<code>FormattableString</code>类型。</p>
<p>同时打印了<code>Format</code>属性，该属性输出的内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into T_Teachers(Name) values (&#123;0&#125;)</span><br></pre></td></tr></table></figure>

<p>这里，我们可以看到我们在<code>sql</code>语句中写的插值表达式被占位符<code>&#123;0&#125;</code>给占用了。但是该占位符的值是多少呢？</p>
<p>我们再来看一下<code>GetArguments</code>方法的输出结果，该方法的输出结果是一个数组，所以这里我们使用<code>string.Join</code>方法将其分割成了字符串。打印的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from T_Teachers;</span><br></pre></td></tr></table></figure>

<p>也就是会使用上面的参数替换掉占位符。</p>
<p>所以说：当一个<code>C#</code>字符串中包含内插值表达式，然后将该字符串赋值给了一个<code>FormattableString</code>类型的变量以后，编译器会把字符串中插值表达式以及赋值给插值表达式的值等内容构建成一个<code>FormattableString</code>对象，<code>FormattableString</code>对象中包含了插值表达式以及每个参数的值。这样在执行<code>ExecuteSqlInterpolatedAsync</code>这个方法的时候，就可以根据<code>FormattableString</code>对象的信息去构建参数化查询<code>SQL</code>语句。（解决<code>sql</code>注入攻击最好的方式就是参数化查询）</p>
<p>所以说，以后写<code>sql</code>语句就写成这种内插值的方式。</p>
<p>除了<code>ExecuteSqlInterpolated、ExecuteSqlInterpolatedAsync</code>方法之外，<code>EF Core</code>的<code>ExecuteSqlRaw、ExecuteSqlRawAsync</code>等方法也可以执行原生<code>SQL</code>语句，但使用这两个方法需要开发人员自己处理查询参数等问题，因此不推荐使用。</p>
<h2 id="27-2-执行实体类SQL查询语句"><a href="#27-2-执行实体类SQL查询语句" class="headerlink" title="27.2 执行实体类SQL查询语句"></a>27.2 执行实体类<code>SQL</code>查询语句</h2><p>如果我们要执行的<code>SQL</code>语句是一个查询语句，并且查询的结果也能对应一个实体类（注意：这里需要对应一个实体，有可能一个查询会关联多张表，这时候就不会对应一个实体，就不能使用这一小节所介绍的方法），<strong>就可以调用对应实体类的<code>DbSet</code>的（由于这里是对应一个实体，所以调用的就是<code>DbSet</code>中的方法）</strong><code>FromSqlInterpolated</code>方法执行一个<code>SQL</code>语句，<strong>该方法的参数是<code>FormattableString</code>类型，因此同样可以使用字符串内插值传递参数、</strong></p>
<p>案例：查询编姓<code>张</code>的学生信息（这个需求完成可以通过<code>EFCore</code>中的方法来实现，这里我们假设只能自己写<code>SQL</code>语句来实现，<code>EF Core</code>中的扩展方法满足无法满足这个需求）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;张%&quot;</span>;</span><br><span class="line">   IQueryable&lt;Student&gt; students = ctx.Students.FromSqlInterpolated(<span class="string">$&quot; select * from T_Students where Name like <span class="subst">&#123;s&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">foreach</span> ( <span class="keyword">var</span> student <span class="keyword">in</span> students)</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine( student.Name );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>我们看<code>FromSqlInterpolated</code>没有异步的方法，只有同步的方法，原因是该方法返回的是<code>IQueryable</code>，也就是没有真正的执行查询操作，所以说该方法并没有<code>IO</code>的耗时操作。因此该方法不需要异步方法。</p>
<p>查看一下生成的<code>sql</code>语句，发现也是带参数的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T_Students where Name like @p0</span><br></pre></td></tr></table></figure>

<p>这里很明显进行了参数化的处理。</p>
<p>由于<code>FromSqlInterpolated</code>方法返回值是<code>IQueryable</code>类型的，因此我们可以在实际执行<code>IQueryable</code>之前，对<code>IQueryable</code>进行进一步的处理，例如使用<code>Skip</code>和<code>Take</code>方进行分页查询。</p>
<p>如下下面代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;张%&quot;</span>;</span><br><span class="line">    IQueryable&lt;Student&gt; students = ctx.Students.FromSqlInterpolated(<span class="string">$&quot; select * from T_Students where Name like <span class="subst">&#123;s&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ( <span class="keyword">var</span> student <span class="keyword">in</span> students.Skip(<span class="number">1</span>).Take(<span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( student.Name );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就是就是跳过1条取2条记录。</p>
<p>当然，这里我们也可以对数据进行排序</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;张%&quot;</span>;</span><br><span class="line">   IQueryable&lt;Student&gt; students = ctx.Students.FromSqlInterpolated(<span class="string">$&quot; select * from T_Students where Name like <span class="subst">&#123;s&#125;</span> order by id desc&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">foreach</span> ( <span class="keyword">var</span> student <span class="keyword">in</span> students.Skip(<span class="number">1</span>).Take(<span class="number">2</span>))</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine( student.Name );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们是将<code>order by</code>直接写到了<code>sql</code>语句中，执行上面的代码程序出错了。</p>
<p>我们通过<code>SQL Server Profile</code>来查看一下所生成的<code>SQL</code>语句，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [多].[Id], [多].[Name]</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">     <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T_Students <span class="keyword">where</span> Name <span class="keyword">like</span> <span class="variable">@p0</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span></span><br><span class="line">) <span class="keyword">AS</span> [多]</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (<span class="keyword">SELECT</span> <span class="number">1</span>)</span><br><span class="line"><span class="keyword">OFFSET</span> @__p_1 <span class="keyword">ROWS</span> <span class="keyword">FETCH</span> NEXT @__p_2 <span class="keyword">ROWS</span> <span class="keyword">ONLY</span><span class="string">&#x27;,N&#x27;</span><span class="variable">@p0</span> nvarchar(<span class="number">4000</span>),@__p_1 <span class="type">int</span>,@__p_2 <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>这里发现，子查询中包含了<code>order by</code>，而在外层查询中通过<code>offset fetch</code>实现了分页操作。</p>
<p><strong>但是问题是在<code>SQLServer</code>中<code>order by</code>是不能用在子查询中的。</strong></p>
<p>这时候，正确的排序写法如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">string</span> s = <span class="string">&quot;张%&quot;</span>;</span><br><span class="line">    IQueryable&lt;Student&gt; students = ctx.Students.FromSqlInterpolated(<span class="string">$&quot; select * from T_Students where Name like <span class="subst">&#123;s&#125;</span> &quot;</span>);</span><br><span class="line"><span class="comment">// 指定了排序方式，按照id编号降序排序</span></span><br><span class="line">    <span class="keyword">foreach</span> ( <span class="keyword">var</span> student <span class="keyword">in</span> students.OrderByDescending(s=&gt;s.Id).Skip(<span class="number">1</span>).Take(<span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( student.Name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行上面的代码发现没有问题。</p>
<p>所以说，<code>FromSqlInterpolated</code>方法只能执行原生<code>SQL</code>语句写的逻辑，然后把分页，分组，排序，二次过滤，<code>Include</code>等其他的逻辑尽可能的使用<code>EF Core</code>的标准操作去实现。</p>
<p>例如：这里我们想关联<code>T_Teachers</code>表，就可以使用<code>include</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">string</span> s = <span class="string">&quot;张%&quot;</span>;</span><br><span class="line"><span class="comment">// 注意：不要在Students后面调用Include，因为FromSqlInterpolated方法是来自DbSet</span></span><br><span class="line">    IQueryable&lt;Student&gt; students = ctx.Students.FromSqlInterpolated(<span class="string">$&quot; select * from T_Students where Name like <span class="subst">&#123;s&#125;</span> &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里添加了Include方法，关联了Teacher表</span></span><br><span class="line">    <span class="keyword">foreach</span> ( <span class="keyword">var</span> student <span class="keyword">in</span> students.Include(t =&gt; t.Teachers).OrderByDescending(s=&gt;s.Id).Skip(<span class="number">1</span>).Take(<span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine( student.Name );</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> teacher <span class="keyword">in</span> student.Teachers)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;teacher.Name&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>FromSqlInterpolated</code>方法也有使用的局限性：</p>
<p>第一:<code>SQL</code>查询必须返回实体类型对应数据表的所有列（返回部分列，会出现问题）</p>
<p>第二：查询结果集中的列名必须与属性映射到的列名匹配。</p>
<p>第三：<code>SQL</code>语句只能进行单表查询，不能使用<code>Join</code>语句进行关联查询，但是可以在查询后面使用<code>Include</code>方法进行关联数据的获取。</p>
<p>注意：如果是关联多表的查询，例如报表查询，这时候，并不会具体对应到某个实体，同时即使按照以上通过<code>Include</code>进行关联，生成的<code>SQL</code>语句有可能也不是高效的，这时候就需要自己写<code>SQL</code>语句。这种情况就不适合使用<code>FromSqlInterpolated</code>方法来进行查询</p>
<p>问题是，针对这种复杂的<code>SQL</code>语句，应该怎样执行呢？我们下一小节再进行讲解。</p>
<h2 id="27-3-执行任意SQL查询语句"><a href="#27-3-执行任意SQL查询语句" class="headerlink" title="27.3 执行任意SQL查询语句"></a>27.3 执行任意<code>SQL</code>查询语句</h2><p><code>FromSqlInterpolated</code>只能执行单实体类的查询，但是在实现报表查询的时候，<code>SQL</code>语句通常是非常复杂的，不仅要多表关联，而且返回的查询结果一般也都不会和一个实体类完整对应，因此我们需要一种执行任意<code>SQL</code>查询语句的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">存储过程好处:存储过程只需要在创建的时候编译，而普通的`sql`是使用一次编译一次，所以使用存储过程可以提高运行速度，减少流量交互。</span><br><span class="line"></span><br><span class="line">视图好处：`https://www.cnblogs.com/lip-blog/p/7402550.html`</span><br></pre></td></tr></table></figure>



<p><code>EF Core</code>中允许把一个视图或者一个存储过程映射为实体类，因此我们可以把复杂的查询语句写成视图或者存储过程，然后声明对应的实体类，并且在上下文中配置对应的<code>DbSet</code>属性。不过，目前大部分公司都不推荐编写存储过程（存储过程中包含了业务，数据库的压力增大，同时存储过程是不跨数据库的，不同数据库创建存储过程的语法是不一样的。），而推荐创建视图。但是项目的报表等复杂查询通常很多，因此对应的视图也会很多，我们就需要在上下文类中配置很多本质上不是实体类的“实体类”，这会造成项目中“实体类”的膨胀，也就是<code>DbSet</code>的膨胀，不利于项目的管理。</p>
<p>如下伪代码所示(<code> T_Students</code>可以理解成是一个视图)：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Name <span class="keyword">from</span> T_Students </span><br></pre></td></tr></table></figure>

<p>以上的查询没有对应一个具体的实体类，也就是没有和一张数据表对应的实体，而我们可以自己定义一个<code>实体类</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">StudentInfo</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">ctx.StudentInfos.FromSqlInterPolated(<span class="string">&quot;select Name as ACount from T_Students &quot;</span>)</span><br></pre></td></tr></table></figure>

<p>虽然，我们可以采用如上的做法，但是这样会导致<code>DbSet</code>的膨胀，非常不利于项目的管理。</p>
<p>像这种情况，我们可以直接使用原生的<code>ADO.NET</code>来进行数据的查询。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的ctx还是DbContext对象</span></span><br><span class="line">DbConnection conn= ctx.Database.GetDbConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn.State != System.Data.ConnectionState.Open)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> conn.OpenAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> cmd = conn.CreateCommand())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据姓进行分组，并且统计每组的个数</span></span><br><span class="line">        cmd.CommandText = <span class="string">&quot;select substring(Name,1,1) as su ,count(*) as acount from T_Students Group by substring(Name,1,1)&quot;</span>;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> reader = <span class="keyword">await</span> cmd.ExecuteReaderAsync())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">await</span> reader.ReadAsync())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> name = reader.GetString(<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">int</span> count = reader.GetInt32(<span class="number">1</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;name&#125;</span>&quot;</span>);</span><br><span class="line">                Console.WriteLine(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当然，以上的写法还是比较麻烦，还需要处理参数等情况。</p>
<p>所以可以使用<code>Dapper</code>这个轻量级的<code>ORM</code>框架。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Dapper </span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  注意这里的ctx还是DbContext对象</span></span><br><span class="line"><span class="keyword">var</span> items = ctx.Database.GetDbConnection().Query&lt;StudentInfo&gt;(<span class="string">&quot;select substring(Name,1,1) as Name ,count(*) as Acount from T_Students Group by substring(Name,1,1)&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(item.Name);</span><br><span class="line">        Console.WriteLine(item.Acount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里在<code>TestContext</code>的范围外部定义一个<code>StudentInfo</code>类，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">StudentInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Acount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>sql</code>语句中<code>as</code>后面的别名，与<code>StudentInfo</code>中的属性保持一致。把查询的数据映射到了对应的属性上。</p>
<p>这里我们没有定义<code>DbSet</code>，只是定义了一个普通的类，这就是模型类，这样就不会出现<code>DbSet</code>的膨胀问题。</p>
<p>这里底层还是对<code>Ado.net</code>的封装。</p>
<p>关于<code>Dapper</code>的其他应用，大家可以查看文档自己学习。(<code>https://www.cnblogs.com/gaoyongtao/p/15993191.html</code>)</p>
<p><code>EF Core</code>与<code>Dapper</code>可以混合使用，根据不同的情况选择不同的技术。</p>
<p>总结：</p>
<p>第一：一般<code>Linq</code>查询就够用了，尽量不用原生的<code>sql</code>，除非遇到前面所讲到的特殊情况</p>
<p>第二：非查询(<code>insert ,update,delete</code>)<code>sql</code>用<code>ExecuteSqlInterpolatedAsync( )</code>方法</p>
<p>第三： 针对实体的<code>SQL</code>查询用<code>FromSqlInterpolated( )</code></p>
<p>第四：复杂<code>sql</code>查询用<code>Ado.net</code>的方式或者是<code>Dapper</code>等轻量级的<code>ORM</code>框架。</p>
<h1 id="28、实体类变化的检测"><a href="#28、实体类变化的检测" class="headerlink" title="28、实体类变化的检测"></a>28、实体类变化的检测</h1><p><code>KilgourNote:使用Linq查询语句查询出来的数据都处于DbContext的监视之下，因此查询出来的数据并不需要放入DbSet中也可以被SaveChangesAsync保存到数据库中。但是在Using(MyDbContext mc = new MyDbContext)中创建的新的模型对象则需要mc.Add()方法才能进入DbContext的监视中。</code></p>
<p>当我们修改从<code>DbContext</code>中查询出来的对象并调用<code>SaveChanges</code>方法的时候，<code>EF Core</code>会检测对象的状态变化，然后把变化后的数据保存到数据库中，但是实体类没有实现属性值改变的通知机制），<code>EFCore</code>是如何检测到实体类的这些变化的呢？</p>
<p>如下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student =<span class="keyword">await</span> ctx.Students.FirstOrDefaultAsync();</span><br><span class="line">    student.Name = <span class="string">&quot;张三三&quot;</span>;</span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们查询出了第一个学生信息，并且将学生的名字有<code>张三</code>修改成了<code>张三三</code>。</p>
<p>问题是：<code>EF Core</code>怎么就知道，我们赋值给<code>Name</code>属性新的值了呢（这里的<code>Name</code>属性就是一个普通的属性）？从而生成一个<code>update</code>语句进行更新呢？</p>
<p>因为,<code>EF Core</code>默认采用<code>快照更改跟踪</code>来实现实体类改变的检测。也就是说只要一个实体类对象和<code>DbContext</code>发生关系，例如上面的查询关系，或者是<code>Add</code>（添加）关系等，都默认会被<code>DbContext</code>跟踪。</p>
<p>怎么进行跟踪的呢？</p>
<p><code>EF Core</code>会创建这个实体类的快照，当执行<code>SaveChanges</code>等方法的时候，<code>EF Core</code>将会把存储在快照中的值与实体类的当前值进行比较，以确定哪些属性值被更改了。</p>
<p>这个快照，我们可以理解成就是创建了一个副本（拍了一张照片）</p>
<p><code>EF Core</code>还支持“通知实体类”“更改跟踪代理”等检测实体类改变的机制，但是这些机制用起来比较麻烦，带来的好处也不明显，因此我们一般都用默认的“快照更改跟踪”机制.</p>
<p>实体类的改变并不只有“属性值改变”这样一种情况，实体类中属性被删除，添加等也属于改变。对应着就有不同的状态，实体类有如下5种可能的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">已添加（Added）：DbContext正在跟踪此实体类，但数据库中尚不存在此实体类。(新增实体，但是对应的数据还没有插入到数据库中)</span><br><span class="line">例如：</span><br><span class="line">  Student s = new Student()</span><br><span class="line">   s.Name =&quot;hello&quot;;</span><br><span class="line">   ctx.Students.Add(s) // 这里新创建了一个实体对象，并且与DbContext产生了关系，但是还没有执行SaveChanges方法，此时该对象的状态就是Added已添加状态。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">未改变（Unchanged）：DbContext在跟踪此实体类，此实体类存在于数据库中，其属性值和从数据库中读取到的值一致，未发生改变。</span><br><span class="line"> var student =await ctx.Students.FirstOrDefaultAsync();</span><br><span class="line"> 这里的实体对象`student`与`DbContext`产生了关系，但是没有修改其任何属性的值，这时候该对象就是未改变状态。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">已修改（Modified）：上下文正在跟踪此实体类，此实体类存在于数据库中，并且其部分属性值已被修改。</span><br><span class="line">var student =await ctx.Students.FirstOrDefaultAsync();</span><br><span class="line">    student.Name = &quot;张三三&quot;;</span><br><span class="line">    await ctx.SaveChangesAsync(); // 这里通过`DbContext`查询出了`student`对象，该对象就与`DbContext`产生了关系，然后给`student`对象中的`Name`属性赋了值，当调用`SaveChanges`方法的时候当前的`student`对象就是已修改状态</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">已删除（Deleted）：上下文正在跟踪此实体类，此实体类存在于数据库中，但在下次调用SaveChanges时要从数据库中删除对应数据。</span><br><span class="line">    var student =await ctx.Students.FirstOrDefaultAsync();</span><br><span class="line"> </span><br><span class="line">    ctx.Students.Remove(student); // 这时候状态是已删除状态。</span><br><span class="line"></span><br><span class="line">    await ctx.SaveChangesAsync();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分离（Detached）：上下文未跟踪该实体类。</span><br><span class="line">Student stu = new Student();</span><br><span class="line">这里是新创建了一个实体对象stu,但是该对象并没有与`DbContext`产生任何的关系，所以该实体对象的状态就是分离的状态</span><br></pre></td></tr></table></figure>

<p>当执行<code>SaveChanges</code>的时候，<code>EFCore</code>会就会判断实体对象的状态，从而执行不同的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">·对于分离和未改变的实体类，SaveChanges会忽略它们。</span><br><span class="line">·对于已添加的实体类，SaveChanges把它们插入数据库。</span><br><span class="line">·对于已修改的实体类，SaveChanges把对它们的修改更新到数据库。</span><br><span class="line">·对于已删除的实体类，SaveChanges把它们从数据库中删除。</span><br></pre></td></tr></table></figure>

<p>下面我们来查看一下以上所说的这些状态。</p>
<p>这里，我们可以使用<code>DbContext</code>对象中的<code>Entry</code>方法获取一个实体类在<code>EF Core</code>中的跟踪信息对象<code>EntityEntry</code>.</p>
<p><code>EntityEntry</code>中的<code>State</code>属性代表了实体的状态。并且通过<code>DebugView.LongView</code>属性我们可以看到实体类的状态变化信息。</p>
<p>下面我们来看一下代码示例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student[] stus = ctx.Students.ToArray();</span><br><span class="line">  Student s1= stus[<span class="number">0</span>];</span><br><span class="line">  Student s2= stus[<span class="number">1</span>];</span><br><span class="line">  Student s3= stus[<span class="number">2</span>];</span><br><span class="line">  Student s4 = <span class="keyword">new</span> Student&#123;Name = <span class="string">&quot;小于&quot;</span> &#125;;</span><br><span class="line">  Student s5 = <span class="keyword">new</span> Student &#123; Name = <span class="string">&quot;小孙&quot;</span> &#125;;</span><br><span class="line">  s1.Name = <span class="string">&quot;张小三&quot;</span>;</span><br><span class="line">  ctx.Remove(s3);</span><br><span class="line">  ctx.Add(s4);</span><br><span class="line">  EntityEntry entry1 = ctx.Entry(s1);</span><br><span class="line">  EntityEntry entry2 = ctx.Entry(s2);</span><br><span class="line">  EntityEntry entry3 = ctx.Entry(s3);</span><br><span class="line">  EntityEntry entry4 = ctx.Entry(s4);</span><br><span class="line">  EntityEntry entry5 = ctx.Entry(s5);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;s1.state:&quot;</span>+ entry1.State);</span><br><span class="line">  Console.WriteLine(<span class="string">&quot;s1.DebugView:&quot;</span>+ entry1.DebugView.LongView);</span><br></pre></td></tr></table></figure>

<p>从上面程序的输出结果我们可以看出来，<code>s1</code>这个对象由于被修改了，因此状态是<code>Modified</code>, 而且<code>Debug View</code>中输出的是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student &#123;Id: 1&#125; Modified</span><br><span class="line">  Id: 1 PK</span><br><span class="line">  Name: &#x27;张小三&#x27; Modified Originally &#x27;张三三&#x27;</span><br><span class="line">  Teachers: []</span><br></pre></td></tr></table></figure>

<p>编号为1的<code>Student</code>为<code>Modified</code>. <code>Name</code>的新值是<code>张小三</code>，原来的值是<code>张三三</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;s2.state:&quot;</span> + entry2.State); </span><br><span class="line">Console.WriteLine(<span class="string">&quot;s3.state:&quot;</span> + entry3.State);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;s4.state:&quot;</span> + entry4.State);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;s5.state:&quot;</span> + entry5.State);</span><br></pre></td></tr></table></figure>

<p><code>s2</code>对象从数据库中查询出来后没有任何修改，因此状态是<code>Unchanged</code></p>
<p><code>s3</code>对象被<code>Remove</code>方法标记为删除状态，因此对应的状态是<code>Deleted</code></p>
<p><code>s4,s5</code>两个对象都是新创建的对象，由于<code>b4</code>通过<code>Add</code>方法添加到了<code>DbContext</code>对象中，因此<code>b4</code>的状态是<code>Added</code>.</p>
<p>而<code>s5</code>这个新创建的对象没有与<code>DbContext</code>对象产生任何关系，所以<code>s5</code>状态是<code>Detached</code>.</p>
<p>由此可见，<code>EF Core</code>会跟踪实体类的状态，在执行<code>SaveChanges</code>的时候，<code>EF Core</code>会根据实体类状态的不同，生成对应的<code>Update、Delete、Insert</code>等<code>SQL</code>语句，从而把内存中实体类的变化同步到数据库中。</p>
<h1 id="29、EF-Core性能优化"><a href="#29、EF-Core性能优化" class="headerlink" title="29、EF Core性能优化"></a>29、<code>EF Core</code>性能优化</h1><p>我们知道<code>EF Core</code>会将我们所写的<code>C#</code>代码转换成对应的<code>sql</code>语句来操作数据库，如果我们使用<code>EF Core</code>不当，应用程序的性能和数据正确性会受到威胁，因此有必要对于如何更高性能地使用<code>EF Core</code>以及如何解决数据库并发问题进行讲解。</p>
<h2 id="29-1-EF-Core-优化之-AsNoTracking"><a href="#29-1-EF-Core-优化之-AsNoTracking" class="headerlink" title="29.1 EF Core 优化之 AsNoTracking"></a>29.1 <code>EF Core </code>优化之 <code>AsNoTracking</code></h2><p>在上一小节中我们讲到了<code>EF Core</code>默认会对通过<code>DbContext</code>对象查询出来的所欲实体类进行跟踪，以便于在执行<code>SaveChanges</code>的时候把实体类的改变同步到数据库中，<code>DbContext</code>对象不仅会跟踪对象的状态改变，还会通过快照的方式记录实体类的原始值，这是比较消耗资源的。因此，如果我们能够确认通过<code>DbContext</code>查询出来的对象只是用来展示，不会发生状态改变，那么可以使用<code>AsNoTracking</code>方法告诉<code>IQueryable</code>在查询的时候<code>禁用跟踪</code>，如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; stus = ctx.Students.AsNoTracking().Take(<span class="number">3</span>).ToList();</span><br><span class="line">    Student s = stus[<span class="number">0</span>];</span><br><span class="line">    Console.WriteLine(s.Name);   <span class="comment">// 打印第一个学生的姓名</span></span><br><span class="line">    s.Name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    EntityEntry entry1 = ctx.Entry(s);</span><br><span class="line">    Console.WriteLine(entry1.State); <span class="comment">// 这里输出的结果是`Detached`</span></span><br></pre></td></tr></table></figure>

<p>执行上面的代码，打印的<code>entry1.State</code>的值是<code>Detached</code>，也就是说使用了<code>AsNoTracking</code>查询出来的实体类是不被<code>DbContext</code>跟踪的。</p>
<p>这里我们即使调用<code>SaveChanges</code>方法也不会更新，不会生成<code>update</code>语句。</p>
<p>因此，在项目开发的时候，如果我们查询出来的对象不会被修改、删除等，那么在查询的时候，可以启用<code>AsNoTracking</code>，这样就能降低&#96;&#96;EF Core&#96;的资源占用。</p>
<h2 id="29-2-实体状态跟踪的妙用"><a href="#29-2-实体状态跟踪的妙用" class="headerlink" title="29.2 实体状态跟踪的妙用"></a>29.2 实体状态跟踪的妙用</h2><p>在使用<code>EF Core</code>的时候，我们可以借用状态跟踪机制，来完成一些特殊的需求。</p>
<p>由于<code>EF Core</code> 需要跟踪实体类的改变，因此如果我们需要修改一个实体类的属性值，一般都需要先查询出来对应的实体类，然后修改相应的属性值，最后调用<code>SaveChanges</code>保存修改到数据库中。如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student? s = <span class="keyword">await</span> ctx.Students.FirstOrDefaultAsync(s=&gt;s.Id == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s.Name = <span class="string">&quot;张晓&quot;</span>;</span><br><span class="line">       <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码生成的<code>SQL</code>语句，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT TOP(1) [t].[Id], [t].[Name]</span><br><span class="line">FROM [T_Students] AS [t]</span><br><span class="line">WHERE [t].[Id] = CAST(1 AS bigin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exec sp_executesql N&#x27;SET IMPLICIT_TRANSACTIONS OFF;</span><br><span class="line">SET NOCOUNT ON;</span><br><span class="line">UPDATE [T_Students] SET [Name] = @p0</span><br><span class="line">OUTPUT 1</span><br><span class="line">WHERE [Id] = @p1;</span><br><span class="line">&#x27;,N&#x27;@p1 bigint,@p0 nvarchar(20)&#x27;,@p1=1,@p0=N&#x27;张晓晓&#x27;</span><br></pre></td></tr></table></figure>

<p>可以看到，生成了<code>select</code>查询语句，同时也生成了<code>update</code>更新语句。</p>
<p>讲到这，有同学就可能已经想到了一个问题。如果直接执行<code>sql</code>语句的话，我们仅可以通过一条<code>update</code>语句就能完成数据的更新操作。</p>
<p>但是在<code>EF Core</code>中就需要两条<code>SQL</code>语句完成更新操作。</p>
<p>当然在<code>EF Core</code>中我们可以利用状态跟踪机制实现一条<code>Update</code>语句完成数据更新的功能。</p>
<p>如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student &#123; Id =<span class="number">1</span> &#125;;</span><br><span class="line">   student.Name = <span class="string">&quot;张小小&quot;</span>;</span><br><span class="line">   <span class="keyword">var</span> entry1 = ctx.Entry(student);</span><br><span class="line">   entry1.Property(<span class="string">&quot;Name&quot;</span>).IsModified = <span class="literal">true</span>;</span><br><span class="line">   ctx.SaveChanges();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过<code>SQL Server Profile</code>工具只能看到只有1条<code>update</code>语句。</p>
<p>在上面的代码中，创建了<code>Student</code>对象，并且指定了要跟新的是编号为1的数据。这里是修改编号为1的学生姓名。</p>
<p>然后创建<code>Entry</code>对象。通过该对象中的<code>Property</code>方法获取<code>Name</code>属性的跟踪对象，然后通过设置<code>IsModified</code>为<code>true</code>，把<code>Name</code>属性设置为已修改,注意：只要实体类中的一个属性标记为已修改，那么这个实体类对应的状态也会被设置为已修改。最后执行<code>SaveChanges</code>方法进行修改，由于这里我们通过对象的<code>Id</code>属性的方式告诉了<code>EF Core</code>要更新哪条数据，所以会生成对应的<code>update</code>语句。</p>
<p>同样的，常规的<code>EF Core</code>开发中，如果要删除一条数据，我们也要将要删除的数据查询出来，然后在调用<code>DbContext</code>对象中的<code>Remove</code>方法把实体类标记为已删除，再执行<code>SaveChanges</code>方法的进行删除操作。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student? s = <span class="keyword">await</span> ctx.Students.FirstOrDefaultAsync(s =&gt; s.Id == <span class="number">1</span>); <span class="comment">// 这里会生成select查询</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ctx.Remove(s); <span class="comment">// 指定了删除状态</span></span><br><span class="line">    <span class="keyword">await</span> ctx.SaveChangesAsync(); <span class="comment">// 生成delete语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然，在<code>EF Core</code>中我们也可以利用状态跟踪机制实现一条<code>Delete</code>语句完成数据的删除操作。</p>
<p>如下面代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student &#123; Id =<span class="number">9</span> &#125;;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> entry1 = ctx.Entry(student);</span><br><span class="line">entry1.State = EntityState.Deleted;</span><br><span class="line">ctx.SaveChanges();</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们创建了一个<code>Student</code>对象，并且指定了<code>Id</code>属性的值是9，也就是删除编号为9的这条记录，然后我们把实体类对应的<code>State</code>属性设置为了<code>Deleted</code>状态，来标记这个实体类为已经删除。</p>
<p>总结：通过上面的演示，我们知道借助于<code>EF Core</code>的实体类跟踪机制，我们可以让<code>EF Core</code>生成更加简洁的<code>SQL</code>语句，</p>
<p><strong>大部分情况下，采用这种技巧带来的性能提升也是微乎其微的，毕竟“查询一下再删除”和“直接删除”的性能差别是很小的。</strong></p>
<h2 id="29-3-数据的批量删除，更新与插入"><a href="#29-3-数据的批量删除，更新与插入" class="headerlink" title="29.3 数据的批量删除，更新与插入"></a>29.3 数据的批量删除，更新与插入</h2><p><strong>数据的批量插入：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student s =<span class="keyword">new</span> Student&#123; Name=<span class="string">&quot;abc&quot;</span> &#125;;</span><br><span class="line">   Student s1 = <span class="keyword">new</span> Student &#123; Name = <span class="string">&quot;ddd&quot;</span> &#125;;</span><br><span class="line">   Student s2 = <span class="keyword">new</span> Student &#123;  Name = <span class="string">&quot;ccc&quot;</span> &#125;;</span><br><span class="line">   ctx.Students.Add(s);</span><br><span class="line">   ctx.Students.Add(s1);</span><br><span class="line">   ctx.Students.Add(s2);</span><br><span class="line">   ctx.SaveChanges();</span><br></pre></td></tr></table></figure>

<p>采用如上的写法会生成3条<code>insert</code>语句。</p>
<p>如果采用如下写法呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student s =<span class="keyword">new</span> Student&#123; Name=<span class="string">&quot;abc&quot;</span> &#125;;</span><br><span class="line">   Student s1 = <span class="keyword">new</span> Student &#123; Name = <span class="string">&quot;ddd&quot;</span> &#125;;</span><br><span class="line">   Student s2 = <span class="keyword">new</span> Student &#123;  Name = <span class="string">&quot;ccc&quot;</span> &#125;;</span><br><span class="line">   <span class="comment">/*  ctx.Students.Add(s);</span></span><br><span class="line"><span class="comment">     ctx.Students.Add(s1);</span></span><br><span class="line"><span class="comment">     ctx.Students.Add(s2);*/</span></span><br><span class="line">   ctx.Students.AddRange(s,s1,s2);</span><br><span class="line">   ctx.SaveChanges();</span><br></pre></td></tr></table></figure>

<p>这里虽然使用了<code>AddRange</code>方法，但是还是会生成3条<code>sql</code>语句，<code>AddRange</code>方法只是简化了<code>Add</code>方法的使用。</p>
<p>如果我们想一次性插入的数据量非常大的话，采用如上的方式性能就比较差了。</p>
<p>怎样解决呢？</p>
<p>我们可以使用<code>ExecuteSqlInterpolatedAsync</code>方法来执行原生的<code>SQL</code>语句。</p>
<p>在原生的<code>sql</code>语句中，有一种批量插入数据性能比较高的实现方式，就是通过 <code>SqlBulkCopy</code>方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://learn.microsoft.com/zh-cn/dotnet/api/system.data.sqlclient.sqlbulkcopy?source=recommendations&amp;view=dotnet-plat-ext-7.0</span><br></pre></td></tr></table></figure>



<p><strong>数据批量更新</strong></p>
<p><code>EF Core 7</code>中提供了批量更新的方法</p>
<p>将编号大于等于10的记录的学生名后面添加一个<code>hello</code>字符串</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="keyword">await</span> ctx.Students.Where(s =&gt; s.Id &gt;= <span class="number">10</span>).ExecuteUpdateAsync(e =&gt; e.SetProperty(a =&gt; a.Name, a =&gt; a.Name + <span class="string">&quot;hello&quot;</span>));</span><br><span class="line">   Console.WriteLine(<span class="string">&quot;count=&quot;</span>+count.Result);</span><br></pre></td></tr></table></figure>

<p>这里是先找到编号大于等于10的记录，然后调用<code>ExecuteUpdateAsync</code>方法，将<code>Name</code>属性的值修改后面添加<code>hello</code>这个字符串。</p>
<p>返回的就是修改数据表所影响的行数。</p>
<p>看一下生成的<code>SQL</code>语句</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE [t]</span><br><span class="line">SET [t].[Name] = [t].[Name] + N<span class="string">&#x27;hello22&#x27;</span></span><br><span class="line">FROM [T_Students] AS [t]</span><br><span class="line">WHERE [t].[Id] &gt;= CAST(<span class="number">10</span> AS bigint)</span><br></pre></td></tr></table></figure>

<p><strong>数据批量删除</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = ctx.Students.Where(s=&gt;s.Id&gt;=<span class="number">10</span>).ExecuteDelete();</span><br><span class="line">    Console.WriteLine(count); </span><br></pre></td></tr></table></figure>

<p>上面的代码删除的是编号大于等于10的学生信息，返回的是影响的行数。</p>
<h2 id="29-4-全局查询筛选器"><a href="#29-4-全局查询筛选器" class="headerlink" title="29.4 全局查询筛选器"></a>29.4 全局查询筛选器</h2><p><code>EF Core</code>支持在配置实体类的时候，为实体类设置全局查询筛选器，<code>EF Core</code>会自动将全局查询筛选器应用于涉及<strong>这个实体类型</strong>的所有<code>Linq</code>查询。</p>
<p>例如：我为<code>Student</code>实体类添加了一个全局查询筛选器，<code> Num &gt; 10</code></p>
<p>当我们写了如下查询的时候，也会在所生成的<code>sql</code>语句中自动添加全局查询筛选器中指定的过滤条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.Students.Where(s=&gt;s.Age = 18)</span><br></pre></td></tr></table></figure>

<p>以上查询生成的<code>sql</code>语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T_Students where AGE = 18 and Num &gt; 10 </span><br></pre></td></tr></table></figure>

<p>这个功能常见的应用场景就是<strong>软删除</strong></p>
<p>基于“可审计性”“数据可恢复性”等需求的考虑，很多系统中数据的删除其实并不是真正的删除，数据其实仍然保存在数据库中，我们只是给数据库表增加一列“是否已删除”。当一行数据需要被删除的时候，我们只是把这条数据的“是否已删除”列的值改为“是”，数据仍然保存在数据库表中没有被删除。当进行数据查询的时候，在查询中我们把“是否已删除”列中为“是”的值过滤掉。这就叫作“软删除”。</p>
<p>在<code>EF Core</code>中，我们可以给对应实体类设置一个全局查询筛选器，这样所有的查询都会自动增加全局查询筛选器，被软删除的数据就会自动从查询结果中过滤掉。下面演示一下。</p>
<p>首先，我们给<code>Student</code>实体类增加一个<code>bool</code>类型的属性<code>IsDeleted</code>，如果对应的数据被标记为已删除，那么<code>IsDeleted</code>的值就是<code>true</code>，否则就是<code>false</code>。(这里在对多多项目中进行演示)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">bool</span> ? IsDeleted &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> List&lt;Teacher&gt; Teachers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;=<span class="keyword">new</span> List&lt;Teacher&gt;() &#123; &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>StudentConfig.cs</code>文件中，指定默认值</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StudentConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Student</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Student&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Students&quot;</span>);</span><br><span class="line">           builder.Property(s=&gt;s.Name).IsRequired().HasMaxLength(<span class="number">20</span>);</span><br><span class="line">           builder.Property(b =&gt; b.IsDeleted).HasDefaultValue(<span class="literal">false</span>); <span class="comment">// 指定了IsDeleted默认值是false</span></span><br><span class="line">           builder.HasMany&lt;Teacher&gt;(s =&gt; s.Teachers).WithMany(s =&gt; s.Students).UsingEntity(a =&gt; a.ToTable(<span class="string">&quot;T_Students_Teachers&quot;</span>));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>执行一下迁数据移操作,注意：在【程序包管理器控制台】中选择【多对多项目】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration IsDeleted</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>这时候在<code>T_Students</code>表中添加了<code>IsDeleted</code> 字段。</p>
<p>下面进行软删除的操作。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> studentInfo = <span class="keyword">await</span> ctx.Students.Where(s=&gt;s.Id==<span class="number">1</span>).FirstOrDefaultAsync();</span><br><span class="line">   <span class="keyword">if</span> (studentInfo != <span class="literal">null</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       studentInfo.IsDeleted = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里就是把编号为1的记录的<code>IsDeleted</code>字段的值设置为<code>true</code>，表示的就是软删除了这条记录。</p>
<p>下面，我们进行查询，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students = ctx.Students;</span><br><span class="line">   <span class="keyword">foreach</span> (<span class="keyword">var</span> student <span class="keyword">in</span> students)</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine(student.Name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里，如果我们如果执行上面的查询，会将已经【软删除】的记录也给查询出来。</p>
<p>如果，我们不想把已经软删除的记录查询出来，可以给定查询的条件，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students = ctx.Students.Where(s=&gt;s.IsDeleted!=<span class="literal">true</span> ); <span class="comment">//这里添加了过滤条件</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> student <span class="keyword">in</span> students)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(student.Name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是每次写这个过滤的条件是比较麻烦的，这里我们可以在<code>StudentConfig.cs</code>这个配置文件中添加如下的配置，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Student&gt; builder</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          builder.ToTable(<span class="string">&quot;T_Students&quot;</span>);</span><br><span class="line">          builder.Property(s=&gt;s.Name).IsRequired().HasMaxLength(<span class="number">20</span>);</span><br><span class="line">          builder.Property(b =&gt; b.IsDeleted).HasDefaultValue(<span class="literal">false</span>);</span><br><span class="line">          builder.HasMany&lt;Teacher&gt;(s =&gt; s.Teachers).WithMany(s =&gt; s.Students).UsingEntity(a =&gt; a.ToTable(<span class="string">&quot;T_Students_Teachers&quot;</span>));</span><br><span class="line">         builder.HasQueryFilter(a=&gt;a.IsDeleted!=<span class="literal">true</span>); <span class="comment">// 添加了该配置项。当然，这里可以根据自己的实际情况，将条件写到的比较复杂。</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们再来看一下如下的查询。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students = ctx.Students;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> student <span class="keyword">in</span> students)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(student.Name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在以上的查询中我们并没有指定过滤的条件，但是这里查询的学生姓名中并不包含已经软删除的记录。</p>
<p>即使我们进行如下的查询，也会添加上以上配置的过滤条件。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students = ctx.Students.Where(s=&gt;s.Name.Contains(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> student <span class="keyword">in</span> students)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(student.Name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们指定的过滤条件是查询一下学生名称中是<code>张</code>姓的学生，虽然数据表中的第一条记录也是满足条件的，但是由于第一条记录已经被软删除了，所以执行上面的查询不会查询出第一个学生。</p>
<p>看一下生成的<code>SQL</code>语句，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT [t].[Id], [t].[IsDeleted], [t].[Name]</span><br><span class="line">FROM [T_Students] AS [t]</span><br><span class="line">      <span class="comment">// &lt;&gt; :表示不等于</span></span><br><span class="line">WHERE ([t].[IsDeleted] &lt;&gt; CAST(<span class="number">1</span> AS bit) OR ([t].[IsDeleted] IS NULL)) AND ([t].[Name] LIKE N<span class="string">&#x27;%张%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到在以上的<code>sql</code>语句中，添加了对已经软删除记录的过滤条件。</p>
<p>这里有一个问题：如果我们想查询出所有已经软删除的记录应该怎样实现呢？</p>
<p>你可能会想到采用如下的查询方式，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students = ctx.Students.Where(s=&gt;s.IsDeleted==<span class="literal">true</span>);</span><br><span class="line">   <span class="keyword">foreach</span> (<span class="keyword">var</span> student <span class="keyword">in</span> students)</span><br><span class="line">   &#123;</span><br><span class="line">       Console.WriteLine(student.Name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码发现没有查询到任何的结果。</p>
<p>查看一下所生成的<code>sql</code>语句，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT [t].[Id], [t].[IsDeleted], [t].[Name]</span><br><span class="line">FROM [T_Students] AS [t]</span><br><span class="line">WHERE ([t].[IsDeleted] &lt;&gt; CAST(<span class="number">1</span> AS bit) OR ([t].[IsDeleted] IS NULL)) AND [t].[IsDeleted] = CAST(<span class="number">1</span> AS bit)</span><br></pre></td></tr></table></figure>

<p>在上面的<code>sql</code>查询条件中，发现查询条件比较奇怪，这里是查询<code>IsDeleted</code>不等于1（1这个了表示的就是true）或者是不等于<code>null</code>，并且<code>IsDeleted</code>等于1.</p>
<p>很明显根据这个条件无法查询出任何的记录。</p>
<p>这时候，我们应该怎样进行处理呢?</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> students = ctx.Students.IgnoreQueryFilters().Where(s=&gt;s.IsDeleted==<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> student <span class="keyword">in</span> students)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(student.Name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的查询中我们使用了<code>IgnoreQueryFilters</code>这个方法，该方法的作用就是在进行查询的时候，忽略掉全局过滤筛选。</p>
<p>运行上面的程序，发现能够查询出已经软删除的记录数据。</p>
<p>可以看一下所生成的<code>sql</code>语句，发现全局查询筛选器中的过滤条件并没有添加。</p>
<p>当然，这里仅仅是在当前所指定的查询中忽略掉了全局查询筛选器。如果在别的针对当前<code>Student</code>实体类的查询中还是会添加全局查询筛选器。</p>
<p>注意:由于这里针对<code>Student</code>实体类查询过滤的时候，都会自动带上我们所添加的全局查询筛选器，所以可以考虑给<code>IsDeleted</code>添加索引，来提升查询的效率。当然，这里一定是在出现了性能问题的时候，才考虑添加索引。</p>
<h2 id="29-5-悲观并发控制"><a href="#29-5-悲观并发控制" class="headerlink" title="29.5  悲观并发控制"></a>29.5  悲观并发控制</h2><p>什么是并发问题？</p>
<p>先来看一个问题：统计文章的点赞量。</p>
<p>并发控制指的就是避免多个用户同时操作资源造成的并发冲突的问题。</p>
<p>当然，解决并发问题的最好解决方案，是通过非数据库解决方案，性能高。例如通过<code>redis</code>队列，操作内存</p>
<p>在数据库中解决并发问题也是可以的，但是相对来讲性能低，因为必进是磁盘<code>IO</code></p>
<p>这里，我们先讲解数据库层面怎样解决并发问题，关于数据库层面有两种策略，分别是悲观策略与乐观策略。</p>
<p>悲观并发控制一般采用行锁、表锁等排他锁对资源进行锁定，确保同时只有一个使用者操作被锁定的资源</p>
<p>因为不同类型的数据库对于悲观并发控制的实现差异很大，所以<code>EF Core</code>没有封装悲观并发控制，<strong>需要开发人员编写原生<code>SQL</code>语句</strong></p>
<p>下面我们演示一下：</p>
<p>创建一个<code>悲观并发控制</code>控制台项目</p>
<p>安装<code>EFCore</code>操作数据库对应的包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">		&lt;PackageReference Include=<span class="string">&quot;Microsoft.EntityFrameworkCore.SqlServer&quot;</span> Version=<span class="string">&quot;7.0.3&quot;</span> /&gt;</span><br><span class="line">		&lt;PackageReference Include=<span class="string">&quot;Microsoft.EntityFrameworkCore.Tools&quot;</span> Version=<span class="string">&quot;7.0.3&quot;</span>&gt;</span><br><span class="line">			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;</span><br><span class="line">			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;</span><br><span class="line">		&lt;/PackageReference&gt;</span><br><span class="line">	&lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure>

<p>创建一个<code>House.cs</code>实体类，代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">House</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 房子主人</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Owner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个<code>HouseConfig.cs</code>文件，代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HouseConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">House</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;House&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           builder.ToTable(<span class="string">&quot;T_Houses&quot;</span>);</span><br><span class="line">           builder.Property(a=&gt;a.Name).IsRequired();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>创建<code>MyDbContext.cs</code>，代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;House&gt; Houses &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnConfiguring(optionsBuilder);</span><br><span class="line">            <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=TestDB2;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">            optionsBuilder.UseSqlServer(connStr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行数据库的迁移操作</p>
<p>在<code>[程序包管理器控制台]</code>中选择对应的控制台项目，执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration Init</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>然后在数据表中，录入测试数据。</p>
<p>下面实现代码，在<code>Program.cs</code>文件中添加如下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;请输入你的名字&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> name =Console.ReadLine();</span><br><span class="line"><span class="keyword">using</span> (MyDbContext myDbContext = <span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> h = myDbContext.Houses.FirstOrDefault(h=&gt;h.Id==<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(h.Owner))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h.Owner == name)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;房子已经被您抢到了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;房子已经被【&quot;</span> + h.Owner + <span class="string">&quot;】抢走了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里为了演示并发问题，让程序暂停5秒钟</span></span><br><span class="line">        <span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">        h.Owner = name;</span><br><span class="line">        myDbContext.SaveChanges();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;恭喜您，抢到房子了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;没有这套房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们找到<code>bin</code>目录，直接执行对应的<code>exe</code>程序，开启两个窗口，模拟两个用户抢房子（在这之前，一定要将项目重新生成一下）</p>
<p>在第-一个窗口中输入<code>zhangsan</code>(不要敲回车键)，在另外一个窗口中输入<code>lisi</code>，然后再返回到第一个窗口中按下回车键，同时在第二个窗口中也按下回车键，在等待了一段时间后，两个窗口都会显示用户抢到了房子，而在数据库中，存储的只是<code>lisi</code>。这就是并发冲突的问题。</p>
<p>下面看一下具体的解决</p>
<p><code>KilgourNote:悲观并发控制的本质就是给需要改变的字段加锁，以保证每一次访问都是最新的数据              也就是使用事务给数据库字段加锁以达到目的              transaction-事务</code></p>
<p>下面的代码就是悲观并发控制的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;请输入你的名字&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> name =Console.ReadLine();</span><br><span class="line"><span class="keyword">using</span> (MyDbContext myDbContext = <span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ---开启事务</span></span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> tx = <span class="keyword">await</span> myDbContext.Database.BeginTransactionAsync())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ----UPDLOCK：更新锁定,如果有其他的查询操作，那些查询就会被挂起，直到针对这条数据的更新操作完成，从而释放这个锁，那些被挂起的代码才会继续执行。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//var h = myDbContext.Houses.FirstOrDefault(h =&gt; h.Id == 1);</span></span><br><span class="line">        <span class="keyword">var</span> h = <span class="keyword">await</span> myDbContext.Houses.FromSqlInterpolated(<span class="string">$&quot;SELECT * FROM T_Houses WITH (UPDLOCK) WHERE id = 1 &quot;</span>).FirstOrDefaultAsync();</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">string</span>.IsNullOrEmpty(h.Owner))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (h.Owner == name)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;房子已经被您抢到了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;房子已经被【&quot;</span> + h.Owner + <span class="string">&quot;】抢走了&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.ReadKey();<span class="comment">// ----暂停</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">            h.Owner = name;</span><br><span class="line">            myDbContext.SaveChanges();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;恭喜您，抢到房子了&quot;</span>);</span><br><span class="line">            <span class="keyword">await</span> tx.CommitAsync(); <span class="comment">// ------提交事务</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;没有这套房子&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>悲观并发控制的使用比较简单，只要对要进行并发控制的资源加上锁即可。但是这种锁是独占排他的，如果系统并发量很大，锁会严重影响性能(一个操作加锁，其他操作都需要等待)，如果使用不当，甚至会导致死锁。因此，对于高并发系统，要尽量优化算法，比如调整逻辑或者使用<code>NoSQL</code>等，尽量避免通过关系数据库进行并发控制。如果必须使用数据库进行并发控制，尽量采用乐观并发控制。</p>
<h2 id="29-6-乐观并发控制"><a href="#29-6-乐观并发控制" class="headerlink" title="29.6 乐观并发控制"></a>29.6 乐观并发控制</h2><p>以<code>T_Houses</code>表为例，由于可能有多个操作者并发修改<code>Owner</code>列</p>
<p>在更新<code>Owner</code>列的时候，我们把Owner列更新前的值也放入Update语句的条件中，<code>SQL</code>语句如下：<code>Update T_Houses set Owner=新值 where Id=1 and Owner=旧值</code>。</p>
<p>如下示例代码：</p>
<p> RowVer &#x3D; 0x00000000000007D6</p>
<p>update T_Houses set Owner&#x3D;’zhangsan’ where Id&#x3D;1 and  RowVer &#x3D; 0x00000000000007D7</p>
<p>Update T_Houses set Owner&#x3D;’lisi’ where Id&#x3D;1 and RowVer &#x3D;”0x00000000000007D6” </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update T_Houses <span class="built_in">set</span> Owner=<span class="string">&#x27;zhangsan&#x27;</span> <span class="built_in">where</span> Id=1 and Owner=<span class="string">&quot;&quot;</span> //影响一行 </span><br></pre></td></tr></table></figure>

<p>即使并发，在某个时间点上只有一个用户进行更新，例如<code>zhangsan</code>抢到了房间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Update T_Houses <span class="built_in">set</span> Owner=<span class="string">&#x27;lisi&#x27;</span> <span class="built_in">where</span> Id=1 and Owner=<span class="string">&quot;&quot;</span> // 影响0行数</span><br></pre></td></tr></table></figure>

<p><code>lisi</code>去抢房子的时候，<code>Owner</code>的值已经不是空了，而是<code>zhangsan</code>，所以并发修改失败。</p>
<p>以上就是乐观并发控制的实现原理。</p>
<p>通过上面所举的例子，我们可以看到<code>Owner</code>这个列是被并发操作影响的列，所以这个列我们也可以称作<strong>并发令牌列</strong>。</p>
<p>也就是说，并发令牌列通常就是被并发操作影响的列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：这样，当执行Update语句的时候，如果数据库中的Owner值已经被其他操作者更新，那么where语句的值就会为false。因此这条Update语句影响的行数就是0，EF Core就知道“发生并发冲突了”，此时SaveChanges方法就会抛出DbUpdateConcurrencyException异常。</span><br></pre></td></tr></table></figure>



<p>问题：怎样将<code>Owner</code> 这个列设置为并发令牌呢？</p>
<p><code>EF Core</code>中，我们只要把被并发修改的属性使用<code>IsConcurrencyToken</code>设置为并发令牌即可</p>
<p>下面演示</p>
<p>新创建一个控制台项目，安装<code>EFCore</code>操作数据库所需要的包</p>
<p>同时，将拷贝上一个控制台项目中的文件</p>
<p>修改<code>HouseConfig.cs</code>文件</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 乐观并发控制 <span class="comment">// 修改了命名控制</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HouseConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">House</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;House&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Houses&quot;</span>);</span><br><span class="line">            builder.Property(a=&gt;a.Name).IsRequired();</span><br><span class="line">            builder.Property(a =&gt; a.Owner).IsConcurrencyToken(); <span class="comment">// 通过IsConcurrencyToken设置Owner是并发令牌</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>MyDbContext.cs</code>修改一下命名空间。</p>
<p><code>House.cs</code>修改一下命名空间。</p>
<p><code>Program.cs</code>文件中的代码(以下代码，是根据最开始的代码进行改造的)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"><span class="keyword">using</span> 乐观并发控制;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (MyDbContext mc = <span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/悲观并发控制的本质就是给需要改变的字段加锁，以保证每一次访问都是最新的数据</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/也就是使用事务给数据库字段加锁以达到目的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/transaction-事务</span></span><br><span class="line">    <span class="comment">//Console.WriteLine(&quot;请输入你的名字&quot;);</span></span><br><span class="line">    <span class="comment">//string name = Console.ReadLine()!;</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/开始事务以达到加锁的目的</span></span><br><span class="line">    <span class="comment">//using(var transcation = await mc.Database.BeginTransactionAsync())</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    //开启事务以后从数据库中找到一条房间数据</span></span><br><span class="line">    <span class="comment">//    var h = await mc.houses.FromSqlInterpolated($&quot;select * from T_House with (updlock) where id = 2&quot;).FirstOrDefaultAsync();</span></span><br><span class="line">    <span class="comment">//    // with (updlock)更新锁：在读取数据的时候申请一个锁以防止其他事务修改这些数据</span></span><br><span class="line">    <span class="comment">//    if( h != null)</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        if (string.IsNullOrEmpty(h.Owner))</span></span><br><span class="line">    <span class="comment">//        &#123;</span></span><br><span class="line">    <span class="comment">//            await Task.Delay(3000);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//            h.Owner = name;</span></span><br><span class="line">    <span class="comment">//            await mc.SaveChangesAsync();</span></span><br><span class="line">    <span class="comment">//            Console.WriteLine($&quot;&#123;h.Owner&#125;!恭喜你已经抢到了房间号为&#123;h.RoomName&#125;的房间&quot;);</span></span><br><span class="line">    <span class="comment">//            await transcation.CommitAsync();//提交事务解放锁</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//        else</span></span><br><span class="line">    <span class="comment">//        &#123;</span></span><br><span class="line">    <span class="comment">//            if(h.Owner == name)</span></span><br><span class="line">    <span class="comment">//            &#123;</span></span><br><span class="line">    <span class="comment">//                Console.WriteLine(&quot;这间房子已经是你的了&quot;);</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//            else</span></span><br><span class="line">    <span class="comment">//            &#123;</span></span><br><span class="line">    <span class="comment">//                Console.WriteLine($&quot;这间房子已经被&#123;h.Owner&#125;抢到了&quot;);</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    else</span></span><br><span class="line">    <span class="comment">//    &#123;</span></span><br><span class="line">    <span class="comment">//        Console.WriteLine($&quot;不好意思没有该房间&quot;);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    Console.ReadKey();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//乐观并发控制</span></span><br><span class="line">    <span class="comment">//使用并发令牌控制(ConcurrencyToken),不使用事务（一般用这个而不用悲观）</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;请输入你的名字&quot;</span>);</span><br><span class="line">    <span class="built_in">string</span> name = Console.ReadLine()!;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> h = <span class="keyword">await</span> mc.houses.Where(a =&gt; a.Id == <span class="number">1</span>).FirstOrDefaultAsync();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(h.Owner))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                h.Owner = name;</span><br><span class="line">                <span class="keyword">await</span> mc.SaveChangesAsync();<span class="comment">//这是因为并发冲突的检测是在尝试将更改保存到数据库时进行的。因此运行到该行的时候会导致异常</span></span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;h.Owner&#125;</span>!恭喜你已经抢到了房间号为<span class="subst">&#123;h.RoomName&#125;</span>的房间&quot;</span>);</span><br><span class="line">                <span class="comment">//await transcation.CommitAsync();//提交事务解放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (DbUpdateConcurrencyException ex)<span class="comment">//在更新数据时遇到</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//foreach (var entry in ex.Entries)</span></span><br><span class="line">                <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//    Console.WriteLine(entry.ToString()); // 或者使用其他方法打印信息</span></span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">                <span class="comment">//Console.WriteLine(&quot;-----------------------&quot;);</span></span><br><span class="line">                <span class="keyword">var</span> message = ex.Entries.FirstOrDefault();<span class="comment">//获取导致异常的实体条目</span></span><br><span class="line">                <span class="comment">//Console.WriteLine(message.ToString());//House &#123;Id: 1&#125; Modified</span></span><br><span class="line">                <span class="comment">//await Task.Delay(40000);</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">var</span> <span class="keyword">value</span> = message.GetDatabaseValues()!.GetValue&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Owner&quot;</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * message.GetDatabaseValues() 方法从数据库中获取该实体的最新值，并返回一个 PropertyValues 对象。</span></span><br><span class="line"><span class="comment">                   GetValue&lt;string&gt;(&quot;Ower&quot;) 方法从 PropertyValues 对象中获取名为 Ower 的属性的值，并将其转换为string。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;房间已经被<span class="subst">&#123;<span class="keyword">value</span>&#125;</span>抢走了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//finally</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h.Owner == name)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;这间房子已经是你的了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;这间房子已经被<span class="subst">&#123;h.Owner&#125;</span>抢到了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;不好意思没有该房间&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>KilkgourNote:</code></p>
<blockquote>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><p>以下是这两行代码的逐步解释：</p>
<ol>
<li><strong><code>var message = ex.Entries.First();</code></strong><ul>
<li>这里，<code>ex.Entries</code> 是一个 <code>IReadOnlyList&lt;EntityEntry&gt;</code>，包含所有导致并发冲突的实体条目。</li>
<li><code>First()</code> 方法返回列表中的第一个条目，这个条目是一个 <code>EntityEntry</code> 对象，表示发生并发冲突的实体。</li>
</ul>
</li>
<li><strong><code>var value = message.GetDatabaseValues()!.GetValue&lt;string&gt;(&quot;Ower&quot;);</code></strong><ul>
<li><code>message.GetDatabaseValues()</code> 方法从数据库中获取该实体的最新值，并返回一个 <code>PropertyValues</code> 对象。</li>
<li><code>GetValue&lt;string&gt;(&quot;Ower&quot;)</code> 方法从 <code>PropertyValues</code> 对象中获取名为 <code>Ower</code> 的属性的值，并将其转换为 <code>string</code>。</li>
</ul>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>这种处理方法在并发冲突的情况下非常有用，例如多个用户同时尝试更新同一个记录时：</p>
<ul>
<li>用户 A 读取记录，开始编辑。</li>
<li>用户 B 读取相同的记录，开始编辑。</li>
<li>用户 A 保存更改，这会成功。</li>
<li>用户 B 尝试保存更改，但因为用户 A 已经修改了记录，导致并发冲突。</li>
</ul>
<p>在用户 B 捕获到 <code>DbUpdateConcurrencyException</code> 后，可以通过 <code>GetDatabaseValues()</code> 获取数据库中的最新值，并决定如何处理冲突，例如通知用户冲突情况或重新加载数据。</p>
</blockquote>
<p>总结：乐观并发控制则允许多个使用者同时操作同一个资源，通过冲突的检测避免并发操作。</p>
<p>和悲观并发控制的代码相比，乐观并发控制不需要显式地使用事务，而且不需要使用数据库锁，我们只要捕捉保存更改时候的<code>DbUpdateConcurrencyException</code>异常即可。我们可以通过<code>DbUpdateConcurrencyException</code>类的<code>Entries</code>属性获取发生并发修改冲突的<code>EntityEntry</code>对象，并且通过<code>EntityEntry</code>类的<code>GetDatabaseValuesAsync</code>获取当前数据库的值.</p>
<p>注意：以上操作不需要数据库迁移</p>
<h2 id="29-7-乐观并发控制2"><a href="#29-7-乐观并发控制2" class="headerlink" title="29.7 乐观并发控制2"></a>29.7 乐观并发控制2</h2><p>我们可以通过把并发修改的属性设置为并发令牌的方式启用乐观并发控制。但是有时候我们无法确定到底哪个属性适合作为并发令牌，比如<strong>程序在不同的情况下会更新不同的列或者程序会更新多个列</strong>，在这种情况下，<strong>我们可以使用设置一个额外的并发令牌属性的方式来使用乐观并发控制。</strong></p>
<p>如果使用<code>Microsoft SQL Server</code>数据库，我们可以用一个<code>byte[]</code>类型的属性作为并发令牌属性，然后使用<code>IsRowVersion</code>把这个属性设置为<code>RowVersion</code>类型，这个属性对应的数据库列就会被设置为<code>ROWVERSION</code>类型。对于<code>ROWVERSION</code>类型的列，在每次插入或更新行时，<code>Microsoft SQL Server</code>会自动为这一行的<code>ROWVERSION</code>类型的列生成新值(只要更新这一行中的任意字段的值，<code>ROWVERSION</code>类型的列就会生成新的值)。</p>
<p>下面演示如何在<code>Microsoft SQL Server</code>中通过额外的<code>ROWVERSION</code>类型列进行乐观并发控制。首先，我们定义包含一个<code>byte[]</code>类型属性的<code>House</code>类</p>
<p>这里我们直接在上一小节创建的控制台项目中进行修改。</p>
<p>修改<code>House.cs</code>中的代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 乐观并发控制</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">House</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 房子主人</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Owner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">byte</span>[] RowVer &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面，我们对<code>House</code>实体类进行配置，对<code>RowVer</code>属性设置<code>IsRowVersion</code></p>
<p>修改<code>HouseConfig.cs</code>中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 乐观并发控制</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HouseConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">House</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;House&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Houses&quot;</span>);</span><br><span class="line">            builder.Property(a=&gt;a.Name).IsRequired();</span><br><span class="line">            <span class="comment">//  builder.Property(a =&gt; a.Owner).IsConcurrencyToken(); // 这行不需要了</span></span><br><span class="line">			<span class="comment">// -----这里给`RowVer`属性设置`IsRowVersion`</span></span><br><span class="line">            builder.Property(a =&gt; a.RowVer).IsRowVersion();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面执行数据库的迁移，这里为了方便测试，我们重新创建一个新的数据库。</p>
<p><strong>所以修改一下<code>MyDbContext.cs</code>中的数据库连接字符串</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration Init2</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>数据库迁移完成以后，打开数据库表的结构，查看<code>RowVer</code>字段类型，发现是<code>timestamp</code> 类型。</p>
<p>在<code>SQL Server</code>中，<code>timestamp</code>和<code>rowversion</code>是同一种类型的不同别名，效果是一样的，那就是每次对一行数据进行更新的时候，<code>timestamp</code>列的值都会自动更新（数据库来进行维护），因此<code>timestamp</code>列是一个非常好的并发令牌列。</p>
<p>这里可以在<code>SQLSERVER</code>中进行演示，看一下每次修改一个字段的值，<code>RowVer</code>字段的值是否发生变化。</p>
<p>注意：<code>Program.cs</code>文件中的代码不需要修改，与上一小节的代码是一样的。</p>
<p>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">乐观并发控制能够避免悲观锁带来的性能下降、死锁等问题，因此推荐使用乐观并发控制而不是悲观锁。如果有一个确定的字段要被进行并发控制，使用IsConcurrencyToken把这个字段设置为并发令牌即可；如果无法确定唯一的并发令牌列，可以引入一个额外的属性并将其设置为并发令牌，并且在每次更新数据的时候，手动更新这一列的值；当然，如果用的是Microsoft SQL Server数据库，我们也可以采用RowVersion列，这样就不用开发人员手动更新并发令牌列的值了（数据库来进行维护）。</span><br></pre></td></tr></table></figure>

<h1 id="30、表达式树"><a href="#30、表达式树" class="headerlink" title="30、表达式树"></a>30、表达式树</h1><h2 id="30-1-什么是表达式树"><a href="#30-1-什么是表达式树" class="headerlink" title="30.1  什么是表达式树"></a>30.1  什么是表达式树</h2><p>表达式树（<code>expression tree</code>）是用树形数据结构来表示代码逻辑运算的技术，它让我们可以在运行时访问逻辑运算的结构。表达式树在.NET中对应<code>Expression&lt;TDelegate&gt;</code>类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;Book,<span class="built_in">bool</span>&gt;&gt; el = b =&gt;b.Price &gt; <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>编译器在分析上面的表达式的时候，会分析出上面是一个比较的运算。然后构成如下的表达式树</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202406242057730.png" alt="3"></p>
<p>下面在对上图中的表达式树进行遍历（深度遍历），从而构成对应的<code>SQL</code>语句。</p>
<p>在<code>Program.cs</code>中查看一下</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;Book,<span class="built_in">bool</span>&gt;&gt; el =b.Price &gt;<span class="number">5</span></span><br><span class="line"> <span class="keyword">using</span>(MyDbContext ctx = <span class="keyword">new</span> MyDbContext)&#123;</span><br><span class="line">    <span class="comment">// 给这行打上断点，查看`el`变量的值</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>如果采用如下的写法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;Book,<span class="built_in">bool</span>&gt; el =b.Price &gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>语法上没有任何问题，但是并不会生成表达式树。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Expression&lt;Func&lt;Book,<span class="built_in">bool</span>&gt;&gt; el =b.Price &gt;<span class="number">5</span></span><br><span class="line">Func&lt;Book,<span class="built_in">bool</span>&gt; f1 =b.Price &gt;<span class="number">5</span>    </span><br><span class="line"> <span class="keyword">using</span>(MyDbContext ctx = <span class="keyword">new</span> MyDbContext)&#123;</span><br><span class="line"> <span class="comment">//    ctx.Books.Where(el).ToList();// 会生成带有条件的SQL语句。调用ToList方法的目的就是立即执行</span></span><br><span class="line">    ctx.Books.Where(f1).ToList() <span class="comment">// 通过查看生成的SQL语句，可以看到，没有构建具有查询条件的SQL语句，而是直接把所有的数据查询出来放入到内存中。</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>总结：<code>Expression</code>对象存储了运算逻辑，它把运算逻辑保存成抽象语法树（<code>AST</code>），可以在运行时动态获取运算逻辑，而普通委托则没有。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.kilgour.top">kilgour</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.kilgour.top/2024/06/23/%E8%80%81%E7%8E%8B-5%E3%80%81Entity-Framework-Core/">http://www.kilgour.top/2024/06/23/%E8%80%81%E7%8E%8B-5%E3%80%81Entity-Framework-Core/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.kilgour.top" target="_blank">Kilgour Notes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover9.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/26/%E8%80%81%E7%8E%8B-6%E3%80%81HTML/" title="HTML"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTML</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/21/%E8%80%81%E7%8E%8B-4%E3%80%81%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" title="日志系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">日志系统</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kilgour</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kilg0ur"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Entity-Framework-Core"><span class="toc-number">1.</span> <span class="toc-text">Entity Framework Core</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFORM"><span class="toc-number">2.</span> <span class="toc-text">1、什么是ORM?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%BC%80%E5%8F%91%E6%80%9D%E6%83%B3%E7%9A%84%E8%BD%AC%E5%8F%98"><span class="toc-number">2.1.</span> <span class="toc-text">1.1   开发思想的转变</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81EF-Core%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">2、EF Core性能问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81EF-Core%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">3、EF Core基本使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81EF-Core%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A82"><span class="toc-number">5.</span> <span class="toc-text">4、EF Core基本使用2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81EF-Core%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A83"><span class="toc-number">6.</span> <span class="toc-text">5、EF Core基本使用3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81EF-Core%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">7.</span> <span class="toc-text">6、EF Core数据的增删改查</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">7.1.</span> <span class="toc-text">6.1  数据的插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 数据查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 修改和删除数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E5%AE%9E%E4%BD%93%E7%B1%BB%E9%85%8D%E7%BD%AE"><span class="toc-number">8.</span> <span class="toc-text">7、实体类配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%A7%84%E5%88%99%E8%AF%B4%E6%98%8E"><span class="toc-number">8.1.</span> <span class="toc-text">7.1  规则说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Data-Annotation"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 Data Annotation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Fluent-API%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 Fluent API基本配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">8、数据库迁移原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB%E5%91%BD%E4%BB%A4"><span class="toc-number">10.</span> <span class="toc-text">9、其他数据库迁移命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81%E5%8F%8D%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">10、反向工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81%E6%9F%A5%E7%9C%8BEF-Core%E7%94%9F%E6%88%90%E7%9A%84SQL%E8%AF%AD%E5%8F%A5"><span class="toc-number">12.</span> <span class="toc-text">11、查看EF Core生成的SQL语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB%E9%85%8D%E7%BD%AE"><span class="toc-number">13.</span> <span class="toc-text">12、一对多关系配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">14.</span> <span class="toc-text">13、关联数据的获取</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81%E9%A2%9D%E5%A4%96%E8%AE%BE%E7%BD%AE%E5%A4%96%E9%94%AE%E5%AD%97%E6%AE%B5"><span class="toc-number">15.</span> <span class="toc-text">14、额外设置外键字段</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E3%80%81%E5%8D%95%E5%90%91%E5%AF%BC%E8%88%AA%E5%B1%9E%E6%80%A7"><span class="toc-number">16.</span> <span class="toc-text">15、单向导航属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16%E3%80%81%E5%85%B3%E7%B3%BB%E9%85%8D%E7%BD%AE%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD"><span class="toc-number">17.</span> <span class="toc-text">16、关系配置在哪个实体类中</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E3%80%81%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB%E9%85%8D%E7%BD%AE"><span class="toc-number">18.</span> <span class="toc-text">18、一对一关系配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19%E3%80%81%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-number">19.</span> <span class="toc-text">19、多对多</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20%E3%80%81%E5%9F%BA%E4%BA%8E%E5%85%B3%E7%B3%BB%E7%9A%84%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2"><span class="toc-number">20.</span> <span class="toc-text">20、基于关系的复杂查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21%E3%80%81IEnumerable%E4%B8%8EIQueryable"><span class="toc-number">21.</span> <span class="toc-text">21、IEnumerable与IQueryable</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22%E3%80%81IQueryable%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C"><span class="toc-number">22.</span> <span class="toc-text">22、IQueryable延迟执行</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23%E3%80%81IQueryable%E5%A4%8D%E7%94%A8%E6%80%A7"><span class="toc-number">23.</span> <span class="toc-text">23、IQueryable复用性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24%E3%80%81%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2"><span class="toc-number">24.</span> <span class="toc-text">24、分页查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25%E3%80%81IQueryable%E5%BA%95%E5%B1%82%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">25.</span> <span class="toc-text">25、IQueryable底层运行机制*</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#26%E3%80%81EF-Core%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">26.</span> <span class="toc-text">26、EF Core中的异步方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#27%E3%80%81EF-Core%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%94%9FSQL%E8%AF%AD%E5%8F%A5"><span class="toc-number">27.</span> <span class="toc-text">27、EF Core如何执行原生SQL语句</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#27-1-%E6%89%A7%E8%A1%8CSQL%E9%9D%9E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-number">27.1.</span> <span class="toc-text">27.1  执行SQL非查询语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-2-%E6%89%A7%E8%A1%8C%E5%AE%9E%E4%BD%93%E7%B1%BBSQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-number">27.2.</span> <span class="toc-text">27.2 执行实体类SQL查询语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-3-%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8FSQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5"><span class="toc-number">27.3.</span> <span class="toc-text">27.3 执行任意SQL查询语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#28%E3%80%81%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%8F%98%E5%8C%96%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">28.</span> <span class="toc-text">28、实体类变化的检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#29%E3%80%81EF-Core%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">29.</span> <span class="toc-text">29、EF Core性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#29-1-EF-Core-%E4%BC%98%E5%8C%96%E4%B9%8B-AsNoTracking"><span class="toc-number">29.1.</span> <span class="toc-text">29.1 EF Core 优化之 AsNoTracking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-2-%E5%AE%9E%E4%BD%93%E7%8A%B6%E6%80%81%E8%B7%9F%E8%B8%AA%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-number">29.2.</span> <span class="toc-text">29.2 实体状态跟踪的妙用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-3-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%EF%BC%8C%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%8F%92%E5%85%A5"><span class="toc-number">29.3.</span> <span class="toc-text">29.3 数据的批量删除，更新与插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-4-%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E7%AD%9B%E9%80%89%E5%99%A8"><span class="toc-number">29.4.</span> <span class="toc-text">29.4 全局查询筛选器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-5-%E6%82%B2%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">29.5.</span> <span class="toc-text">29.5  悲观并发控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-6-%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">29.6.</span> <span class="toc-text">29.6 乐观并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">29.6.1.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">29.6.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-7-%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B62"><span class="toc-number">29.7.</span> <span class="toc-text">29.7 乐观并发控制2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#30%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="toc-number">30.</span> <span class="toc-text">30、表达式树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#30-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="toc-number">30.1.</span> <span class="toc-text">30.1  什么是表达式树</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By kilgour</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">2</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>