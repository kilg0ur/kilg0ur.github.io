<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kilgour Notes | Kilgour Notes</title><meta name="author" content="kilgour"><meta name="copyright" content="kilgour"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="DDD1、架构设计1.1  架构设计的问题和具体的代码编写不同，架构设计存在一定的主观因素，而且因行业、公司、团队的不同而不同，并没有哪个架构设计是绝对对的或错的，没有最好的架构，只有最适合的架构。但是不少技术人员在架构设计上容易犯“迷信大公司”“迷信流行技术”等错误。 有的人员在进行架构设计的时候，会说“某某大公司采用这样的架构”，言下之意就是“大公司都这样做，我们这样做肯定没错”，但是他并不了">
<meta property="og:type" content="article">
<meta property="og:title" content="Kilgour Notes">
<meta property="og:url" content="http://www.kilgour.top/2024/09/03/%E8%80%81%E7%8E%8B-24%E3%80%81DDD/index.html">
<meta property="og:site_name" content="Kilgour Notes">
<meta property="og:description" content="DDD1、架构设计1.1  架构设计的问题和具体的代码编写不同，架构设计存在一定的主观因素，而且因行业、公司、团队的不同而不同，并没有哪个架构设计是绝对对的或错的，没有最好的架构，只有最适合的架构。但是不少技术人员在架构设计上容易犯“迷信大公司”“迷信流行技术”等错误。 有的人员在进行架构设计的时候，会说“某某大公司采用这样的架构”，言下之意就是“大公司都这样做，我们这样做肯定没错”，但是他并不了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover8.jpg">
<meta property="article:published_time" content="2024-09-03T07:36:34.035Z">
<meta property="article:modified_time" content="2024-09-04T07:17:55.824Z">
<meta property="article:author" content="kilgour">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover8.jpg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/logo.png"><link rel="canonical" href="http://www.kilgour.top/2024/09/03/%E8%80%81%E7%8E%8B-24%E3%80%81DDD/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kilgour Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-04 15:17:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/panarama.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover8.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Kilgour Notes"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/logo.png"/><span class="site-name">Kilgour Notes</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-03T07:36:34.035Z" title="发表于 2024-09-03 15:36:34">2024-09-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-04T07:17:55.824Z" title="更新于 2024-09-04 15:17:55">2024-09-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>113分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a><code>DDD</code></h1><h1 id="1、架构设计"><a href="#1、架构设计" class="headerlink" title="1、架构设计"></a>1、架构设计</h1><h2 id="1-1-架构设计的问题"><a href="#1-1-架构设计的问题" class="headerlink" title="1.1  架构设计的问题"></a>1.1  架构设计的问题</h2><p>和具体的代码编写不同，架构设计存在一定的主观因素，而且因行业、公司、团队的不同而不同，并没有哪个架构设计是绝对对的或错的，没有最好的架构，只有最适合的架构。但是不少技术人员在架构设计上容易犯“迷信大公司”“迷信流行技术”等错误。</p>
<p>有的人员在进行架构设计的时候，会说“某某大公司采用这样的架构”，言下之意就是“大公司都这样做，我们这样做肯定没错”，但是他并不了解那个大公司为什么采用这样的架构，自己所在的项目是否适合这样的架构</p>
<p>IT行业的发展瞬息万变，新技术层出不穷，很多技术人员出于个人兴趣、个人职业发展等考虑而选择一些流行的新技术，他们会把各种复杂的架构模式、高精尖的技术都加入架构中，这增加了项目的复杂度、延长了交付周期、增加了项目的研发成本。有些技术并不符合公司的情况，最后项目失败了，某些技术人员就拿着“精通某某流行技术”的简历去找下家了，给公司留下一地鸡毛。</p>
<p>因此，我们做架构设计的时候，一定要分析行业情况、公司情况、公司未来发展、项目情况、团队情况等来设计适合自己的架构，不能盲目跟风。</p>
<h2 id="1-2-架构是进化而来的"><a href="#1-2-架构是进化而来的" class="headerlink" title="1.2 架构是进化而来的"></a>1.2 架构是进化而来的</h2><p>罗马不是一天建成的，大公司的复杂架构也不是一蹴而就的，而是从简单到复杂演变、进化而来的。以淘宝网为例，它的第一个版本是几名开发人员用了一个月时间基于一个<code>PHP</code>（page hypertext preprocessor，页面超文本预处理器）版拍卖网站改造的，上线的时候淘宝网只有一台Web服务器和一台数据库服务器。在淘宝网近20年的发展中，随着网站访问量越来越大、功能越来越多，淘宝网才逐渐进化到现在这样复杂的架构。而现在很多网站在开发第一版的时候就以“上亿人访问，百万并发量”为架构设计目标，导致项目迟迟无法交付、研发成本高昂，好不容易网站开发完成了，但是由于项目交付延迟，公司已经错过了绝佳的市场机会，上线后才几千个注册用户，最后网站无疾而终。</p>
<p>按照“精益创业”的理念，我们应该用最低的成本、最短的时间开发出一个“最小的可行性产品”，然后把产品投入市场，根据市场的反馈再进行产品的升级。这里并不是让大家开发一个新产品的时候，也像淘宝网一样写普通的<code>PHP</code>代码、部署到普通服务器上。经过IT行业的发展，我们现在已经可以用非常低的成本、在很短的时间内构建一个可承担较大访问量的高可用系统。我们只要基于成熟的技术进行开发，并且对项目未来较短一段时间内的发展进行预测，在项目架构上做必要的准备就可以了，没必要“想得太长远”。架构设计在满足必要的可扩展性、隔离性的基础上，要尽可能简单。</p>
<p>一个优秀的架构不应该是初期版本简单、升级过程中经常需要推倒重来的，而是要从简单开始，并且可以顺滑地持续升级。也就是架构最开始的版本很简单，但是为后续的进化、升级做好了准备，以便后续可以完美地升级架构。这样可以持续升级的架构，叫作“演进式架构”。设计一个优秀的演进式架构比设计一个大而全的架构对架构设计人员的要求更高。</p>
<p>.NET是一个可以很好地支撑演进式架构的技术平台。在前期网站访问量低、没有专业运维人员的情况下，我们可以把用.NET开发的程序部署到单机Windows服务器上，随着网站规模的扩大，我们可以在不修改代码的情况下，把程序迁移到Linux+Docker的环境下；在网站访问量低的时候，我们可以用内存作为缓存，随着网站访问量的增大，我们可以切换为使用<code>Redis</code>作为缓存；.NET的依赖注入让我们可以替换服务的实现类，而不需要修改服务消费者的代码。</p>
<p>一个好的软件架构应该是可以防止软件退化的。软件退化指的是在软件升级的时候，随着功能的增加和系统复杂度的提升，代码的质量越来越差，系统的稳定性和可维护性等指标越来越差。一个退化中的软件的明显特征就是：软件的第一个版本是代码质量最高的版本，之后的版本中代码质量越来越差。软件的需求是不断变更的，软件的升级也是必然的，因此我们应该在进行架构设计的时候避免后续软件需求变更导致软件退化，并且在软件的升级过程中，我们要适时地进行架构的升级，以保持高质量的软件设计。如果我们在每次软件升级的时候没有及时地调整程序结构，而是在原有的程序结构上不断地加入代码，最终软件就会退化。</p>
<h1 id="2、什么是微服务"><a href="#2、什么是微服务" class="headerlink" title="2、什么是微服务"></a>2、什么是微服务</h1><p>随着IT行业的发展，传统的单体结构项目已经无法满足如今的软件项目的要求，越来越多的项目采用微服务架构进行开发</p>
<p><code>DDD</code>是一个很好的应用于微服务架构的方法论.</p>
<p>从本节开始，将会对微服务和与<code>DDD</code>相关的概念进行讲解.</p>
<p><code>DDD</code>相关的概念比较晦涩难懂，这也是<code>DDD</code>学习中比较高的门槛</p>
<p>在<code>DDD</code>的学习中，我们一般会经历多次“从理论到实践，在实践中应用一段时间，再回到理论”这样的过程，才会对于<code>DDD</code>的概念及实践有螺旋式上升的认知。</p>
<p>什么是微服务呢？</p>
<h2 id="2-1-单体架构优缺点"><a href="#2-1-单体架构优缺点" class="headerlink" title="2.1 单体架构优缺点"></a>2.1 单体架构优缺点</h2><p>传统的软件项目大部分都是单体结构，也就是项目中的所有代码都放到同一个应用程序中，一般它们也都运行在同一个进程中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images%5C126.png"></p>
<p>单体结构的项目有结构简单、部署简单等优点，但是有如下的缺点。</p>
<p>第一：代码之间耦合严重，代码的可维护性低。</p>
<p>虽然项目进行了分层，但是所有的模块都是在一个项目中，也就是在一个进程中，而且模块之间存在直接访问的情况，</p>
<p>例如：订单模块，直接访问物流模块，这样会导致这两个模块之间存在一定的耦合性。</p>
<p>第二：项目只能采用单一的语言和技术栈，甚至采用的开发包的版本都必须统一。</p>
<p>例如：订单模块使用<code>c#</code>开发，物流模块也是<code>c#</code>开发，并且模块开发的技术栈都是统一的，不可能会出现订单模块是<code>.net6</code>开发，而<code>物流模块使用.net7</code>开发的情况。</p>
<p>而且模块之间使用的一些第三包的版本是统一的，例如：不会出现订单模块使用某个第三包是2.1版本，而物流模块使用的相同的第三包是<code>3.2</code>版本，否则会出现版本混乱。</p>
<p>第三：一个模块的崩溃就会导致整个项目的崩溃。</p>
<p>由于整个项目是运行在同一个进程中的，很有可能会出现一个模块崩溃而导致整个项目崩溃的情况。</p>
<p>第四：升级周期长</p>
<p>一个模块升级了，其他模块也需要进行检测。从而导致升级周期变长。</p>
<p>当需要更新某一个功能时，我们需要把整个系统重新部署一遍，这会导致新功能的上线流程变长</p>
<p>第五：我们只能整体进行服务器扩容，无法对其中一个模块进行单独的服务器扩容</p>
<p>例如：只有订单模块，用户访问量比较大，只想对该模块进行服务器的扩容，但是由于是单体项目，只能进行整体的服务器扩容，增加了成本。</p>
<h2 id="2-2-微服务架构优缺点"><a href="#2-2-微服务架构优缺点" class="headerlink" title="2.2 微服务架构优缺点"></a>2.2 微服务架构优缺点</h2><p><strong>微服务项目结构</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images%5C710.png"></p>
<p>微服务架构把项目拆分为多个应用程序，每个应用程序单独构建和部署，也就是每个服务都是独立运行在单独的进程中的。</p>
<p>微服务架构有如下的优点</p>
<p>第一：每个微服务只负责一个特定的业务，业务逻辑清晰、代码简单，对于其他微服务的依赖非常低，因此易于开发和维护</p>
<p>第二：不同的微服务可以用不同的语言和技术栈开发</p>
<p>第三：一个微服务的运行不会影响其他微服务。</p>
<p>第四：可以对一个特定的微服务进行单独扩容</p>
<p>第五：当需要更新某一个功能的时候，我们只需要重新部署这个功能所在的微服务即可，不需要重新部署整个系统</p>
<p>当然，万事万物都不会只有优点没有缺点，微服务架构的缺点如下</p>
<p>微服务架构的缺点：</p>
<p>第一：在单体结构中，运维人员只需要保证一个应用的正常运行即可，而在微服务架构中，运维人员需要保证多个应用的正常运行，这给运维工作带来了更大的挑战。</p>
<p>第二：在单体结构中，各模块之间是进程内调用，数据交互的效率高，而在微服务架构中，各微服务之间要通过网络进行通信，数据交互的效率低。</p>
<p>第三：</p>
<p>在单体结构中，各模块之间的调用都是在进程内进行的，实现容错、事务一致性等比较容易，而在微服务架构中，各微服务之间通过网络通信，实现容错、事务一致性等非常困难</p>
<h2 id="2-3-微服务误区"><a href="#2-3-微服务误区" class="headerlink" title="2.3  微服务误区"></a>2.3  微服务误区</h2><p><strong>微服务的误区</strong></p>
<p>在应用微服务架构的时候，我们可能会有微服务切分过细和微服务之间互相调用过于复杂这两个主要的误区。有的技术人员并没有深刻理解微服务的本质，迷信微服务，把一个很简单的项目拆分成了几十个甚至上百个微服务，这么多微服务的管理是非常麻烦的，运维人员苦不堪言。在设计不好的微服务架构中，微服务之间的调用关系非常复杂，一个来自客户端的请求甚至要经过七八层的微服务调用，这样糟糕的设计不仅导致系统间耦合严重，而且使得服务器端的处理效率非常低，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images%5C312.png"></p>
<p>我们讲过，架构应该是进化而来的，同样微服务架构也应该是进化而来的。因此在进行系统架构设计的时候，我们应该认真思考“这个项目真的需要微服务架构吗”。如果经过思考后，我们仍然决定要采用微服务架构，那么也要再思考“能不能减少微服务的数量”。第一个版本的项目可以只有几个微服务，随着系统的发展，当我们发现一个微服务中某个功能已经发展到可以独立的程度时（比如某个功能被高频访问、某个功能经常被其他微服务访问），我们再把这个功能拆分为一个微服务。总之，是否采用微服务及如何采用微服务，应该是仔细思考后的结果，我们不能盲目跟风</p>
<h1 id="3、什么是DDD"><a href="#3、什么是DDD" class="headerlink" title="3、什么是DDD"></a>3、什么是<code>DDD</code></h1><p><code>DDD</code>（<code>Domain-driven design</code>）中文：领域驱动设计，是一个很好的应用于微服务架构的方法论。</p>
<p><code>诞生2004</code>年，兴起于2014年（微服务元年）</p>
<p><code>DDD</code>是由埃里克·埃文斯（Eric Evans）在2004年提出来的，但是一直停留在理论层次，多年来的实际应用并不广泛，直到2014年，马丁·福勒与詹姆斯·刘易斯（James Lewis）共同提出了微服务的概念，人们才发现<code>DDD</code>是一种很好的指导微服务架构设计的模式。**<code>DDD</code>的诞生早于微服务的诞生，<code>DDD</code>并不是为微服务而生的，<code>DDD</code>也可以用于单体结构项目的设计，但是在微服务架构中<code>DDD</code>能发挥出更大的作用。**</p>
<p><code>DDD</code>并不是一个技术，而是一种架构设计的指导原则,是一个方法论；<code>DDD</code>不是一种强制性的规范，各个项目可以根据自己的情况进行个性化的设计。<code>DDD</code>就像烹饪中餐时“盐少许、油少许”一样让人难以捉摸(没有明确的步骤)，而且<code>DDD</code>中的概念非常多，表述非常晦涩，因此很多人都对<code>DDD</code>望而生畏。</p>
<p>不同项目的行业情况、公司情况、团队情况、业务情况等不同，因此<code>DDD</code>不能给我们一个拿来就能照着用的操作手册。每个人、每个团队对<code>DDD</code>的理解不同，如果说“一千个人心中就有一千个哈姆雷特”的话，那么也可以说“一千个人心中就有两千个<code>DDD”</code>，因为同一个人对<code>DDD</code>也可能在不同时期有着不同的理解。</p>
<p><strong>很多开发人员把<code>DDD</code>当成一个技术，这是非常大的一个误区。<code>DDD</code>是一种设计思想</strong></p>
<p><strong><code>DDD</code>思想的目的：在项目的整个生命周期内，所有岗位的人员（开发人员，产品经理，运维，测试等待）都应该是基于对业务的相同理解来开展工作，所有人员都应该站在用户的角度，业务的角度去思考问题，而不是站在技术的角度去思考问题。</strong></p>
<p>不同的人对<code>DDD</code>的理解及对<code>DDD</code>概念落地的理解有所不同，并不存在绝对的错与对，在情况A下成功的<code>DDD</code>实战经验放到情况B下可能就会失败。正如古人所说“橘生淮南则为橘，生于淮北则为枳”，读者不要在众多的对<code>DDD</code>解读的文章中迷失，也不要执着于寻找根本就不存在的“<code>DDD</code>最佳实践”，而要认真聆听各方的解读，并且根据项目的自身情况来个性化地实现<code>DDD</code>的落地。只要读者能够用<code>DDD</code>很好地指导项目，那么该落地方案就是最优解。</p>
<p>说了那么多，到底什么是<code>DDD</code>呢？</p>
<p><strong><code>DDD</code>的英文全称是domain driven design，翻译成中文就是“领域驱动设计”。这里的主干词是“设计”，也就是说<code>DDD</code>是一种设计思想</strong>。<strong>这里的形容词是“领域驱动”，那么什么是“领域”呢？领域其实指的就是业务，因此<code>DDD</code>其实就是一种用业务驱动的设计</strong>。传统的软件设计把业务和实现技术割裂，在系统的需求设计完成后，技术人员把业务人员描述的需求文档转换为代码去实现，业务人员和技术人员对系统的理解并不完全匹配</p>
<p><strong>随着系统的升级，技术人员对代码进行修改，业务人员和技术人员对系统的理解偏差越来越大，从而造成系统的扩展性、可维护性越来越差。而<code>DDD</code>则是指在项目的全生命周期内，管理、产品、技术、测试、实施、运维等所有岗位的人员都基于对业务的相同理解来开展工作。技术人员在把业务落地为设计、代码的时候，也直接把业务映射到代码中。<code>DDD</code>的核心理念就是所有人员站在用户的角度、业务的角度去思考问题，而不是站在技术的角度去思考问题。</strong></p>
<h1 id="4、领域与领域模型"><a href="#4、领域与领域模型" class="headerlink" title="4、领域与领域模型"></a>4、领域与领域模型</h1><h2 id="4-1-什么是领域"><a href="#4-1-什么是领域" class="headerlink" title="4.1 什么是领域"></a>4.1 什么是领域</h2><p>“领域”（<code>domain</code>）是一个比较宽泛的概念，主要指的是一个组织做的所有事情，比如一家银行做的所有事情就是银行的领域。为了缩小讨论问题的范围，我们通常会把领域细分为多个“子领域”（简称“子域”），比如银行的领域就可以划分为“对公业务子域”“对私业务子域”“内部管理子域”等，子域还可以继续划分为更细粒度的子域，比如“对私业务子域”可以划分为“柜台业务子域”“ATM（automated teller machine，自动柜员机）业务子域”“网银业务子域”等。划分出子域之后，我们就能专注于子域内部的领域相关业务的处理。</p>
<p>领域（包含子域）可以按照功能划分为<strong>核心域、支撑域、通用域</strong></p>
<p>核心域 ：指的是解决项目的核心问题的领域</p>
<p>支撑域：指的是解决项目的非核心问题的领域</p>
<p>通用域：指的是解决通用问题的领域</p>
<p>领域的划分可以不限于技术相关的问题，举个例子，对于一家手机公司来讲，手机的研发、制造、销售业务就属于核心域，售后业务、财务业务就属于支撑域，而保洁、保安则属于通用域。领域划分为不同类别后，我们就可以为不同的领域投入不同的资源：对于核心域我们要投入重点资源，对于通用域我们可以采购外部服务，比如很多公司的保洁人员都是外包的第三方服务公司提供的。一个公司对于领域的不同分类也决定了公司业务方向的不同。一家注重销售的手机公司，可能手机都是从第三方采购的，只是把手机贴上自己的商标而已，对于这样的公司来讲，研发、制造业务就是通用域。</p>
<p>从软件开发技术这个层面来讲，领域的不同分类也决定了公司的研发重点。对于一家普通软件公司来讲，业务逻辑代码属于核心域，权限管理、日志模块等属于支撑域，而报表工具、工作流引擎等属于可以从外部采购的通用域。但是对于一家提供云计算基础服务的公司来讲，服务器资源管理、安全监控等属于核心域，云服务器<code>SDK</code>、技术文档、沙箱环境、计费模块等则属于支撑域，而操作系统、数据库等属于通用域。对于一家想要通过研发自己的操作系统、数据库系统从而最大化地利用服务器资源的云计算公司来讲，操作系统、数据库等就属于支撑域甚至核心域了。</p>
<h2 id="4-2-什么是领域模型"><a href="#4-2-什么是领域模型" class="headerlink" title="4.2  什么是领域模型"></a>4.2  什么是领域模型</h2><p>确定一个领域之后，我们就要对领域内的对象进行建模，从而抽象出模型的概念，这些领域中的模型就叫作领域模型（domain model）。比如银行的柜台业务领域中，就有储户、柜员、账户等领域模型。建模是<code>DDD</code>中非常核心的事情，一旦定义出了领域模型，我们就可以用领域模型驱动项目的开发。使用<code>DDD</code>，我们在分析完产品需求后，就应该创建领域模型，而不是考虑如何设计数据库和编写代码。使用领域模型，我们可以一直用业务语言去描述和构建系统，而不是使用技术人员的语言。</p>
<p>与领域模型对应的概念是“事务脚本”（transaction script），<strong>事务脚本是指使用技术人员的语言去描述和实现业务</strong>，说通俗一点儿就是没有太多设计，没有考虑可扩展性、可维护性，通过使用if、for等语句用流水账的形式编写代码。如下代码所示：，“柜员取款”业务的伪代码就是一个典型的事务脚本。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="built_in">string</span> <span class="title">Withdraw</span>(<span class="params"><span class="built_in">string</span> account,<span class="built_in">double</span> amount</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.User.HasPermission(<span class="string">&quot;Withdraw&quot;</span>))</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;当前柜员没有取款权限&quot;</span>;</span><br><span class="line">    <span class="built_in">double</span>? balance = Query(<span class="string">$&quot;select Balance from Accounts where Number=<span class="subst">&#123;account&#125;</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(balance==<span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;账号不存在&quot;</span>;</span><br><span class="line">   <span class="keyword">if</span>(balance&lt;amount)</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;账号余额不足&quot;</span>;</span><br><span class="line">     </span><br><span class="line">   Query(<span class="string">$&quot;Update Accounts set Balance=Balance-<span class="subst">&#123;amount&#125;</span> where Number=<span class="subst">&#123;account&#125;</span>&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们检查当前柜员是否拥有操作取款业务的权限，然后检查账户的余额，最后完成扣款。包括作者在内的很多开发人员的职业生涯中都写过这样流水账式的代码。这样的代码可以满足业务需求，而且编写简单、自然，非常符合开发人员的思维方式。事务脚本代码的问题在于，本应该属于支撑域中的权限的概念出现在了核心域的代码中，我们应该通过<code>AOP</code>（aspect-oriented programming，面向切面编程）等方式把权限校验的代码放到单独的权限校验支撑域中。这段代码的另外一个问题是，它对于需求变更的响应是非常糟糕的，比如系统需要增加一个“取款金额大于5万元需要主管审批”的功能，我们就要在第5行代码之前加上一些if判断语句；再比如系统需要增加一个取款成功后发送通知短信的功能，我们就要在,<code>return ok</code>这行代码之前添加上发送短信的代码…….</p>
<p>随着系统需求的膨胀，以上方法可能会膨胀出上千行的代码，代码的可维护性，可扩展性非常差。</p>
<p>而根据领域模型、<code>DDD</code>开发完成的系统，代码的可维护性、可扩展性会非常高.</p>
<p>大家学习完这次课程以后，可以尝试重构上面的代码。</p>
<h1 id="5、通用语言与界限上下文"><a href="#5、通用语言与界限上下文" class="headerlink" title="5、通用语言与界限上下文"></a>5、通用语言与界限上下文</h1><p>在进行系统开发的时候，非常容易导致歧义的是不同人员对于同一个概念的不同描述。比如用户说“我想要商品可以被删除”，开发人员就开发了一个使用<code>Delete</code>语句把商品从数据库中删除的功能；后来用户又说“我想把之前删除的商品恢复回来”，开发人员就会说“数据已经被删除了，恢复不了”，用户就会生气地说“Windows里的文件删除后都能从回收站里恢复，你们删除的怎么就恢复不了呢”。这其实就是开发人员和用户对于“删除”这个词语的理解不同造成的。再如，电商系统的支付模块的开发人员和后台管理模块的开发人员聊了许久关于“用户管理”的功能，最后才发现支付模块开发人员说的“用户”指的是购买商品的“客户”，而后台管理模块开发人员说的“用户”指的是“网站管理员”。</p>
<p>从上面两个例子我们可以看出，在描述业务对象的时候，拥有确切含义的、没有二义性的语言是非常重要的，这样的语言就是“通用语言”<strong>。在应用<code>DDD</code>的时候，团队成员必须对于系统内的每一个业务对象有确定的、无二义性的、公认的定义</strong>。通用语言离不开特定的语义环境，只有确定了通用语言所在的边界，才能没有歧义地描述一个业务对象。比如，后台管理模块中的“用户”和支付模块的“用户”就处于不同的边界中，它们在各自的边界内有着各自的含义。界限上下文就是用来确定通用语言的边界的，在一个特定的界限上下文中，通用语言有着唯一的含义。</p>
<h1 id="6、实体与值对象"><a href="#6、实体与值对象" class="headerlink" title="6、实体与值对象"></a>6、实体与值对象</h1><h3 id="6-1-实体对象"><a href="#6-1-实体对象" class="headerlink" title="6.1 实体对象"></a>6.1 实体对象</h3><p>在<code>DDD</code>中，“标识符”用来唯一定位一个对象，在数据库中我们一般用表的主键来实现标识符。当谈到标识符的时候，我们是站在业务的角度思考问题，而谈到主键的时候，我们是站在技术的角度思考问题。</p>
<p>在具体实现<code>DDD</code>的时候，实体类一般的表现形式就是<code>EF Core</code>中的实体类，实体类的Id属性一般就是标识符，Id属性的值不会变化，它标识着唯一的对象，实体类的其他属性则可能在运行时被修改(例如：商品名称，商品价格，数量等)，但是只要Id不变，我们就知道前后两个对象指的是同一个对象。我们可以把实体类的对象保存到数据库中，也可以把它从数据库中读取出来。(实体是一个概念，在<code>EFCORE</code>中的实体类就是它的一般的表现形式)</p>
<h3 id="6-2-值对象"><a href="#6-2-值对象" class="headerlink" title="6.2 值对象"></a>6.2 值对象</h3><p>在<code>DDD</code>中还存在着一些没有标识符的对象，它们也有多个属性，它们依附于某个实体类对象而存在，这些没有标识符的对象叫作值对象</p>
<p>比如，在电子地图系统中，“商家”就是一个实体类，该实体类包含营业执照编号、名称、经纬度位置、电话等属性。一个商家的营业执照编号是不可以修改的，而商家的名称、经纬度位置、电话都是可以修改的，只要两个商家的营业执照编号一样，我们就认定两个商家是同一家，因此营业执照编号就可以看作标识符。而经纬度位置就是一个值对象，经纬度位置这个值对象包含“经度”和“纬度”两个属性，经纬度位置没有标识符，而且经纬度位置的经度和纬度两个属性也不会被修改，如果商家搬家了，我们只要重新创建一个新的经纬度位置的对象，然后重新赋值商家的经度和纬度属性就可以了。当然，我们也可以取消经纬度位置这个值对象属性，直接改为经度、纬度两个属性，也就是商家实体类包含营业执照编号、名称、经度、纬度、电话等属性，但是把经度和纬度作为一个值对象更能够体现它们的整体关系。</p>
<p>定义为值对象还是实体对象的区别：整体与部分的关系</p>
<p>例如：上面所说的“商家实体类”中的经纬度是商家实体类的一部分，它是不能单独存在的。</p>
<p>问题：员工是实体对象还是值对象，是实体对象，因为员工不是商家实体类中的一部分，它们两者之间是合作的关系。</p>
<p>员工是可以独立商家而存在的。</p>
<p><strong>所以说到底是定义实体对象还是值对象，就看，是可以单独存在，还是作为某个对象的一部分存在。可以单独存在就定义成实体对象，如果是某个实体对象的一部分，不能单独的存在就是值对象。</strong></p>
<h1 id="7、聚合与聚合根"><a href="#7、聚合与聚合根" class="headerlink" title="7、聚合与聚合根"></a>7、聚合与聚合根</h1><p>一个系统中会有很多的实体类（包含值对象），这些实体类之间有的关系紧密，有的关系很弱，有的没有关系。面向对象设计的一个重要原则就是“高内聚，低耦合”（电脑与鼠标就是高内聚，低耦合，电脑中的各个元器件是高内聚，缺少了哪个都不能工作，而电脑与鼠标的关系是低耦合，也就是说电脑与鼠标只是通过接口能够链接，鼠标坏了，也不能影响接口。而且鼠标可以插入到任何电脑中，只要共同的接口就可以了），<strong>我们同样希望有关系的实体类紧密协作，而关系很弱或者没有关系的实体类可以很好地被隔离</strong>。因此，<strong>我们可以把关系紧密的实体类放到一个聚合（aggregate）中，每个聚合中有一个实体类作为聚合根（aggregate root），所有对聚合内实体类的访问都通过聚合根进行</strong>（鼠标只是通过接口与电脑进行沟通，而不会直接访问电脑中的元器件，所以接口可以理解成聚合根），外部系统只能持有对聚合根的引用，聚合根不仅仅是实体类，还是所在聚合的管理者。</p>
<p>聚合并不是简单地把实体类组合在一起，而要协调聚合内若干实体类的工作，让它们按照统一的业务规则运行，从而实现实体类数据访问的一致性，这样我们就能够实现聚合内的“高内聚”；聚合之间的关系很弱，一个聚合只能引用另外一个聚合的聚合根，这样我们就能够实现聚合间的“低耦合”。</p>
<p>聚合体现的是现实世界中整体和部分的关系，比如订单与订单明细（订单是一个实体，而订单明细也是一个实体，并且订单明细是在订单中的，外部访问的是订单，而不是订单明细）。整体封装了对部分的操作，部分与整体有相同的生命周期。部分不会单独与外部系统交互，与外部系统的交互都由整体来负责</p>
<p><strong>聚合的设计是<code>DDD</code>中比较难的工作，因为系统中很多实体类都存在着关系，这些关系到底是设计为聚合之间的关系还是聚合之内的关系是非常容易让人困惑的。判断的标准就是看它们是否是整体和部分的关系，是否存在着相同的生命周期，如果是的话，它们就是聚合内的关系，反之，则不是。</strong></p>
<p>比如，订单与订单明细之间显然是整体和部分的关系，因为删除了订单，订单明细也就消失了，而且外部系统不会直接引用订单明细，只会引用订单。因此我们把订单和订单明细设计为一个聚合，并且把订单作为聚合根，外部系统只能引用订单，对订单明细的操作都通过订单来进行。</p>
<p>而用户和订单之间的关系就不是整体与部分的关系，因为删除了订单，用户还是可以存在的。有人可能会认为，删除了用户，这个用户的订单也就消失了，因此用户和订单是整体和部分的关系。但是聚合关系还有一个判断标准就是“实体类能否单独和外部系统交互”，很显然，在系统中订单是可以单独和外部系统交互的，比如支付系统中就可以直接引用订单，因此用户和订单之间不是聚合关系。</p>
<p>有的情况下，聚合关系的划分也不是一成不变的，不同的业务流程决定了不同的划分方式。比如新闻和新闻的评论就既可以设计成同一个聚合，也可以放到不同的聚合中。如果在网站中，新闻和评论都是一起出现的，评论不会单独出现，我们就可以把它们设计成同一个聚合，把新闻设置为聚合根。但是如果在网站中，有“全站热门评论榜”“分享评论到朋友圈”等把评论作为一个独立的实体类看待的情况，我们就可以把新闻和评论设置为两个聚合。</p>
<p>在设计聚合的时候，要尽量把聚合设计得小一点儿，一个聚合只包含一个聚合根实体类和密不可分的实体类，实体类中只包含最小数量的属性。小聚合有助于进行微服务的拆分，也有助于减少数据修改冲突。设计聚合的一个原则就是：聚合宁愿设计得小一点儿，也不要设计得太大。(例如：新闻与评论，如果放到一个聚合中，后期由于评论访问比较大的时候，进行拆分比较麻烦，所以可以设计成两个聚合)</p>
<p><strong>如果不知道怎样划分，就是一个实体就是一个聚合，这样有利于以后的拆分。</strong></p>
<h1 id="8、领域服务与应用服务"><a href="#8、领域服务与应用服务" class="headerlink" title="8、领域服务与应用服务"></a>8、领域服务与应用服务</h1><p>聚合根的实体类中没有业务逻辑代码，只有对象的创建、对象的初始化、状态管理等与个体相关的代码。对<strong>于聚合内的业务逻辑，我们编写领域服务（domain service）</strong>，而对于跨聚合协作的逻辑，我们编写应用服务（application service）。应用服务协调多个领域服务来完成一个用例。</p>
<p><strong>其实就是本质上就是说，我们的代码写到什么地方。</strong></p>
<p>下面我们通过一段伪代码，来体会以上所提到的<code>领域服务，应用服务</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title">Order</span>&#123;</span><br><span class="line">     <span class="built_in">int</span> Id&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;;</span><br><span class="line">     DateTime CreateTime,</span><br><span class="line">     <span class="built_in">double</span> TotalAmount; <span class="comment">// 总金额</span></span><br><span class="line">     List&lt;OrderItem&gt;Items ;<span class="comment">// 订单明细</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Order</span>()</span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.CreateTime = DateTime.Now();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">AddDetail</span>(<span class="params"><span class="built_in">string</span> productId,<span class="built_in">int</span> count</span>)</span>&#123;</span><br><span class="line">         OrderItem item = Items.FirstOrDefault(i=&gt;i.ProductId==productId);</span><br><span class="line">         <span class="keyword">if</span>(item !=<span class="literal">null</span>)&#123;</span><br><span class="line">             item.Count+=count;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             item = <span class="keyword">new</span> OrderItem();</span><br><span class="line">             item.ParentId = <span class="keyword">this</span>.Id;</span><br><span class="line">             item.ProductId = productId;</span><br><span class="line">             item.Count = count;</span><br><span class="line">             Items.<span class="keyword">add</span>(item)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">OrderItem</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> Id;</span><br><span class="line">    <span class="built_in">int</span> ParentId;</span><br><span class="line">    <span class="built_in">string</span> ProductId;</span><br><span class="line">    <span class="built_in">int</span> Count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到在<code>Order</code>这个实体类中的构造函数中，初始化了<code>CreateTime</code>这个属性，同时在该实体类中添加了一个<code>AddDetail</code>方法，该方法中，根据传递过来的商品编号，查询订单项，如果找到了，更新数量，如果没有找到，添加一个具体的订单项。</p>
<p>这里我们可以看到这些代码，仅仅是为了完成对象的创建，对象的初始化，状态管理等工作，不是具体的业务代码，所以在聚合根<code>Order</code>这个实体类中，添加了如上的代码。</p>
<p>假如，这里有一个场景，就是用户每次最多购买99件商品，这就是一个具体的业务，而且是属于聚合内的业务，因为商品的数量与当前订单聚合有关，与其他的聚合没有关系，这个业务代码就需要领域服务中。</p>
<p>例如：有一个场景：如果订单需要与采购或者是库存，等聚合之间有关系，或者与外部系统之间有关系，例如把创建好的订单实体保存到数据库，这样的业务代码需要写到应用服务中。</p>
<p>以上其实就是体现了<code>DDD</code>的职责的划分;</p>
<p>这里也可以在对前面所讲的内容做一个总结：</p>
<p>第一：领域模型与外部系统不会发生直接的交互，领域服务也不会涉及到数据库的操作。</p>
<p>第二：业务逻辑放入领域服务中（所以说，在一些比较大的系统中，领域服务会比较复杂），而与外部系统的交互由应用服务来负责。</p>
<p>第三：领域服务不是必须的，在一些简单的业务处理中，比如简单的增删改查中，是可以没有领域服务的。像这种情况，可以在应用服务中完成所有的操作，就不需要引入领域服务了，这样可以避免过度设计。</p>
<p>这里还有两个前面已经提到的概念：</p>
<p>仓储（<code>Repository</code>）和 工作单元(<code>Unit of Work</code>)</p>
<p>仓储：负责按照要求从数据库中读取数据以及把领域服务修改的数据保存回数据库。一个聚合对应一个用来实现数据持久化的仓储。</p>
<p>工作单元：聚合内数据操作的关系是非常紧密的，我们要保证事务的强一致性，聚合内的若干相关联的操作组成一个“工作单元”，这些工作单元要么全部成功，要么全部失败。</p>
<h1 id="9、领域事件与集成事件"><a href="#9、领域事件与集成事件" class="headerlink" title="9、领域事件与集成事件"></a>9、领域事件与集成事件</h1><p>这一小节是比较重要的</p>
<p>我们在进行系统开发的时候，经常会遇到“当发生某事件的时候，执行某个动作（什么是事件）”。比如，在一个问答系统中，当有人回复了提问者的提问的时候，系统就向提问者的邮箱发送通知邮件，如果我们使用事务脚本的方式来实现这个功能，如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveAnswer</span>(<span class="params"><span class="built_in">long</span> id,<span class="built_in">string</span> answer</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   保存到数据库(id,answer);</span><br><span class="line">   <span class="built_in">string</span> email = 获取提问者邮箱(id);</span><br><span class="line">   发送邮件(email,<span class="string">&quot;你的问题被回答了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样编写的代码有如下几个问题。</p>
<p>第一个问题：代码会随着需求的增加而持续膨胀。比如网站又增加了一个功能“如果用户回复的答案中有疑似违规的内容，则先把答案隐藏，并且通知管理员进行审核”，那么我们就要把“保存答案”方法修改成，如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SaveAnswer</span>(<span class="params"><span class="built_in">long</span> id,<span class="built_in">string</span> answer</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">long</span> aId = 保存到数据库(id,answer);</span><br><span class="line">     <span class="keyword">if</span>(检查是否疑似违规(answer))</span><br><span class="line">     &#123;</span><br><span class="line">        隐藏答案(aId);</span><br><span class="line">        通知管理员审核();</span><br><span class="line">     &#125;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">string</span> email = 获取提问者邮箱(id);</span><br><span class="line">      发送邮件(email,<span class="string">&quot;你的问题被回答了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着系统的升级，这个方法的代码也越来越长、越来越复杂，充斥着大量一层嵌套一层的判断语句。这样的代码经过几任开发人员的接手，可能没有任何一个开发人员能够完全理解这个方法。当需要为这个方法增加新的功能的时候，开发人员不敢修改前任的代码，他只能“胆战心惊”地找到一个位置插入自己编写的代码，如果代码恰好能够运行，又没有导致原有功能出现bug，就是一件“天大的喜事”。这样新版本的代码又成为了继任的开发人员不敢动的“祖传代码”。总之，这样的事务脚本的可读性和可维护性非常差。</p>
<p>第二个问题：</p>
<p>代码可扩展性低。在后续版本中，我们可能要把“发送邮件”改成“发送短信”，那么我们就要把发送邮件行代码改成与发送短信相关的代码；如果后续我们又要把逻辑改成“向普通会员发邮件，向VIP会员发短信”，那我们就要把代码改成由多个判断语句组成的代码块</p>
<p>面向对象设计中有一个原则是<strong>“开闭原则”</strong>，即“对扩展开放，对修改关闭”，通俗来讲就是“当需要增加新的功能的时候，我们可以通过增加扩展代码来完成，而不需要修改现有的代码”。很显然，我们这种事务脚本的写法是很难满足开闭原则的。</p>
<p>第三个问题：</p>
<p>用户体验很差。这段代码中除了“保存答案”这个核心的业务逻辑之外，掺杂了“检查是否疑似违规”“发送邮件”等业务逻辑，这些业务逻辑的执行一般都比较耗时，会拖慢“保存答案”方法的执行速度，造成每次用户单击【保存答案】按钮的时候都要等待很长时间。</p>
<p>第四个问题：</p>
<p>容错性差。“检查是否疑似违规”可能需要调用第三方的鉴黄服务，“发送邮件”需要访问邮件服务，这些都需要访问外部系统，这些外部系统并不总是稳定的。比如，在发送邮件时，邮件服务器的暂时故障可能会造成用户单击【保存答案】按钮后，系统提示“操作失败”，因此用户体验是极差的。</p>
<p>为了解决以上的问题，可以<strong>通过事件机制来进行解</strong>决。</p>
<p>为了解决这些问题，我们可以在保存答案后，发出一个“答案已保存”的通知事件，内容审核模块和邮件发送模块监听这个事件来分别进行各自的处理。采用事件机制的伪代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> 保存答案(<span class="built_in">long</span> id,<span class="built_in">string</span> answer)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">long</span> aId = 保存到数据库(id,answer);</span><br><span class="line">     发布事件(<span class="string">&quot;答案已保存&quot;</span>,aId,answer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [绑定事件(<span class="string">&quot;答案已保存&quot;</span>)]</span><br><span class="line">  <span class="keyword">void</span> 审核答案(<span class="built_in">long</span> aId,<span class="built_in">string</span> answer)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(检查是否疑似违规(answer))</span><br><span class="line">    &#123;</span><br><span class="line">       隐藏答案(aId);</span><br><span class="line">       发布事件(<span class="string">&quot;内容待审核&quot;</span>,aId);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> [绑定事件(<span class="string">&quot;答案已保存&quot;</span>)]</span><br><span class="line"> <span class="keyword">void</span> 发邮件给提问者(<span class="built_in">long</span> aId,<span class="built_in">string</span> answer)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="built_in">long</span> qId = 获取问题Id(aId);</span><br><span class="line">    <span class="built_in">string</span> email = 获取提问者邮箱(qId);</span><br><span class="line">    发送邮件(email,<span class="string">&quot;你的问题被回答了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的<code>保存答案</code>方法中，在将答案保存到了数据库以后，发布了一个事件叫做<code>答案已保存</code>，下面将该事件绑定到了<code>审核答案，发送邮件给提问者</code>方法上，当<code>答案已保存</code>这个事件发生了以后，<code>审核答案，发送邮件给提问者</code>这两个方法就会被执行。</p>
<p>采用这样的事件机制的代码有如下优点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、关注点分离。3个方法各司其职，各自的业务逻辑没有混杂到一起，代码的可读性、可维护性都非常高。</span><br><span class="line">2、扩展容易。如果我们需要实现“保存答案后，刷新缓存”，只要再增加一个新的方法并且将其绑定到&quot;答案已保存&quot;事件即可，现有的代码不用做任何修改，符合“开闭原则”。</span><br><span class="line">3、用户体验好。我们可以把“审核答案”“发邮件给提问者”等这些对事件的处理异步运行，这样这些处理就不会影响用户体验。</span><br><span class="line">4、容错性更好。如果外部系统调用失败，我们可以进行失败重试（主要是保存答案这个方法，修改成异步的以后，用户不用等待第三方的处理完成以后才会受到反馈，这样第三方处理失败了，例如发送短信失败了，可以在发送短信或者是发送邮件的方法中进行重试，这时候修改的是发送短信或者是发送邮件的方法，其他方法中的代码不需要修改）</span><br></pre></td></tr></table></figure>

<p><code>DDD</code>中的事件分为两种类型：领域事件（domain events）和集成事件（integration events）</p>
<p>领域事件：主要用于在同一个微服务内(同一个进程内)的聚合之间的事件传递。</p>
<p>比如在问答微服务中，当用户保存答案的时候，审核答案的逻辑我们一般通过领域事件实现，因为：保存答案与审核答案我们一般都是将其放到同一个微服务中。</p>
<p>集成事件：用于跨微服务的事件传递，例如：项目中有专门的邮件发送微服务，则当用户保存答案的时候，发送邮件给提问者的操作就要通过集成事件来实现。还有就是我们前面提到的订单与仓库，这是两个不同的微服务，当用户下完订单以后，可以通知仓库发货。</p>
<p>这时候涉及到了不同的微服务直接的事件传递，所以需要使用的就是集成事件来完成。集成事件的实现，主要是通过事件总线来实现，一般也是使用第三方的，例如<code>redis</code>，<code>RabbitMQ</code>(我们一般使用消息队列服务器中的“发布&#x2F;订阅”模式来实现事件总线。)</p>
<h1 id="10、贫血模型与充血模型"><a href="#10、贫血模型与充血模型" class="headerlink" title="10、贫血模型与充血模型"></a>10、贫血模型与充血模型</h1><p>在前面的小节中，我们主要讲解了关于<code>DDD</code>中常见的概念，从这一小节开发，我们逐步的来看一下关于<code>DDD</code>中这些概念应该怎样进行落地。</p>
<p>在面向对象的设计中有贫血模型和充血模型两种风格。所谓的贫血模型指的是一个类中只有属性或者成员变量，没有方法（有意义的方法，虽然<code>get</code>和<code>set</code>也是方法，但是没有具体的其他方面的意义），而充血模型指的是一个类中既有属性、成员变量，也有方法。下面用一个用户的例子来说明它们的区别。</p>
<p>下面通过一段需求结合伪代码来体会一下贫血模型与充血模型</p>
<p>需求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设我们需要定义一个类，这个类中可以保存用户的用户名、密码、积分；用户必须具有用户名；为了保证安全，密码采用密码的哈希值保存；用户的初始积分为10；每次登录成功奖励5个积分，每次登录失败扣3个积分（这样的需求肯定是不合理的，这里只是为了方便演示而已）。</span><br></pre></td></tr></table></figure>

<p>如果采用贫血模型，我们就会如下定义<code>User</code>类。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;     <span class="comment">//用户名</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> PasswordHash &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//密码的哈希值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> Credit &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;         <span class="comment">//积分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个典型的只包含属性、不包含逻辑方法的类，这样的类通常被叫作<code>POCO</code>类，这就是典型的“贫血模型”。使用这样的类，我们编写代码来进行用户创建、登录、积分变动操作</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> User u1 = <span class="keyword">new</span> User();</span><br><span class="line"> u1.UserName = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"> u1.Credit = <span class="number">10</span>;</span><br><span class="line"> u1.PasswordHash = HashHelper.Hash(<span class="string">&quot;123456&quot;</span>);<span class="comment">//计算密码的哈希值</span></span><br><span class="line"> <span class="built_in">string</span> pwd = Console.ReadLine();</span><br><span class="line"> <span class="keyword">if</span>(HashHelper.Hash(pwd)==u1.PasswordHash)</span><br><span class="line"> &#123;</span><br><span class="line">     u1.Credit += <span class="number">5</span>;                        <span class="comment">//登录成功，奖励5个积分</span></span><br><span class="line">     Console.WriteLine(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (u1.Credit &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;积分不足，无法扣减&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        u1.Credit -= <span class="number">3</span>;                   <span class="comment">//登录失败，则扣3个积分</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   Console.WriteLine(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以正常地实现需求，但有问题：</p>
<p>这里是将业务逻辑与实体的状态初始化，实体状态的管理等一系列的代码，都写在一起了，导致代码非常的臃肿。</p>
<p>如果我们按照面向对象的原则来重新设计User类，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; <span class="comment">// 这里将UserName 设置为只读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Credit &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>? passwordHash; <span class="comment">// 这里是私有的成员变量，因为密码的哈希值是不应该被外部系统访问的。</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params"><span class="built_in">string</span> userName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">this</span>.UserName = userName;     <span class="comment">// 在构造函数中给UserName赋值</span></span><br><span class="line">       <span class="keyword">this</span>.Credit =<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePassword</span>(<span class="params"><span class="built_in">string</span> newValue</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(newValue.Length&lt;<span class="number">6</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;密码太短&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">this</span>.passwordHash = HashHelper.Hash(newValue);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckPassword</span>(<span class="params"><span class="built_in">string</span> password</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">string</span> hash = HashHelper.Hash(password);</span><br><span class="line">      <span class="keyword">return</span> passwordHash== hash;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeductCredits</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(delta&lt;=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;额度不能为负值&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.Credit -= delta;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddCredits</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">this</span>.Credit += delta;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Credit</code>属性设置为只读并且只能在<code>User</code>类内部被修改.</p>
<p><code>passwordHash</code>:是私有的成员变量，因为密码的哈希值是不应该被外部系统访问的。当然为了能够让外部系统发送修改密码的请求以及检查密码是否正确，这里提供了<code>ChangePassword,CheckPassword</code>方法，把保存密码和校验密码的工作封装起来。</p>
<p>通过合理设置User类的属性的访问修饰符，我们有效地避免了外部访问者对类内部数据的随意修改</p>
<p>以上实现的<code>User</code>这个实体类就是充血模型，也<strong>就是将针对实体的初始化，状态更改等操作放在了实体类中完成，这就是所谓的充血模型。</strong></p>
<p>具体的业务操作就比较简单了，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  User u1 = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">  u1.ChangePassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">  <span class="built_in">string</span> pwd = Console.ReadLine();</span><br><span class="line">  <span class="keyword">if</span> (u1.CheckPassword(pwd))</span><br><span class="line"> &#123;</span><br><span class="line">     u1.AddCredits(<span class="number">5</span>);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">       u1.DeductCredits(<span class="number">3</span>);</span><br><span class="line">     Console.WriteLine(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>大家可能会认为，无论是贫血模型还是充血模型，只不过是逻辑代码放置的位置不同而已，本质上没什么区别。这样的观点是错误的。首先，从代码的角度来讲，把本应该属于User类的行为封装到User类中，这是符<strong>合“单一职责原则”</strong>的，当系统中其他地方需要调用User类的时候就可以复用User中的方法。其次，贫血模型是站在开发人员的角度思考问题的，而充血模型是站在业务的角度思考问题的。领域专家不明白什么是“把用户输入的密码进行哈希运算，然后把哈希值保存起来”，但是他们明白“修改密码、检查密码成功”等充血模型反映出来的概念，因此领域模型中的所有行为应该有业务价值，而不应该只是反映数据属性。</p>
<p>当然，充血模型设计起来比较复杂一些（<code>EFCore</code>中还需要进行配置，使用难度增加），需要仔细分析模型中需要完成的操作。</p>
<p>尽管充血模型带来的好处更明显，但是贫血模型依然很流行，其根本原因就在于早期的很多持久性框架（比如<code>ORM</code>等）要求实体类的所有属性必须是可读可写的，而且我们可以很简单地把数据库中的表按照字段逐个映射为一个贫血模型的<code>POCO</code>类，这样“数据库驱动”的思维方法更简单直接，因此我们就见到“到处都是贫血模型”的情况了。值得欣慰的是，目前大部分主流的持久性框架都已经支持充血模型的写法了，比如<code>EF Core</code>对充血模型的支持就非常好(当然还是需要进行配置)，因此我们就没有再继续编写贫血模型的理由了。采用充血模型编写代码，我们能更好地实现<code>DDD</code>和模型驱动编程。</p>
<h1 id="11、EF-Core-对实体类属性操作"><a href="#11、EF-Core-对实体类属性操作" class="headerlink" title="11、EF Core 对实体类属性操作"></a>11、<code>EF Core</code> 对实体类属性操作</h1><p><code>EF Core</code>对实体类属性的读写操作有一个非常不容易被发现的秘密，了解这个秘密之后，我们能更好地在<code>EF Core</code>中实现充血模型，因此本小节将会为大家揭示这个秘密。</p>
<p>我们知道，对于属性的读写操作都是通过<code>get,set</code>代码块来进行的，因此，当我们通过<code>EF Core</code> 把实体类对象写入数据库或者把数据从数据库中加载到实体对象的时候，<code>EF Core</code>也应该通过实体类对象的属性的<code>get,set</code>进行属性的读写。但是基于性能和对特殊功能支持的考虑，<code>EF Core</code>在读写属性的时候，如果可能，它会直接跳过<code>get,set</code>,而直接操作真正存储属性值的成员变量。</p>
<p>下面来演示一下：</p>
<p>新创建一个控制台的项目</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>Exe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>net7.0<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImplicitUsings</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">ImplicitUsings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Nullable</span>&gt;</span>enable<span class="tag">&lt;/<span class="name">Nullable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!---安装EFCore需要的包---&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.EntityFrameworkCore.SqlServer&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;7.0.3&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.EntityFrameworkCore.Tools&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;7.0.3&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PrivateAssets</span>&gt;</span>all<span class="tag">&lt;/<span class="name">PrivateAssets</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">IncludeAssets</span>&gt;</span>runtime; build; native; contentfiles; analyzers; buildtransitive<span class="tag">&lt;/<span class="name">IncludeAssets</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">PackageReference</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后创建<code>Person.cs</code>实体类，该类中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;get 被调用&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> name; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">set</span> &#123; </span><br><span class="line"></span><br><span class="line">                name = <span class="keyword">value</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们为了方便观察代码对<code>Name</code>属性的<code>get,set</code>代码块的调用情况，我们编写<code>Name</code>属性的代码的时候没有使用<code>&#123;get;set;&#125;</code>这样简化的语法，而是使用完全的<code>get,set</code>代码块，把属性的值显式地保存到名字为<code>name</code>的成员变量中，并且在<code>get和set</code>代码块中都加入了调试输出的信息。</p>
<p>下面搭建<code>EF Core</code>的环境</p>
<p>创建<code>PersonConfig.cs</code>类，该类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Person</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Person&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Persons&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面再创建<code>TestDbContext.cs</code>类，该类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">          <span class="keyword">public</span> DbSet&lt;Person&gt; Persons &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=D1;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">            optionsBuilder.UseSqlServer(connStr);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面进行数据的迁移操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration InitialCreate</span><br><span class="line"> Update-database</span><br></pre></td></tr></table></figure>

<p>整个<code>EFCore</code>的环境搭建好以后，下面我们需要创建<code>Person</code>类的对象，并且把对应的数据插入到数据库中，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ConsoleApp1;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.Name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;完成Person初始化&quot;</span>);</span><br><span class="line"><span class="keyword">using</span> (TestDbContext ctx= <span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    ctx.Persons.Add(person);    </span><br><span class="line">    ctx.SaveChanges();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;SaveChanges执行完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，然后查看运行结果，发现<code>Name</code>属性的<code>get</code>代码块没有被调用执行。按照常理来讲，<code>SaveChanges</code>方法在将对象插入数据库的时候，需要读取<code>Name</code>属性的值，这时候应该会调用<code>get</code>代码块，但是实验的结果表明<code>get</code>代码块没有被调用，那么<code>EFCore</code>是怎样得到<code>Name</code>属性的值的呢？</p>
<p>下面我们再来读取一下数据，看一下执行情况，如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ConsoleApp1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Person person = new Person();</span></span><br><span class="line"><span class="comment">person.Name = &quot;zhangsan&quot;;</span></span><br><span class="line"><span class="comment">Console.WriteLine(&quot;完成Person初始化&quot;)*/</span>;</span><br><span class="line"><span class="keyword">using</span> (TestDbContext ctx= <span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ctx.Persons.Add(person);    </span></span><br><span class="line"><span class="comment">     ctx.SaveChanges();</span></span><br><span class="line"><span class="comment">     Console.WriteLine(&quot;SaveChanges执行完毕&quot;);*/</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;准备读取数据&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> p = ctx.Persons.First(p=&gt;p.Name==<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;数据读取完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，Name属性的set代码块竟然也没有被调用。按照常理来讲，<code>EF Core</code>在从数据库中读取数据的时候，应该会调用set代码块为对象的Name属性赋值，但是实验的结果表明set代码块没有被调用，那<code>EF Core</code>是怎么设置Name属性的值的呢？</p>
<p>答案其实很简单，**<code>EF Core</code>在读写实体类对象的属性时，会查找类中是否有与属性的名字一样（忽略大小写）的成员变量，如果有这样的成员变量的话，<code>EF Core</code>会直接读写这个成员变量的值，而不是通过set和get代码块来读写**。如果我们采用<code>stirng Name&#123;get;set;&#125;</code>这种简化的语法来声明属性，编译器会为我们生成名字为<code>&lt;Name&gt;k__BackingField的成员变量来保存属性的值</code>，因此<code>EF Core</code>除了查找与属性同名的成员变量之外，也会查找符合<code>&lt;Name&gt;k__BackingField</code>规则的成员变量，还会查找“_name”“m_name”等常见写法的成员变量。</p>
<p>由于<code>EF Core</code>直接读写属性背后的成员变量，而不是通过执行<code>get、set</code>代码块来读写属性的值，因此我们编写的<code>get、set</code>代码块就不会被<code>EF Core</code>执行了</p>
<h1 id="12、-EF-Core中实现充血模型"><a href="#12、-EF-Core中实现充血模型" class="headerlink" title="12、 EF Core中实现充血模型"></a>12、 <code>EF Core</code>中实现充血模型</h1><h2 id="12-1-充血模型实体类特征说明"><a href="#12-1-充血模型实体类特征说明" class="headerlink" title="12.1  充血模型实体类特征说明"></a>12.1  充血模型实体类特征说明</h2><p><code>EF Core</code>中对充血模型提供了比较好的支持，本小节我们来学习如何在<code>EF Core</code>中把充血模型风格的实体类映射到数据库表中</p>
<p>这里我们看一个充血模型，然后总结一下充血模型中实体类的特征：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 因为Id是由数据库生成的自增字段，我们无法修改它的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span> &#125;                    <span class="comment">//特征一</span></span><br><span class="line">     <span class="comment">// CreatedDateTime（创建日期）在对象创建的时候初始化,之后我们就不能修改这个属性的值，因此我们同样把CreatedDateTime属性修饰为init</span></span><br><span class="line">    <span class="keyword">public</span> DateTime CreatedDateTime &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  <span class="comment">//特征一</span></span><br><span class="line">   <span class="comment">//  UserName（用户名）、Credit（积分）这两个属性可以由类内部的代码修改，因此我们把它们的set操作修饰为私有的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;    <span class="comment">//特征一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Credit &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>? passwordHash;                   <span class="comment">//特征三</span></span><br><span class="line">    <span class="comment">// Remark（备注）是一个只读属性，它的值只能从数据库中读取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span>? remark;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>? Remark                           <span class="comment">//特征四</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123; <span class="keyword">return</span> remark; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     <span class="comment">// 这里要求Tag属性不被映射到数据库表中</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span>? Tag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;                <span class="comment">//特征五</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">User</span>()                                  <span class="comment">//特征二</span></span></span><br><span class="line">   &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params"><span class="built_in">string</span> yhm</span>)                         <span class="comment">//特征二</span></span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">this</span>.UserName = yhm;</span><br><span class="line">      <span class="keyword">this</span>.CreatedDateTime = DateTime.Now;</span><br><span class="line">      <span class="keyword">this</span>.Credit = <span class="number">10</span>;</span><br><span class="line">       <span class="keyword">this</span>.remark=<span class="string">&quot;......&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeUserName</span>(<span class="params"><span class="built_in">string</span> newValue</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">this</span>.UserName = newValue;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePassword</span>(<span class="params"><span class="built_in">string</span> newValue</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue.Length &lt; <span class="number">6</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;密码太短&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.passwordHash = HashHelper.Hash(newValue);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>充血模型中的实体类与前面我们所讲的贫血模型中实体类相比，有如下的特征：</p>
<p>第一个特征：有的属性是只读的或者只能被类内部的代码修改</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; <span class="comment">// 这里将UserName 设置为只读</span></span><br></pre></td></tr></table></figure>

<p>这是我们前面定义的充血模型案例中的<code>UserName</code>属性，我们可以看到它是只读的，只能在当前类的构造函数中进行初始化。</p>
<p>后面是不能对该属性的值进行修改的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Credit &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>该属性也是只读的，并且只能在当前类中修改<code>Credit</code>属性的值，外部类是不能修改的。</p>
<p>也就是说，充血模型要能够对以上提到的情况进行支持。</p>
<p>第二个特征：可以定义有参构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="title class_">User</span>(string userName)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">UserName</span> = userName;     <span class="comment">// 在构造函数中给UserName赋值</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">Credit</span> =<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个构造函数<code>User</code>，完成了对<code>UserName</code>属性和<code>Credit</code>属性的赋值。</p>
<p>关于特征二，也就是上面我们提到的<code>实体类中可能包含有参数的构造方法</code>。这里需要注意一个点：</p>
<p>如果定义的充血模型中的实体类只有有参构造方法，而没有无参构造方法，<strong>这时候要求有参构造方法中的参数名字必须和属性的名字一致（如上代码）</strong>，因为在<code>EFCore</code>中从数据库加载数据的时候，它会利用反射的机制来调用有参构造方法来初始化实体对象。只有构造方法的参数名字和属性的名字一致，<code>EFCore</code>才知道构造方法中参数和数据库表的对应关系。</p>
<p>当然，如果在定义的充血模型的实体类中，**有参数构造方法，也有无参构造方法，这就要求无参构造方法定义为<code>private</code>.**这时候<code>EFCore</code>可以调用私有的构造方法，因此<code>EFCore</code>在从数据库中加载数据到实体类对象的时候，会调用这个私有构造方法创建实体对象，然后对各个属性进行赋值，而有参构造可以给开发人员使用。当然，有参构造的参数名字没有必要和属性的名字保持一致，如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private <span class="title class_">User</span>()                                  <span class="comment">//特征二</span></span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  public <span class="title class_">User</span>(string yhm)                         <span class="comment">//特征二</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">UserName</span> = yhm;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">CreatedDateTime</span> = <span class="title class_">DateTime</span>.<span class="property">Now</span>;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">Credit</span> = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>第三个特征：有的成员变量没有对应的属性，但是这些成员变量需要映射为数据库表中的字段，也就是需要我们将私有成员变量映射到数据库表中的列。</p>
<p>如下所以：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span>? passwordHash;       </span><br></pre></td></tr></table></figure>

<p>这里的<code>passwordHash</code>,是一个私有的成员变量，没有对应的属性。将其定义成私有成员变量的原因是：关于密码的操作，例如赋值，判断都是在当前实体类中，通过不同方法完成的，也就是说，只在当前类中使用<code>passwordHash</code>，不允许在外部其它类中使用。</p>
<p>所以这里将其定义为私有成员变量。</p>
<p>但是，问题是，我们需要将其映射到数据表中的列。</p>
<p>这应该怎样处理呢？</p>
<p>在<code>EFCore</code>中我们只需要在配置实体类的代码中，使用<code>builder.Property(&quot;成员变量名&quot;)</code>来配置即可。</p>
<p>第四个特征：有的属性是只读的，也就是它的值是从数据库中读取出来的，但是我们不能修改属性的值，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span>? Remark                           <span class="comment">//特征四</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">get</span> &#123; <span class="keyword">return</span> remark; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>例如：上面我们定义的<code>Remark</code>属性，假设它是只读的，这里我们只为其添加<code>get</code>，没有添加<code>set</code></p>
<p>同时，在<code>EFCore</code>中我们还需要在配置实体类的代码中，使用<code>HasField(&quot;成员变量名&quot;)</code>来配置属性。</p>
<p>第五个特征：有的属性不需要映射到数据列，仅仅在运行的时候被使用。</p>
<p>针对这种情况，在<code>EFCORE</code>中我们只要在配置实体类的代码中，使用<code>Ignore</code>来配置忽略相关属性即可。</p>
<h2 id="12-2-实现充血模型"><a href="#12-2-实现充血模型" class="headerlink" title="12.2 实现充血模型"></a>12.2 实现充血模型</h2><p>在控制台项目中创建<code>User.cs</code>这个充血模型实体类</p>
<p>其中的代码，就是上一小节中的所展示的代码</p>
<p><code>HashHelper.cs</code>中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HashHelper</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Hash</span>(<span class="params"><span class="built_in">string</span> input</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">using</span> (MD5 md5Hash = MD5.Create())</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">byte</span>[] data = md5Hash.ComputeHash(Encoding.UTF8.GetBytes(input));</span><br><span class="line">             StringBuilder sBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">             <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">             &#123;</span><br><span class="line">                 sBuilder.Append(data[i].ToString(<span class="string">&quot;x2&quot;</span>));</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> sBuilder.ToString();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面在<code>TestDbContext.cs</code>中添加<code>Users</code>这个<code>DbSet</code>这个属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> DbSet&lt;Person&gt; Persons &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 添加Users这个DbSet这个属性</span></span><br></pre></td></tr></table></figure>

<p>下面需要对<code>User</code>这个实体类进行配置，创建<code>UserConfig.cs</code>，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">User</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;User&gt; builder</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        builder.ToTable(<span class="string">&quot;T_Users&quot;</span>);</span><br><span class="line">        builder.Property(<span class="string">&quot;passwordHash&quot;</span>);<span class="comment">// 针对特征三的配置</span></span><br><span class="line">        builder.Property(u =&gt; u.Remark).HasField(<span class="string">&quot;remark&quot;</span>);<span class="comment">// 针对特征四的配置</span></span><br><span class="line">        builder.Ignore(u=&gt;u.Tag); <span class="comment">// 针对特征五的配置</span></span><br><span class="line">        <span class="comment">// 以上特征四和特征五的应用很少。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面进行数据的迁移操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration CreateUser</span><br><span class="line"> Update-database</span><br></pre></td></tr></table></figure>

<p>打开数据库中对应的表，发现<code>passwordHash</code>这个字段是有的，但是没有<code>Tag</code>这个字段</p>
<p>下面开始编写测试的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx = <span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">    user.ChangePassword(<span class="string">&quot;1234567&quot;</span>);</span><br><span class="line">    ctx.Users.Add(user);</span><br><span class="line">    ctx.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动程序进行测试</p>
<p>进行查询：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx = <span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* User user = new User(&quot;wangwu&quot;);</span></span><br><span class="line"><span class="comment">    user.ChangePassword(&quot;1234567&quot;);</span></span><br><span class="line"><span class="comment">    ctx.Users.Add(user);</span></span><br><span class="line"><span class="comment">    ctx.SaveChanges();*/</span></span><br><span class="line">    User user = ctx.Users.First(u=&gt;u.UserName == <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">    Console.WriteLine(user.UserName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里也可以给构造方法打上断点，查看执行的效果。</p>
<h1 id="13、EF-Core中实现值对象"><a href="#13、EF-Core中实现值对象" class="headerlink" title="13、EF Core中实现值对象"></a>13、<code>EF Core</code>中实现值对象</h1><h2 id="13-1-枚举类型的存储"><a href="#13-1-枚举类型的存储" class="headerlink" title="13.1   枚举类型的存储"></a>13.1   枚举类型的存储</h2><p>在<code>DDD</code>中还存在着一些没有标识符的对象，它们也有多个属性，它们依附于某个实体类对象而存在，这些没有标识符的对象叫作值对象</p>
<p>在定义实体类的时候，实体类中的一些属性之间有着紧密的联系，比如我们要在表示城市的实体类City中定义表示地理位置的属性，因为地理位置包含“经度”（<code>longitude</code>）和“纬度”（<code>latitude</code>）两个值，所以我们可以为<code>City</code>类增加<code>Longitude</code>、<code>Latitude</code>两个属性。这也是大部分人的做法，这样做没什么太大的问题。不过，从逻辑上来讲，这样定义的经纬度和主键、名字等属性之间是平等的关系，体现不出来经度和纬度的紧密关系。如果我们能定义一个包含<code>Longitude、Latitude</code>两个属性的<code>Geo</code>类型，然后把City的“地理位置”属性定义为<code>Geo</code>类型，这样经度、纬度的关系就更紧密了。<code>Geo</code>类型的<code>Longitude、Latitude</code>两个属性通常不会被单独修改，因此<code>Geo</code>被定义成不可变类，也就是值对象。</p>
<p>在定义实体类的时候，实体类中有的属性为数值类型，比如“商品”实体类中的质量属性。我们如果把质量定义为double类型，那么其实隐含了一个“质量单位”的领域知识，使用这个实体类的开发人员就需要知道这个领域知识，而且我们还要通过文档等形式把这个领域知识记录下来，这又面临一个文档和代码修改同步的问题。在<code>DDD</code>中，我们要尽量减少文档中不必要的领域知识。如果我们定义一个包含<code>Value（数值）、Unit（</code>质量单位）的<code>Weight</code>类型，然后把“商品”的质量属性设置为<code>Weigh</code>t类型，这样的代码中天然包含了数值和质量单位信息。在定义实体类的时候，很多数值类型的属性其实都是隐含了单位的，比如金额隐含了币种信息。理想情况下，这些数值类型的属性都应该定义为包含了计量单位信息的类型。这些包含数值和计量单位的类也一般被定义为不可变的值对象。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Product</span>&#123;</span><br><span class="line">    <span class="built_in">long</span> Id;</span><br><span class="line">    <span class="built_in">string</span> Name;</span><br><span class="line">    Weight Weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Weight</span>&#123;</span><br><span class="line">    <span class="built_in">double</span> <span class="keyword">value</span>;</span><br><span class="line">    WeightUnit Unit;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关于WeightUnit可以定义成一个枚举类型</span></span><br><span class="line"><span class="built_in">enum</span> WeightUnit&#123;G,KG&#125;</span><br><span class="line">Proudct p = <span class="keyword">new</span> Product();</span><br><span class="line">p.Weight = <span class="keyword">new</span> Weight(<span class="number">5</span>,KG) <span class="comment">// 表示是5公斤</span></span><br></pre></td></tr></table></figure>

<p>我们在编写实体类的时候，有一些属性的可选值范围是固定的，比如“员工”中用来定义职位级别的属性为int类型，可选范围为1～3，它们分别表示“初级”“中级”“高级”。我们用int类型表示级别，因此我们同样需要在文档中说明不同数值的含义。如果我们用C#中的枚举类型来表示这些固定可选值范围的属性，就可以让代码的可读性更强，也就更加符合<code>DDD</code>的思想。</p>
<p>下面，我们看一下怎样对上面提到的枚举类型存储到数据库中。在控制台的项目中，添加一个<code>Book.cs</code>这个实体类，该实体类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Book</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> CurrencyName Currency &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> CurrencyName &#123; </span><br><span class="line">      CNY,USD</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道书的价格是有单位的，针对单位，这里我们定义了<code>Currency</code>这个属性，该属性的类型是一个枚举类型<code>CurrencyName</code>.在该枚举类型中定义了单位成员。</p>
<p>当然这里的属性<code>Currency</code>，可以定义成<code>string</code>类型，但是定义成字符串类型，我们无法直观的看出它的具体单位是什么，还需要查看文档。但是定义成枚举类型以后，就比较直观了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Person&gt; Persons &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Book&gt; Books &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;   <span class="comment">// 添加了Books这个DbSet的类型属性</span></span><br></pre></td></tr></table></figure>

<p>下面进行数据库的迁移操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration AddBook</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>下面在<code>Program.cs</code>文件中进测试：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx = <span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    Book book = <span class="keyword">new</span> Book() &#123; Name=<span class="string">&quot;C#&quot;</span>, Currency= CurrencyName.CNY &#125;;</span><br><span class="line">    Book book1 = <span class="keyword">new</span> Book() &#123; Name=<span class="string">&quot;Vue&quot;</span>, Currency = CurrencyName.USD &#125;;</span><br><span class="line">    ctx.Books.Add(book);</span><br><span class="line">    ctx.Books.Add(book1);</span><br><span class="line">    ctx.SaveChanges();  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>执行完上面的测试代码以后，我们可以查看数据库中对应的<code>Books</code>表（注意：这里我们没有写<code>BookConfig.cs</code>，这个类，也就是没有针对<code>Book</code>这个实体类进行配置，这样全部采用默认的配置），</p>
<p><strong>我们发现，枚举类型的属性在数据库中默认是以<code>int</code>类型来进行保存的。</strong></p>
<p>下面看一下查询的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx = <span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    Book book = ctx.Books.First();</span><br><span class="line">    Console.WriteLine(book.Currency);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行上面的查询代码，打印的结果是枚举的内容。(底层做了处理，我们在代码中使用的就是枚举)</strong></p>
<p>当然，这里如果感觉，数据库中存储的枚举用<code>int</code>来进行表示，并不直观，可读性不强，在<code>EFCore</code>中可以使用<code>HasConversion&lt;string&gt;</code>把枚举类型的值配置成字符串。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Book</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Book&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将枚举转换成字符串</span></span><br><span class="line">            builder.Property(e=&gt;e.Currency).HasConversion&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进行数据库的迁移操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration AddBook2</span><br></pre></td></tr></table></figure>

<p>执行完以上的命令以后，会出现如下的警告：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy.</span><br></pre></td></tr></table></figure>

<p>说明：更改后的类型与数据表中，<code>Currency</code>字段的原有类型是不一致，因此有可能会造成数据的丢失，这里我们不需要关心。</p>
<p>下面直接执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>这时候，查看数据表<code>Books</code>中<code>Currency</code>字段的类型就是字符串类型，当然这里你也可以限制字符串类型的长度。</p>
<p>下面我们再执行如下的测试代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx = <span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  Book book = ctx.Books.First();</span></span><br><span class="line"><span class="comment">      Console.WriteLine(book.Currency);    */</span></span><br><span class="line"></span><br><span class="line">    Book book = <span class="keyword">new</span> Book() &#123; Name = <span class="string">&quot;.Net core&quot;</span>, Currency = CurrencyName.CNY &#125;;</span><br><span class="line">    Book book1 = <span class="keyword">new</span> Book() &#123; Name = <span class="string">&quot;React&quot;</span>, Currency = CurrencyName.USD &#125;;</span><br><span class="line">    ctx.Books.Add(book);</span><br><span class="line">    ctx.Books.Add(book1);</span><br><span class="line">    ctx.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完上面的测试代码以后，查看<code>Books</code>表中的<code>Currency</code>这个字段的值就变成了字符串的<code>CNY,USD</code></p>
<p>当然，一般情况下不需要进行该项的配置，除非就是让数据在数据库中展示的更加的清晰。</p>
<h2 id="13-2-值对象类型存储"><a href="#13-2-值对象类型存储" class="headerlink" title="13.2  值对象类型存储"></a>13.2  值对象类型存储</h2><p>在这一小节中，我们看一下值对象类型的存储。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Geo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Latitude &#123; <span class="keyword">get</span>; <span class="keyword">init</span>;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Longitude &#123; <span class="keyword">get</span>; <span class="keyword">init</span>;&#125;   </span><br><span class="line">         <span class="function"><span class="keyword">private</span> <span class="title">Geo</span>()</span> &#123; &#125; <span class="comment">// -----这里需要添加无参的构造方法。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Geo</span>(<span class="params"><span class="built_in">double</span> longitude,<span class="built_in">double</span> latitude</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(longitude&lt;<span class="number">-180</span>|| longitude &gt; <span class="number">180</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;longitude&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (latitude &lt; <span class="number">-90</span> || latitude &gt; <span class="number">90</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;latitude&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.Latitude = latitude;</span><br><span class="line">            <span class="keyword">this</span>.Longitude = longitude;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，定义了<code>Geo</code>这个值对象类型，并且有经度与维度，同时在构造方法中对传递过来的数据进行了合法性的校验。</p>
<p>然后完成了属性的赋值操作。</p>
<p>这里我们再创建一个<code>Shop.cs</code>商品实体类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>  Shop</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Geo? Location &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：这里商家的编号与商家的名称，我们没有按照充血模型中实体类属性的特性进行配置，主要为了简单。</p>
<p>这里的<code>Location</code>属性就是商家的地址坐标位置，对应的类型<code>Geo</code>这个值对象类型。</p>
<p>如果需要将该值对象存储到数据库中，需要对当前的<code>Shop</code>这个实体类进行配置。</p>
<p>创建<code>ShopConfig.cs</code>这个配置类，该类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShopConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Shop</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Shop&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.OwnsOne(x=&gt;x.Location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里通过<code>OwnsOne</code>方法指定了<code>Location</code>这个属性是当前<code>Shop</code>的一部分。</p>
<p>注意：这里也是为了操作简单，没有配置其他的内容。</p>
<p>为了进行测试，一定要注意在<code>TestDbContext</code>中添加一个<code> Shops这个DbSet类型的属性</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Person&gt; Persons &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Book&gt; Books &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;  </span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Shop&gt; Shops &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 添加Shops这个DbSet类型的属性</span></span><br></pre></td></tr></table></figure>

<p>下面进行数据库的迁移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration AddShop</span><br><span class="line"> Update-database</span><br></pre></td></tr></table></figure>

<p>查看数据库中对应的<code>Shops</code>表，发现<code>Geo</code>中定义的两个属性已经映射成了数据表中的字段了。</p>
<p>下面编写如下的测试代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx = <span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    Shop shop = <span class="keyword">new</span> Shop() &#123; Name=<span class="string">&quot;ABC&quot;</span>, Location=<span class="keyword">new</span> Geo(<span class="number">11</span>,<span class="number">12</span>) &#125;;</span><br><span class="line">     ctx.Shops.Add(shop);   </span><br><span class="line">    ctx.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取数据：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (TestDbContext ctx = <span class="keyword">new</span> TestDbContext())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/* Shop shop = new Shop() &#123; Name=&quot;ABC&quot;, Location=new Geo(11,12) &#125;;</span></span><br><span class="line"><span class="comment">     ctx.Shops.Add(shop);   </span></span><br><span class="line"><span class="comment">    ctx.SaveChanges();*/</span></span><br><span class="line">    <span class="comment">// 读取商家的名称以及坐标位置</span></span><br><span class="line">   Shop shop = ctx.Shops.First();   </span><br><span class="line">    Console.WriteLine(shop.Name+<span class="string">&quot;:&quot;</span>+shop.Location.Latitude+<span class="string">&quot;:&quot;</span>+shop.Location.Longitude);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，还需要补充一点，如果需要对<code>值对象</code>中的属性进行单独的配置，可以采用如下的方式</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShopConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">Shop</span>&gt;</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;Shop&gt; builder</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">/* builder.OwnsOne(x=&gt;x.Location);*/</span></span><br><span class="line">           <span class="comment">// 这里使用了OwnsOne中的第二个参数，是一个回调方法，在这回调方法中对属性进行了进一步的配置。当然，这里的double类型不需要指定最大长度，这里只是为了做一个说明</span></span><br><span class="line">           builder.OwnsOne(x =&gt; x.Location, b =&gt;</span><br><span class="line">           &#123;</span><br><span class="line">               b.Property(e =&gt; e.Latitude).HasMaxLength(<span class="number">50</span>);</span><br><span class="line">               b.Property(e=&gt;e.Longitude).HasMaxLength(<span class="number">50</span>).HasColumnType(<span class="string">&quot;decimal&quot;</span>); <span class="comment">// 数据表中的字段采用的是decimal类型</span></span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="14、-聚合在-Net中的实现"><a href="#14、-聚合在-Net中的实现" class="headerlink" title="14、 聚合在.Net中的实现"></a>14、 聚合在<code>.Net</code>中的实现</h1><p>聚合:高内聚，低耦合</p>
<p>把关系强的实体放到同一个聚合中，把其中一个实体作为聚合根</p>
<p>聚合的实现也非常的简单，在<code>EFCore</code>上下文中只为聚合根实体声明<code>DbSet</code>类型的属性，对于非聚合根实体，值对象的操作都通过根实体来进行。</p>
<p>这里我们再创建一个新的控制台项目进行演示。</p>
<p>创建一个商品实体类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 商品</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Proudct</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 商品价格</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个订单的实体类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 订单</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line">        <span class="keyword">public</span> DateTime CreateDateTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 订单总价</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> TotalAmount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> List&lt;OrderDetail&gt; Details &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;OrderDetail&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个订单详情的实体类</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 订单明细</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderDetail</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Order? Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Proudct? Proudct &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 买了多少个</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123;  <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>Order与OrderDetail</code>是一对多的关系，同时这两者之间也是聚合的关系，<code>Order</code>是聚合根。</p>
<p>同时在新创建的控制台程序中，安装<code>EFCore</code>响应的包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;/PropertyGroup&gt;</span><br><span class="line">	&lt;ItemGroup&gt;</span><br><span class="line">		&lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.SqlServer&quot; Version=&quot;7.0.3&quot; /&gt;</span><br><span class="line">		&lt;PackageReference Include=&quot;Microsoft.EntityFrameworkCore.Tools&quot; Version=&quot;7.0.3&quot;&gt;</span><br><span class="line">			&lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;</span><br><span class="line">			&lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;</span><br><span class="line">		&lt;/PackageReference&gt;</span><br><span class="line">	&lt;/ItemGroup&gt;</span><br><span class="line">&lt;/Project&gt;</span><br></pre></td></tr></table></figure>

<p>然后创建<code>MyDbContext.cs</code>类，该类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Order&gt;Orders &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Proudct&gt; Proudcts &#123; <span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=D1;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">            optionsBuilder.UseSqlServer(connStr);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到，在<code>MyDbContext</code>中定义的<code>DbSet</code>属性是<code>Orders,Products</code>，都是聚合根实体。</p>
<p>非聚合根<code>OrderDetail</code>，就不需要创建对应的<code>DbSet</code>属性了。</p>
<p>如果，现在要下订单，需要创建订单明细，应该怎样处理呢？</p>
<p>修改<code>Order.cs</code> 这个实体类中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line">        <span class="keyword">public</span> DateTime CreateDateTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 订单总价</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">double</span> TotalAmount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> List&lt;OrderDetail&gt; Details &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="keyword">new</span> List&lt;OrderDetail&gt;();</span><br><span class="line">    <span class="comment">// -------------------------- 添加了一个AddDetail方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDetail</span>(<span class="params">Proudct proudct,<span class="built_in">int</span> count</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 判断订单明细中是否有该商品</span></span><br><span class="line">            <span class="keyword">var</span> detail = Details.FirstOrDefault(d=&gt;d.Proudct==proudct);</span><br><span class="line">            <span class="keyword">if</span>(detail == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 没有进行添加</span></span><br><span class="line">                detail = <span class="keyword">new</span> OrderDetail() &#123; Proudct=proudct,Count=count &#125;;</span><br><span class="line">                Details.Add(detail);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 有进行累加</span></span><br><span class="line">                detail.Count += count;</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>怎样调用呢？</p>
<p>返回到<code>Program.cs</code>文件中，进行代码的修改：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ConsoleApp2;</span><br><span class="line"><span class="keyword">using</span> (MyDbContext ctx=<span class="keyword">new</span> MyDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.AddDetail(<span class="keyword">new</span> Proudct() &#123; Name = <span class="string">&quot;苹果&quot;</span>, Price = <span class="number">100</span> &#125;, <span class="number">5</span>);</span><br><span class="line">     ctx.Orders.Add(order);</span><br><span class="line">    ctx.SaveChanges();</span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面的测试，我们可以看到这里我们只是使用了聚合根</p>
<p>同时在聚合根<code>Order</code>中完成了对其他子实体的操作。</p>
<p>以上都是伪代码。</p>
<p><strong>总结:关于<code>.Net</code>中实现聚合：</strong></p>
<p><strong>第一：在聚合根实体中定义对聚合内的所有实体进行操作的方法，例如上面提到的的<code>AddDetail</code>方法。</strong></p>
<p><strong>第二：只在<code>DbContext</code>中为聚合根定义<code>DbSet</code>属性。</strong></p>
<p><strong>问题：怎样区分聚合根实体和其他实体呢？</strong></p>
<p>例如：上面定义的<code>Order和OrderDetail</code>，怎样能够很清晰的看出哪个实体就是聚合根实体呢？</p>
<p>这里我们可以定义一个不包含任何成员的标识接口（接口的名字随意命名），这个随意命名的接口，只是起到一个标识的作用。</p>
<p>然后要求所有的聚合根实体都要实现这个接口。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAgateRoot</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面我们创建了一个<code>IAgateRoot</code>的接口，该接口中没有任何的成员。</p>
<p>下面要求所有的聚合根实现该接口，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> 商品</span></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Proudct</span>:<span class="title">IAgateRoot</span> <span class="comment">// ---------------实现了IAgateRoot这个标识的接口</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 商品价格</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">double</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 订单</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span>:<span class="title">IAgateRoot</span> <span class="comment">// 这里的Order这个聚合根实体也实现了IAgateRoot这个标识接口</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p>聚合根虽然实现了<code>IAgateRoot</code>这个标识，但是不会影响到具体的实现。</p>
<p>如果后期由于业务的需求，我们实现了一个方法，只要求传递聚合根，可以定义成如下的泛型方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddMethod&lt;T&gt;(T t) where T:IAgateRoot</span><br></pre></td></tr></table></figure>



<p><strong>注意: 跨聚合进行实体引用，只能引用根实体，并且只能引用根实体的<code>Id</code>，而不是根实体对象。</strong></p>
<p>在前面我们所定义的订单明细实体<code>OrderDetail.cs</code>中，引用了聚合实体<code>Proudct</code>,但是这里需要注意的一点，就是最好不要直接使用<code>Proudct</code>这个实体类型。而是定义具体的<code>Id</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderDetail</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> Order? Order &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Name &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        public Proudct? Proudct &#123; get; set; &#125;*/</span></span><br><span class="line">    <span class="comment">// -------------------------引用根实体的id</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> ProudctId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 买了多少个</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Count &#123;  <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上只是通过伪代码，说明了概念，后面有具体的案例</p>
<h1 id="15、使用MediatR实现领域事件"><a href="#15、使用MediatR实现领域事件" class="headerlink" title="15、使用MediatR实现领域事件"></a>15、使用<code>MediatR</code>实现领域事件</h1><p>领域事件就是进程内事件，也就是一个微服务内的事件。</p>
<p>针对领域事件一般有两种实现方式：</p>
<p>第一种实现方式：传统的<code>C#</code>事件机制</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">event</span>  =  <span class="keyword">new</span> XXXEvent();</span><br><span class="line"><span class="keyword">event</span>.Completed+= event_Completed</span><br></pre></td></tr></table></figure>

<p>这种实现方式要求，事件的处理者被显式地注册到事件的发布者对象中，这种显式注册的方式不是很灵活。事件的发布和事件的处理之间的耦合性比较强</p>
<p>第二种方式：针对进程内的事件传递，可以使用<code>MediatR</code>这个开源库来完成。它可以实现事件的发布和事件的处理之间的解耦。</p>
<p><code>MediatR</code>中支持<code>一个发布者对应一个处理者</code>和<code>一个发布者对应多个处理者</code>两种模式。</p>
<p>后面这种模式使用的更加的广泛，所以这里我们就重点来看一下这种处理模式。</p>
<p>下面我们来看一下<code>MediatR</code>的使用。</p>
<p>第一步：创建一个<code>Asp.net Core</code>项目（这里我们创建一个<code>WebApi</code>的项目来演示）。创建好项目以后，在该项目中通过<code>NuGet</code>安装对应的包（注意：在安装的时候，一定要选择当前的<code>WebApi</code>项目）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package MediatR.Extensions.Microsoft.DependencyInjection</span><br></pre></td></tr></table></figure>

<p>第二步：在项目的<code>Program.cs</code>中调用调用<code>AddMediatR</code>方法，把<code>MediatR</code>相关的服务注册到容器中。</p>
<p><code>AddMediatR</code>方法的参数中一般指定<strong>事件处理者</strong>所在的若干个程序集。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddMediatR(Assembly.Load(&quot;程序集&quot;));</span><br></pre></td></tr></table></figure>

<p>在当前的案例中，事件处理者所在的程序集就是当前项目，所以这里的具体注册如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line">builder.Services.AddMediatR(Assembly.GetExecutingAssembly()); <span class="comment">// 注册MediatR,指定的事件处理者是当前的程序集，如果是分层项目，需要指定的就是事件处理者所在的类库项目的程序集</span></span><br></pre></td></tr></table></figure>

<p>第三步：</p>
<p>定义一个在事件的发布者和处理者之间进行数据传递的类，这个类我们假设就叫做<code>TestEvent</code>,这个类必须要实现<code>INotification</code>接口。</p>
<p>如下代码所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication1</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestEvent</span>:<span class="title">INotification</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestEvent</span>(<span class="params"><span class="built_in">string</span> UserName</span>)</span> &#123; </span><br><span class="line">          <span class="keyword">this</span>.UserName = UserName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>TestEvent</code>这个构造方法中的<code>UserName</code>参数表示的是登录用户的用户名。</p>
<p>第四步：发布事件</p>
<p>在需要发布事件的类中注入<code>IMediator</code>类型的服务，然后我们可以调用<code>Publish</code>方法来发布事件。</p>
<p>注意：这里调用的是<code>Publish</code>方法来发布事件，不要调用<code>Send</code>方法。<code>Send</code>方法也可以实现发布事件，但是<code>Send</code>方法是用来发布一对一事件的，而<code>Publish</code>方法是用来发布一对多事件的。</p>
<p>创建一个<code>TestController</code>控制器，该控制器中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">   [<span class="meta">ApiController</span>]</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestsController</span> : <span class="title">ControllerBase</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">readonly</span> IMediator mediator; <span class="comment">// 注入IMediator</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">TestsController</span>(<span class="params">IMediator mediator</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       [<span class="meta">HttpGet</span>]</span><br><span class="line">       <span class="function"><span class="keyword">public</span>  <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Test</span>()</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 完成了用户的注册</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">// 发布事件（发送邮件）</span></span><br><span class="line">           <span class="keyword">await</span> mediator.Publish(<span class="keyword">new</span> TestEvent(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">           <span class="keyword">return</span> Ok(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>第五步：创建事件的处理者</p>
<p>事件的处理者要求实现<code>NotificationHandler&lt;TNotification&gt;</code></p>
<p>其中的泛型参数<code>TNotification</code>代表此事件处理者要处理的消息类型。所有<code>TNotification</code>类型的事件都会被事件处理者处理</p>
<p>我们编写两个事件处理者,来对发出的事件消息进行处理。</p>
<p>先创建一个<code>TestEventHanderl.cs</code>,该类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestEventHanderl</span> : <span class="title">NotificationHandler</span>&lt;<span class="title">TestEvent</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">TestEvent notification</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;123&quot;</span> +notification.UserName);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再创建一个事件处理者<code>TestEventHandler2.cs</code>,代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestEventHandler2</span> : <span class="title">NotificationHandler</span>&lt;<span class="title">TestEvent</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">TestEvent notification</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;555566&quot;</span> + notification.UserName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，进行测试，查看控制台中打印的结果。</p>
<p>如果我们使用<code>await</code>的方式来调用<code>Publish</code>方法，那么程序会等待所有的事件处理者的<code>Handle</code>方法执行完成后才继续向后执行，因此事件发布者和事件处理者的代码是运行在相同的调用堆栈中的，这样我们可以轻松地实现强一致性的事务。如果事件发布者不需要等待事件处理者的执行，那么我们可以不用<code>await</code>方法来调用Publish方法；即使我们需要使用<code>await</code>方法来调用Publish方法发布事件，如果某个事件处理者的代码执行太耗时，为了避免影响用户体验，我们也可以在事件处理者的<code>Handle</code>方法中异步执行事件的处理逻辑。如果我们选择不等待事件处理者，就要处理事务的最终一致性。</p>
<h1 id="16、EF-Core中发布领域事件的合适时机"><a href="#16、EF-Core中发布领域事件的合适时机" class="headerlink" title="16、EF Core中发布领域事件的合适时机"></a>16、<code>EF Core中</code>发布领域事件的合适时机</h1><p>在上一小节中，我们简单了解了<code>MediatR</code>的使用，问题是：我们什么时候发布领域事件呢?</p>
<p>例如：用户注册成功，我们就可以发布一个发送邮件的事件了。</p>
<p>为了进行说明，这里我们有重新创建了一个<code>WebApi</code>项目。</p>
<p>让后在项目中，把前面创建的<code>User</code>领域实体拷贝过来。对应的<code>DbContext</code>中的内容也拷贝过来进行说明</p>
<p><code>User.cs</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为Id是由数据库生成的自增字段，我们无法修改它的值，所以我们把Id属性修饰为init；</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;                    <span class="comment">//特征一</span></span><br><span class="line">                                                        <span class="comment">// CreatedDateTime（创建日期）在对象创建的时候初始化,之后我们就不能修改这个属性的值，因此我们同样把CreatedDateTime属性修饰为init</span></span><br><span class="line">        <span class="keyword">public</span> DateTime CreatedDateTime &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;  <span class="comment">//特征一</span></span><br><span class="line">                                                        <span class="comment">//  UserName（用户名）、Credit（积分）这两个属性可以由类内部的代码修改，因此我们把它们的set操作修饰为私有的</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;    <span class="comment">//特征一</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Credit &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>? passwordHash;                   <span class="comment">//特征三</span></span><br><span class="line">                                                        <span class="comment">// Remark（备注）是一个只读属性，它的值只能从数据库中读取</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>? remark;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Remark                           <span class="comment">//特征四</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> remark; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里要求Tag属性不被映射到数据库表中</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Tag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;                <span class="comment">//特征五</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">User</span>()                                  <span class="comment">//特征二</span></span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params"><span class="built_in">string</span> yhm</span>)                         <span class="comment">//特征二</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.UserName = yhm;</span><br><span class="line">            <span class="keyword">this</span>.CreatedDateTime = DateTime.Now;</span><br><span class="line">            <span class="keyword">this</span>.Credit = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeUserName</span>(<span class="params"><span class="built_in">string</span> newValue</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.UserName = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePassword</span>(<span class="params"><span class="built_in">string</span> newValue</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue.Length &lt; <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;密码太短&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.passwordHash = HashHelper.Hash(newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>UserConfig.cs</code>中的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore.Metadata.Builders;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">User</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;User&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Users&quot;</span>);</span><br><span class="line">            builder.Property(<span class="string">&quot;passwordHash&quot;</span>);<span class="comment">// 针对特征三的配置</span></span><br><span class="line">            builder.Property(u =&gt; u.Remark).HasField(<span class="string">&quot;remark&quot;</span>);<span class="comment">// 针对特征四的配置</span></span><br><span class="line">            builder.Ignore(u=&gt;u.Tag); <span class="comment">// 针对特征五的配置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>HashHelper.cs</code>中的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HashHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Hash</span>(<span class="params"><span class="built_in">string</span> input</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (MD5 md5Hash = MD5.Create())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] data = md5Hash.ComputeHash(Encoding.UTF8.GetBytes(input));</span><br><span class="line">                StringBuilder sBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; data.Length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sBuilder.Append(data[i].ToString(<span class="string">&quot;x2&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sBuilder.ToString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里还需要将<code>EFCore</code>的包安装一下（直接拷贝）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--------MediatR包------------&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;MediatR.Extensions.Microsoft.DependencyInjection&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;11.1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.AspNetCore.OpenApi&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;7.0.3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Swashbuckle.AspNetCore&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;6.4.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-----------EFCore的包----------&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.EntityFrameworkCore.SqlServer&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;7.0.3&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.EntityFrameworkCore.Tools&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;7.0.3&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PrivateAssets</span>&gt;</span>all<span class="tag">&lt;/<span class="name">PrivateAssets</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">IncludeAssets</span>&gt;</span>runtime; build; native; contentfiles; analyzers; buildtransitive<span class="tag">&lt;/<span class="name">IncludeAssets</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">PackageReference</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>TestDbContext.cs</code>中的代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里修改了数据库的名字，为`D2`</span></span><br><span class="line">            <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=D2;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">            optionsBuilder.UseSqlServer(connStr);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面进行数据库的迁移操作（一定要注意切换到新创建的项目后，进行数据的迁移操作）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration CreateUser</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>现在创建一个<code>UsersController.cs</code>控制器</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="keyword">using</span> (TestDbContext ctx = <span class="keyword">new</span> TestDbContext())</span><br><span class="line">        &#123;</span><br><span class="line">            ctx.Users.Add(user);</span><br><span class="line">            <span class="keyword">await</span> ctx.SaveChangesAsync();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里可以发送事件，表示用户添加成功了，</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ok(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在<code>SaveChangesAsync</code>方法执行完毕以后手动写发送事件的代码，但是问题是：如果新增用户的模块代码比较多，有可能漏掉发送事件的情况。</p>
<p>如果我们在<code>User.cs</code>这个实体类的构造方法中，发送事件的话，就可以解决这个问题。</p>
<p>假如：修改密码完成以后，也需要发送事件，这时候我们可以在<code>User.cs</code>这个实体类的<code>ChangePassword</code>这个方法中发布事件。</p>
<p>但是这种方式也有问题：</p>
<p>例如：如果在构造函数中发布事件，用户信息还没有保存到数据库中，也就是说事件发布的有点早（实际上就是<code>误报</code>）。</p>
<p>或者说，更改密码，更改用户信息的时候，发布事件，有可能会出现重复发布事件，因为这里我们说的是更改用户发布事件，也就是说，更改了用户的年龄，手机号等属性都会发送事件，而我们真正的需求可能仅仅是需要更改用户名的时候才会发送事件，</p>
<p>这里所采用的解决方案是：</p>
<p>我们可以把领域事件的发布延迟到上下文保存修改的时候，也就是实体类中只是注册要发布的领域事件，然后在上下文的<code>SaveChanges</code>方法被调用的时候，我们再发布领域事件。</p>
<p>领域事件是有聚合根进行管理的，因此我们定义了供聚合根进行事件注册的接口<code>IDomainEvents</code>.(这个接口不仅仅是标识了，还要在其中定义方法)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDomainEvents</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取注册的领域事件</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function">IEnumerable&lt;INotification&gt; <span class="title">GetDomainEvents</span>()</span>;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 注册领域事件</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventItem&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">AddDomainEvent</span>(<span class="params">INotification eventItem</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 清除注册的领域事件</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ClearDomainEvents</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了简化实体类的代码编写，我们编写了实现<code>IDomainEvents</code>接口的抽象实体类<code>BaseEntity.cs</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseEntity</span> : <span class="title">IDomainEvents</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;INotification&gt; DomainEvents = <span class="keyword">new</span> List&lt;INotification&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddDomainEvent</span>(<span class="params">INotification eventItem</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            DomainEvents.Add(eventItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearDomainEvents</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            DomainEvents.Clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IEnumerable&lt;INotification&gt; <span class="title">GetDomainEvents</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> DomainEvents;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面，就可以让<code>User.cs</code>这个实体类，继承上面所定义的<code>BaseEntity.cs</code>这个类。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span>:<span class="title">BaseEntity</span></span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure>

<p>下面创建一个新增用户后进行事件发布于事件处理之间进行数据传递的类<code>NewUserNotification.cs</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewUserNotification</span>:<span class="title">INotification</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> DateTime? CreatedAt &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NewUserNotification</span>(<span class="params"><span class="built_in">string</span> userName,DateTime dateTime</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.UserName = userName;</span><br><span class="line">            <span class="keyword">this</span>.CreatedAt = dateTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再创建一个更改用户后进行事件发布于事件处理之间进行数据传递的类<code>UserNameChangeNotification.cs</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserNameChangeNotification</span>:<span class="title">INotification</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? OldUserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? NewUserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserNameChangeNotification</span>(<span class="params"><span class="built_in">string</span> oldUserName,<span class="built_in">string</span> newUserName</span>)</span> &#123; </span><br><span class="line">          <span class="keyword">this</span>.OldUserName = oldUserName;   </span><br><span class="line">            <span class="keyword">this</span>.NewUserName = newUserName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>怎样进行事件的注册呢？</p>
<p>这里需要修改<code>User.cs</code>这个实体类中的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params"><span class="built_in">string</span> yhm</span>)                         <span class="comment">//特征二</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>.UserName = yhm;</span><br><span class="line">    <span class="keyword">this</span>.CreatedDateTime = DateTime.Now;</span><br><span class="line">    <span class="keyword">this</span>.Credit = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 注册事件（这里仅仅是注册了事件，并没有发布事件，所以不会存在`误报`的情况）</span></span><br><span class="line">    AddDomainEvent(<span class="keyword">new</span> NewUserNotification(yhm,<span class="keyword">this</span>.CreatedDateTime));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeUserName</span>(<span class="params"><span class="built_in">string</span> newValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 旧的用户名</span></span><br><span class="line">    <span class="built_in">string</span> oldUserName = <span class="keyword">this</span>.UserName;</span><br><span class="line">    <span class="comment">// 新用户名</span></span><br><span class="line">    <span class="keyword">this</span>.UserName = newValue;</span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    AddDomainEvent(<span class="keyword">new</span> UserNameChangeNotification(oldUserName,newValue));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，在<code>User</code>构造函数和<code>ChangeUserName</code> 方法中完成了相应的事件的注册。</p>
<p>下面我们需要修改<code>TestDbContext.cs</code>这个上下文类中的代码，这里重写<code>SaveChangesAsync</code>方法，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">SaveChangesAsync</span>(<span class="params">CancellationToken cancellationToken = <span class="literal">default</span></span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">      <span class="comment">// ChangeTracker:是上下文用来对实体类的变化进行追踪的对象</span></span><br><span class="line">      <span class="comment">// Entries&lt;IDomainEvents&gt;():获取所有实现了IDomainEvents接口的追踪实体类</span></span><br><span class="line">          <span class="keyword">var</span> domainEntities = <span class="keyword">this</span>.ChangeTracker.Entries&lt;IDomainEvents&gt;().Where(e =&gt; e.Entity.GetDomainEvents().Any());<span class="comment">// 获取所有的没有发布的事件，Any():用来确定序列中是否包含元素（是否有数据）</span></span><br><span class="line">         </span><br><span class="line">      <span class="comment">// 获取所有待发布的消息(通过循环嵌套的方式)</span></span><br><span class="line">         <span class="keyword">var</span> dominEvents = <span class="keyword">new</span> List&lt;INotification&gt;();</span><br><span class="line">          <span class="keyword">foreach</span> (<span class="keyword">var</span> domainEntity <span class="keyword">in</span> domainEntities)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">foreach</span>(<span class="keyword">var</span> entity <span class="keyword">in</span> domainEntity.Entity.GetDomainEvents())</span><br><span class="line">               &#123;</span><br><span class="line">                   dominEvents.Add(entity);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">      </span><br><span class="line">           domainEntities.ToList().ForEach(e=&gt;e.Entity.ClearDomainEvents());</span><br><span class="line">           <span class="keyword">foreach</span>(<span class="keyword">var</span> entity <span class="keyword">in</span> dominEvents)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">await</span> mediator.Publish(entity);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把消息的发布放到base.SaveChangesAsync方法之前，可以保证领域事件响应代码中的事务操作（有可能操作数据库）和 base.SaveChangesAsync中的代码在同一个事务中。</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">base</span>.SaveChangesAsync(cancellationToken); <span class="comment">// 注意await</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们重写了<code>DbContext</code>中的<code>SaveChangesAsync</code>方法。在调用父类的<code>SaveChangesAsync</code>方法保存数据修改之前，我们把所有实体类注册的领域事件发布出去。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">readonly</span> IMediator mediator; <span class="comment">// 注入IMediator</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">TestDbContext</span>(<span class="params">IMediator mediator</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">this</span>.mediator = mediator;   </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>下面我们创建对应的事件处理程序</p>
<p>创建一个<code>NewUserHandler.cs</code>，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NewUserHandler</span> : <span class="title">NotificationHandler</span>&lt;<span class="title">NewUserNotification</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">NewUserNotification notification</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;创建了用户&quot;</span> + notification.UserName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个<code>UserNameChangeHandler.cs</code>，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">WebApplication2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserNameChangeHandler</span> : <span class="title">NotificationHandler</span>&lt;<span class="title">UserNameChangeNotification</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">UserNameChangeNotification notification</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;用户名从<span class="subst">&#123;notification.OldUserName&#125;</span>变成了<span class="subst">&#123;notification.NewUserName&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：不要忘记需要在<code>Program.cs</code>文件中完成注入</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line">builder.Services.AddMediatR(Assembly.GetExecutingAssembly()); <span class="comment">// 将MediatR添加到容器中</span></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br></pre></td></tr></table></figure>

<p>下面修改<code>UsersController.cs</code>控制器中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">// 这里我们注入了`TestDbContext`</span></span><br><span class="line">       <span class="keyword">private</span> TestDbContext context;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">UsersController</span>(<span class="params">TestDbContext testDbContext</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">this</span>.context = testDbContext;</span><br><span class="line">       &#125;</span><br><span class="line">       [<span class="meta">HttpGet</span>] <span class="comment">// ----添加了HttpGet</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Test</span>()</span></span><br><span class="line">       &#123;</span><br><span class="line">           User user = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>); <span class="comment">// 会添加一个添加用户的事件</span></span><br><span class="line">           user.ChangeUserName(<span class="string">&quot;wangwu&quot;</span>);   <span class="comment">// 会添加一个更新用户名的事件</span></span><br><span class="line">           context.Users.Add(user);</span><br><span class="line">               <span class="keyword">await</span> context.SaveChangesAsync();</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> Ok(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里还需要再次修改<code>Program.cs</code>文件中的代码，将<code>TestDbContext</code>添加到容器中</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddMediatR(Assembly.GetExecutingAssembly());</span><br><span class="line"><span class="comment">// 添加TestDbContext</span></span><br><span class="line">builder.Services.AddDbContext&lt;TestDbContext&gt;(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> connStr = <span class="string">&quot;server=.;database=D2;uid=sa;password=123456;TrustServerCertificate=true&quot;</span>;</span><br><span class="line">    opt.UseSqlServer(connStr);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面还需要修改一下<code>TestDbContext.cs</code>文件中的代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IMediator mediator; <span class="comment">// 注入IMediator</span></span><br><span class="line">     	<span class="comment">// ------------由于是注入了TestDbContext,这里的构造方法中必须添加DbContextOptions，同时调用父类的构造方法，传递对应的参数options</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestDbContext</span>(<span class="params">DbContextOptions options, IMediator mediator</span>):<span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.mediator = mediator;   </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//--------------------这段代码需要注释掉，因为数据库链接字符串已经写到了AddDbContext方法中</span></span><br><span class="line">       <span class="comment">/* protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            string connStr = &quot;server=.;database=D2;uid=sa;password=123456;TrustServerCertificate=true&quot;;</span></span><br><span class="line"><span class="comment">            optionsBuilder.UseSqlServer(connStr);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br></pre></td></tr></table></figure>

<p>启动项目进行测试，查看数据库中已经保存了对应的用户信息。</p>
<p>同时控制台中展示了触发的事件内容。</p>
<h1 id="17、DDD实战案例"><a href="#17、DDD实战案例" class="headerlink" title="17、DDD实战案例"></a>17、<code>DDD</code>实战案例</h1><p>前面我们已经介绍了关于<code>DDD</code>中的常见的一些概念，但是没有演示它们在代码中的具体实现，也没有演示它们与充血模型、领域事件等的综合应用。本节中，我们将会通过实现一个项目案例来演示这些<code>DDD</code>概念的综合性技术落地。</p>
<p>这个案例是一个包含用户管理、用户登录功能等待的微服务。</p>
<p>为了简化问题，这个案例中没有对接口调用进行鉴权</p>
<h2 id="17-1-项目分层"><a href="#17-1-项目分层" class="headerlink" title="17.1 项目分层"></a>17.1 项目分层</h2><p>这个案例分为<code>Users.Domain</code>、<code>Users.Infrastructure</code>、<code>Users.WebAPI</code>这3个项目</p>
<p><code>Users.Domain</code>是领域层项目，主要包含实体类、值对象、领域事件数据类、领域服务、仓储接口</p>
<p><code>Users.Infrastructure</code>是基础设施项目，主要包含实体类的配置、上下文类的定义、仓储服务的实现，基础工具类等</p>
<p><code>Users.WebAPI是ASP.NET Web API</code>项目，主要包含应用服务(这里的<code>webapi</code>就是应用服务)、<code>Controlle</code>r类、领域事件处理者、数据校验、权限校验、工作单元、事务处理等代码</p>
<p><strong>这里的项目拆分并不是必须遵守的规范，不同的项目有不同的拆分方法</strong>。</p>
<p>领域模型不应该和具体的数据库耦合，因此<code>Users.Domain</code>项目中只定义了实体类、值对象，而上下文类、实体类的配置等和具体的数据库相关的代码被定义在<code>Users.Infrastructure</code>项目中。领域服务是和领域模型相关的，因此<code>UserDomainService</code>被定义在<code>Users.Domain</code>项目中。<code>UserDomainService</code>需要调用仓储功能来获取数据、保存数据，因此体现仓储功能的接口<code>IUserDomainRepository</code>也被定义在<code>Users.Domain</code>项目中。由于仓储的具体实现是和具体数据库相关的，因此仓储接口<code>IUserDomainRepository</code>的实现类<code>UserDomainRepository</code>被定义在<code>Users.Infrastructure</code>项目中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images%5C332.png"></p>
<h2 id="17-2-领域模型的实现"><a href="#17-2-领域模型的实现" class="headerlink" title="17.2 领域模型的实现"></a>17.2 领域模型的实现</h2><p>先创建一个空白的解决方案<code>UserMgr</code></p>
<p>然后在创建一个类库项目<code>UserMgr.Domain</code>,在该类库项目中创建领域模型。</p>
<p>本小节中，我们将实现实体类、值对象等基础的领域模型，并且识别和定义出聚合及聚合根，这是<code>DDD</code>的战术起点。这些代码都位于<code>Users.Domain</code>项目中。</p>
<p>1、作为一个用户管理系统，“用户”（User）是我们识别出的第一个实体类；“用户登录失败次数过多则锁定”这个需求并不属于“用户”这个实体类中一个常用的特征，我们应当把它拆分到一个单独的实体类中，因此我们识别出一个单独的<strong>“用户登录失败”（<code>UserAccessFail</code>）实体类</strong>（失败的信息需要保存到数据库中）；为什么说<code>用户登录失败次数过多被锁定</code>并不是<code>用户</code>这个实体类中一个常用的特征呢？因为，这个需求仅仅是在用户登录的时候使用，当后面，其他业务场景是使用不到的，例如，获取用户下的订单等。</p>
<p>2、“用户登录记录”，什么时候登录的，也需要保存到数据库中，是一种业务日志的行为，这里也将其单独的设计为一个实体(<code>**UserLoginHistory**</code>)。</p>
<p><strong>当实体分析完以后，下面分析的就是聚合根</strong></p>
<p>3、这里将<code>User</code>和<code>UserAccessFail</code>设计为同一个聚合，因为<code>User和UserAccessFail</code>的关系是非常紧密的，<code>UserAccessFail</code>不会独立于<code>User</code>存在，而且我们只有访问到<code>User</code>的时候才会访问<code>UserAccessFail</code>,因此将<code>User</code>和<code>UserAccessFail</code>设计为同一个聚合，并且把<code>User</code>设置为聚合根。</p>
<p>由于我们有单独查询一段时间内的登录记录等独立于某个用户的需求，因为我们将<code>UserLoginHistory</code>设计为一个单独的聚合。</p>
<p>当然，这里如果你的需求是查询某个用户登录的信息，可以将<code>UserLoginHistory</code>和<code>User</code>设计为同一个聚合。</p>
<p>并没有固定的答案，一切以需求为主。</p>
<p>4、关于<code>DbContext</code>不会定义在领域层项目中，而是定义在基础设施项目中。</p>
<p>5、我们的系统中需要保存手机号，由于该系统可能被海外用户访问，而海外用户的手机号还需要包含“国家&#x2F;地区码”，因此我们设计了用来表示手机号的值对象<code>PhoneNumber</code></p>
<p>6、为了区分聚合根实体类和普通实体类，我们定义了不包含任何成员的标识接口<code>IAggregateRoot</code>，并且让所有的聚合根实体类实现这个接口。</p>
<p>在<code>UserMgr.Domain</code>这个项目中，创建<code>Entities</code>文件夹，在该文件夹中存放对应的实体类</p>
<p>首先创建标识聚合根实体类的标识接口<code>IAggregateRoot.cs</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain.Entities</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAggregateRoot</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建<code>User.cs</code>这个实体类(只是完成了实体状态的更改)</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain.Entities</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span>:<span class="title">IAggregateRoot</span> <span class="comment">// 实现了IAggregateRoot接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 标识--只读</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>  手机号可以修改，但是只能在本类中修改</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> PhoneNumber PhoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span>? passwordHash; <span class="comment">// 密码散列值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> UserAccessFail UserAccessFail &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">User</span>()</span> &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params">PhoneNumber phoneNumber</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.PhoneNumber = phoneNumber;</span><br><span class="line">           <span class="comment">// 表示当前用户登录失败</span></span><br><span class="line">            <span class="keyword">this</span>.UserAccessFail = <span class="keyword">new</span> UserAccessFail(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 判断是否设置了密码</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">HasPassword</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">string</span>.IsNullOrWhiteSpace(<span class="keyword">this</span>.passwordHash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 修改密码</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;password&quot;&gt;</span>传递过来的新密码<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePassword</span>(<span class="params"><span class="built_in">string</span> password</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (password.Length &lt;=<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;密码长度必须大于3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.passwordHash =HashHelper.Hash(password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 判断密码是否输入正确</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;password&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CheckPassword</span>(<span class="params"><span class="built_in">string</span> password</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.passwordHash == HashHelper.Hash(password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 修改手机号码</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangePhoneNumber</span>(<span class="params">PhoneNumber phoneNumber</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.PhoneNumber = phoneNumber;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建<code>UserAccessFail.cs</code>实体类，表示登录失败</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain.Entities</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserAccessFail</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> User User &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用户编号，也可以不用添加，添加上更加清晰</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> UserId &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 是否被锁定，由于只在本类中使用，直接定义成私有的成员变量</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">bool</span> isLockOut &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 被锁定结束日期</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> DateTime? LockEnd &#123; <span class="keyword">get</span>;<span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 登录失败次数</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> AccessFailCount &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 为EFCore使用</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">UserAccessFail</span>()</span> &#123; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 为程序员使用</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;user&quot;&gt;</span>表示哪个用户登录失败<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserAccessFail</span>(<span class="params">User user</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.User = user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 重置方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Rest</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.AccessFailCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.LockEnd = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.isLockOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 登录失败的处理</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fail</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.AccessFailCount++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.AccessFailCount &gt;= <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.isLockOut  = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 锁定5分钟</span></span><br><span class="line">                <span class="keyword">this</span>.LockEnd= DateTime.Now.AddMinutes(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 是否已经锁定</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsLockOut</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLockOut)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (LockEnd &gt;= DateTime.Now)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Rest();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>HashHelper.cs</code>这个负责加密密码的类，也放在了<code>Entities</code>文件夹中，当然，该类实际上应该放在基础项目中，这里为了简单，所以放在了<code>Entities</code>文件夹中。</p>
<p>创建<code>UserLoginHistory.cs</code>类，表示用户登录的记录。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain.Entities</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserLoginHistory</span>:<span class="title">IAggregateRoot</span> <span class="comment">// 实现IAggregateRoot接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">long</span>? UserId &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; <span class="comment">// 用户编号 ,这里设置为可为空的原因是，用户输入的手机号是错误的，就没有对应的用户编号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> PhoneNumber PhoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; <span class="comment">// 手机号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> DateTime CreateDateTime &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; <span class="comment">// 时间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Message &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125; <span class="comment">// 消息</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">UserLoginHistory</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserLoginHistory</span>(<span class="params"><span class="built_in">long</span> userId,PhoneNumber phoneNumber,<span class="built_in">string</span> message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.UserId = userId;   </span><br><span class="line">            <span class="keyword">this</span>.PhoneNumber = phoneNumber;</span><br><span class="line">            <span class="keyword">this</span>.Message = message; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：这里有一个属性<code>UserId</code>，表示用户的编号，是外键。</p>
<p>这里没有添加<code>User</code>类型的属性，原因是：当前的<code>UserLoginHistory</code>类，也是一个聚合根实体，为了以后拆分微服务的方便，只是添加了<code>UserId</code>属性。</p>
<p>当然前面我们所创建的<code>UserAccessFail.cs</code>类中确有<code>User</code>类型的属性，原有是<code>UserAccessFail类与User类</code>是同一个聚合，即使以后进行微服务的拆分，两者也不会进行拆分，就是因为这两个类是同一个聚合。</p>
<p>最后在<code>UserMgr.Domain</code>项目中，创建一个<code>ValueObjects</code>文件夹，存放值对象<code>PhoneNumber.cs</code>。</p>
<p>代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain.ValueObjects</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhoneNumber</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> RegionNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; <span class="comment">// 地区号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? PnoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于领域模型在这里创建完毕。</p>
<h2 id="17-3-领域服务的实现"><a href="#17-3-领域服务的实现" class="headerlink" title="17.3  领域服务的实现"></a>17.3  领域服务的实现</h2><p>领域服务需要使用仓储接口来通过持久层读写数据，因此我们需要在<code>Users.Domain</code>项目中编写仓储接口<code>IUserRepository</code></p>
<p>具体代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUserRepository</span></span><br><span class="line">    &#123; </span><br><span class="line">        </span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据手机号码查询用户信息</span></span><br><span class="line">        <span class="keyword">public</span> Task&lt;User?&gt; FindOneAsync(PhoneNumber phoneNumber);</span><br><span class="line">        <span class="comment">// 根据用户编号查询用户信息</span></span><br><span class="line">        <span class="keyword">public</span> Task&lt;User?&gt; FindOneAsync(<span class="built_in">long</span> userId);</span><br><span class="line">		<span class="comment">// 添加用户登录的日志信息</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">AddNewLoginHistoryAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> message</span>)</span>;</span><br><span class="line">	   <span class="comment">// 保存手机验证码</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">SavePhoneNumberCodeAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> code</span>)</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//用于获取保存的短信验证码。</span></span><br><span class="line">        <span class="keyword">public</span> Task&lt;<span class="built_in">string</span>?&gt; RetrievePhoneCodeAsync(PhoneNumber phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，在<code>Users.Domain</code>项目中创建一个发送短信的接口</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISmsCodeSender</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Task <span class="title">SendCodeAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> code</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实体类中定义的方法只是和特定实体类相关的业务逻辑代码，而跨实体类、跨聚合的代码需要定义在领域服务或者应用服务中。因此我们编写领域服务<code>UserDomainService.cs</code></p>
<p>在<code>UserMgr.Domain</code>项目中创建<code>UserDomainServer.cs</code>文件</p>
<p>代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> UserMgr.Domain.Entities;</span><br><span class="line"><span class="keyword">using</span> UserMgr.Domain.ValueObjects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDomainService</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IUserRepository _userRepository;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> ISmsCodeSender _smsSender;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserDomainService</span>(<span class="params">IUserRepository userRepository, ISmsCodeSender smsSender</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">this</span>. _userRepository = userRepository;</span><br><span class="line">           <span class="keyword">this</span>. _smsSender = smsSender;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检测用户登录</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;UserAccessResult&gt; <span class="title">CheckLoginAsync</span>(<span class="params">PhoneNumber phoneNumber,<span class="built_in">string</span> password</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            User? user = <span class="keyword">await</span> _userRepository.FindOneAsync(phoneNumber);</span><br><span class="line">            UserAccessResult result;</span><br><span class="line">            <span class="comment">// 根据手机号没有找到用户</span></span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                result = UserAccessResult.PhoneNumberNotFound;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsLockOut(user)) <span class="comment">//用户被锁定</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = UserAccessResult.Lockout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (user.HasPassword() == <span class="literal">false</span>)<span class="comment">//没设密码</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = UserAccessResult.NoPassword;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (user.CheckPassword(password))<span class="comment">//密码正确</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = UserAccessResult.OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//密码错误</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = UserAccessResult.PasswordError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == UserAccessResult.OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.ResetAccessFail(user);<span class="comment">//重置</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.AccessFail(user);<span class="comment">//处理登录失败</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送验证码</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;UserAccessResult&gt; <span class="title">SendCodeAsync</span>(<span class="params">PhoneNumber phoneNum</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> user = <span class="keyword">await</span> _userRepository.FindOneAsync(phoneNum);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> UserAccessResult.PhoneNumberNotFound;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IsLockOut(user))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> UserAccessResult.Lockout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> code = Random.Shared.Next(<span class="number">1000</span>, <span class="number">9999</span>).ToString();</span><br><span class="line">            <span class="keyword">await</span> _userRepository.SavePhoneNumberCodeAsync(phoneNum, code);</span><br><span class="line">            <span class="keyword">await</span> _smsSender.SendCodeAsync(phoneNum, code);</span><br><span class="line">            <span class="keyword">return</span> UserAccessResult.OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 检测验证码</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNum&quot;&gt;</span>手机号码<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span>验证码<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;CheckCodeResult&gt; <span class="title">CheckCodeAsync</span>(<span class="params">PhoneNumber phoneNum, <span class="built_in">string</span> code</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> user = <span class="keyword">await</span> _userRepository.FindOneAsync(phoneNum);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.PhoneNumberNotFound;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (IsLockOut(user))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.Lockout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据手机号查询已经保存的验证码</span></span><br><span class="line">            <span class="built_in">string</span>? codeInServer = <span class="keyword">await</span> _userRepository.RetrievePhoneCodeAsync(phoneNum);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrWhiteSpace(codeInServer))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.CodeError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (code == codeInServer)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                AccessFail(user);</span><br><span class="line">                <span class="keyword">return</span> CheckCodeResult.CodeError;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">IsLockOut</span>(<span class="params">User user</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> user.UserAccessFail.IsLockOut();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AccessFail</span>(<span class="params">User user</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            user.UserAccessFail.Fail();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetAccessFail</span>(<span class="params">User user</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            user.UserAccessFail.Rest();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上就是在领域服务中实现的业务逻辑，具体的业务逻辑都是在领域服务中实现</p>
<p>同时在<code>UserMgr.Domain</code>类库项目中<code>UserAccessResult</code>和<code>CheckCodeResult</code>枚举。</p>
<p><code>CheckCodeResult</code>枚举中的代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> CheckCodeResult</span><br><span class="line">    &#123;</span><br><span class="line">        OK, PhoneNumberNotFound, Lockout,CodeError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>UserAccessResult</code>枚举中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">enum</span> UserAccessResult</span><br><span class="line">    &#123;</span><br><span class="line">        OK, PhoneNumberNotFound, Lockout, NoPassword, PasswordError</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是领域服务中的代码，完整的封装了对应的业务逻辑。</p>
<p>最后一个问题就是领域事件的实现，为了简单，这里我们也是定义了领域层项目中。</p>
<p>当然，这里也是在接口中定义一个对应的方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUserRepository</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">public</span> Task&lt;User?&gt; FindOneAsync(PhoneNumber phoneNumber);</span><br><span class="line">       <span class="keyword">public</span> Task&lt;User?&gt; FindOneAsync(<span class="built_in">long</span> userId);</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Task <span class="title">AddNewLoginHistoryAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Task <span class="title">SavePhoneNumberCodeAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> code</span>)</span>;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//方法用于获取保存的短信验证码。</span></span><br><span class="line">       <span class="keyword">public</span> Task&lt;<span class="built_in">string</span>?&gt; RetrievePhoneCodeAsync(PhoneNumber phoneNumber);</span><br><span class="line">       <span class="comment">// --------------------发布领域事件</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Task <span class="title">PublishEventAsync</span>(<span class="params">UserAccessResultEvent eventData</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>UserAccessResultEvent</code>类中的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Domain.Events</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserAccessResultEvent</span>: <span class="title">INotification</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> PhoneNumber PhoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> UserAccessResult UserAccessResult &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserAccessResultEvent</span>(<span class="params">PhoneNumber phoneNumber, UserAccessResult userAccessResult</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.PhoneNumber = phoneNumber;</span><br><span class="line">            <span class="keyword">this</span>.UserAccessResult = userAccessResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当校验完登录用户的信息以后，发布领域事件,修改<code>UserDomainService.cs</code>类中的<code>CheckLoginAsync</code>方法中的代码</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span> (result == UserAccessResult.OK)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">this</span>.ResetAccessFail(user);<span class="comment">//重置</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">this</span>.AccessFail(user);<span class="comment">//处理登录失败</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// -----------------发布领域事件</span></span><br><span class="line">          UserAccessResultEvent eventItem = <span class="keyword">new</span>(phoneNumber, result);</span><br><span class="line">          <span class="keyword">await</span> _userRepository.PublishEventAsync(eventItem);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>在类库项目中安装<code>MediatR</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package MediatR.Extensions.Microsoft.DependencyInjection</span><br></pre></td></tr></table></figure>



<h2 id="17-4-基础设施的实现"><a href="#17-4-基础设施的实现" class="headerlink" title="17.4  基础设施的实现"></a>17.4  基础设施的实现</h2><h3 id="17-4-1、实体类配置"><a href="#17-4-1、实体类配置" class="headerlink" title="17.4.1、实体类配置"></a><strong>17.4.1、实体类配置</strong></h3><p>在领域层项目中，实现了领域模型，领域服务还有仓储的接口。而在基础设施项目中，要完成实体类的配置、上下文类的定义、仓储服务的实现等操作。</p>
<p>在解决方法方案中创建一个新的类库项目<code>UserMgr.Infrastructure</code></p>
<p><strong>该类库项目要引用一下<code>UserMgr.Domain</code>项目</strong></p>
<p>同时在<code>UserMgr.Infrastructure</code>这个基础设施的项目中安装<code>EFCore</code> 需要的包。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!---安装EFCore对应的包---&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.EntityFrameworkCore.SqlServer&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;7.0.3&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.EntityFrameworkCore.Tools&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;7.0.3&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PrivateAssets</span>&gt;</span>all<span class="tag">&lt;/<span class="name">PrivateAssets</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">IncludeAssets</span>&gt;</span>runtime; build; native; contentfiles; analyzers; buildtransitive<span class="tag">&lt;/<span class="name">IncludeAssets</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">PackageReference</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在项目中创建<code>Configs</code>文件夹，然后在该文件夹中 创建<code>UserConfig.cs</code>类，完成对<code>User.cs</code>实体类的配置操作。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Infrastructure.Configs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">User</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;User&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_Users&quot;</span>);</span><br><span class="line">            <span class="comment">// 配置值对象，将RegionNumber和PnoneNumber作为两个字段</span></span><br><span class="line">            builder.OwnsOne(x =&gt; x.PhoneNumber, nb =&gt; &#123;</span><br><span class="line">                nb.Property(x =&gt; x.RegionNumber).HasMaxLength(<span class="number">5</span>);</span><br><span class="line">                nb.Property(x =&gt; x.PnoneNumber).HasMaxLength(<span class="number">20</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            builder.Property(<span class="string">&quot;passwordHash&quot;</span>).HasMaxLength(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">// 配置一对多的关系（这里的User与UserAccessFail是一对多关系，但是这里并没有配置User与UserLoginHistory一对多关系，而在UserLoginHistory.cs中是有外键UserId的，没有配置强制性外键关系的原因是，考虑到UserLoginHistory有可能拆分到不同的微服务中，为了拆分方便,没有强制性的建立外键关系，不同的微服务有可能对应不同的数据库）</span></span><br><span class="line">            builder.HasOne(x =&gt; x.UserAccessFail).WithOne(x =&gt; x.User)</span><br><span class="line">                .HasForeignKey&lt;UserAccessFail&gt;(x =&gt; x.UserId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：聚合内的外键可以强制性建立，但是聚合之间的不建议强制性的建立外键关系。</p>
<p>下面在<code>Configs</code>文件夹下面创建<code>UserLoginHistoryConfig.cs</code>，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Infrastructure.Configs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserLoginHistoryConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">UserLoginHistory</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;UserLoginHistory&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_UserLoginHistories&quot;</span>);</span><br><span class="line">            <span class="comment">// 针对值对象的配置</span></span><br><span class="line">            builder.OwnsOne(x =&gt; x.PhoneNumber, nb =&gt; &#123;</span><br><span class="line">                nb.Property(x =&gt; x.RegionNumber).HasMaxLength(<span class="number">5</span>);</span><br><span class="line">                nb.Property(x =&gt; x.PnoneNumber).HasMaxLength(<span class="number">20</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>Configs</code>文件夹下面创建<code>UserAccessFailConfig.cs</code>代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Infrastructure.Configs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserAccessFailConfig</span> : <span class="title">IEntityTypeConfiguration</span>&lt;<span class="title">UserAccessFail</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">EntityTypeBuilder&lt;UserAccessFail&gt; builder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            builder.ToTable(<span class="string">&quot;T_UserAccessFails&quot;</span>);</span><br><span class="line">           builder.Property(<span class="string">&quot;isLockOut&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="17-4-2-实现具体的仓储"><a href="#17-4-2-实现具体的仓储" class="headerlink" title="17.4.2 实现具体的仓储"></a>17.4.2 实现具体的仓储</h3><p>在实现具体的仓储的时候，会使用到<code>DbContext</code>，所以在<code>UserMgr.Infrastructure</code>这个项目中创建<code>UserDbContext.cs</code>，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Infrastructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserDbContext</span>:<span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;User&gt; Users &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;UserLoginHistory&gt; LoginHistories &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserDbContext</span>(<span class="params">DbContextOptions&lt;UserDbContext&gt; options</span>)</span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params">options</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">base</span>.OnModelCreating(modelBuilder);</span><br><span class="line">            modelBuilder.ApplyConfigurationsFromAssembly(<span class="keyword">this</span>.GetType().Assembly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里我们在创建<code>DbSet</code>属性的时候，只是创建了<code>User,UserLoginHistory</code>两个聚合的<code>DbSet</code>属性，没有创建<code>UserAccessFail</code>的<code>DbSet</code>属性,因为这里可以通过<code>User</code>这个聚合根来访问<code>UserAccessFail</code>.</p>
<p>下面实现具体的数据仓储<code>UserRepository.cs</code>中的代码（在<code>UserMgr.Infrastructure</code>项目中创建）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Infrastructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserRepository</span> : <span class="title">IUserRepository</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> UserDbContext dbCtx;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCache distCache;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IMediator mediator;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserRepository</span>(<span class="params">UserDbContext userDbContext, IDistributedCache distCache,IMediator mediator</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.dbCtx = userDbContext;</span><br><span class="line">            <span class="keyword">this</span>.distCache = distCache;</span><br><span class="line">            <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 添加用户登录的记录</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;message&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">AddNewLoginHistoryAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            User? user = <span class="keyword">await</span> FindOneAsync(phoneNumber); <span class="comment">// 调用下面定义的FindOneAsync方法，根据手机号查询用户信息</span></span><br><span class="line">            <span class="built_in">long</span> userId = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                userId= user.Id;</span><br><span class="line">            &#125;</span><br><span class="line">            dbCtx.LoginHistories.Add(<span class="keyword">new</span> UserLoginHistory(userId,phoneNumber,message));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据手机号查询用户信息</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;User?&gt; FindOneAsync(PhoneNumber phoneNumber)</span><br><span class="line">        &#123;</span><br><span class="line">          User? user =  <span class="keyword">await</span> dbCtx.Users.FirstOrDefaultAsync(u =&gt; u.PhoneNumber.RegionNumber == phoneNumber.RegionNumber &amp;&amp; u.PhoneNumber.PnoneNumber == phoneNumber.PnoneNumber);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据用户的编号查询用户</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;userId&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;User?&gt; FindOneAsync(<span class="built_in">long</span> userId)</span><br><span class="line">        &#123;</span><br><span class="line">            User? user = <span class="keyword">await</span> dbCtx.Users.FirstOrDefaultAsync(u=&gt;u.Id==userId);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 发布事件</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;eventData&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">PublishEventAsync</span>(<span class="params">UserAccessResultEvent eventData</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mediator.Publish(eventData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 根据手机号，查询对应的验证码</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="built_in">string</span>?&gt; RetrievePhoneCodeAsync(PhoneNumber phoneNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> fullNumber = phoneNumber.RegionNumber + phoneNumber.PnoneNumber;</span><br><span class="line">            <span class="built_in">string</span> cacheKey = <span class="string">$&quot;LoginByPhoneAndCode_Code_<span class="subst">&#123;fullNumber&#125;</span>&quot;</span>;</span><br><span class="line">            <span class="built_in">string</span>? code =<span class="keyword">await</span> distCache.GetStringAsync(cacheKey);</span><br><span class="line">            distCache.Remove(cacheKey);  <span class="comment">// 从缓存中获取对应的验证码以后，就将其从缓存中移除。</span></span><br><span class="line">            <span class="keyword">return</span> code;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 保存手机验证码</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;phoneNumber&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;code&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">SavePhoneNumberCodeAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> code</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> fullNumber = phoneNumber.RegionNumber + phoneNumber.PnoneNumber;</span><br><span class="line">            <span class="keyword">var</span> options = <span class="keyword">new</span> DistributedCacheEntryOptions();</span><br><span class="line">            options.AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(<span class="number">60</span>);</span><br><span class="line">           <span class="keyword">return</span>  distCache.SetStringAsync(<span class="string">$&quot;LoginByPhoneAndCode_Code_<span class="subst">&#123;fullNumber&#125;</span>&quot;</span>, code, options);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：<code>SavePhoneNumberCodeAsync</code>方法的作用保存手机号对应的验证码。</p>
<p>这里我们是将其存储到了分布式缓存中，当然，也可以存储到数据库中。</p>
<p>这里存储到分布式缓存中的目的：主要考虑的是缓存中可以设置过期时间，当时间到了以后，验证码就无效了。</p>
<p>如果将验证码存储到数据库中，还需要自己进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">什么是分布式的缓存</span><br><span class="line">分布式的缓存由多个应用程序服务器共享,缓存中的信息不存储在单独的 Web 服务器的内存中，并且缓存的数据可用于所有应用服务器。这具有几个优点：</span><br><span class="line"></span><br><span class="line">　　1、所有 Web 服务器上的缓存数据都是一致的。（用户不会因处理其请求的 Web 服务器的不同而看到不同的结果。）</span><br><span class="line"></span><br><span class="line">　　2、缓存的数据在 Web 服务器重新启动后和部署后仍然存在。 （删除或添加单独的 Web 服务器不会影响缓存。）</span><br><span class="line"></span><br><span class="line">　　3、对数据库的请求变的更少 。</span><br><span class="line"></span><br><span class="line"> 像其它缓存一样，分布式缓存可以显著提高应用的响应速度，因为通常情况下，数据从缓存中检索比从关系数据库（或 Web 服务）中检索快得多。</span><br><span class="line"></span><br><span class="line">缓存配置是特定于实现的。 本文介绍如何配置 Redis、 mongoDB 和 SQL Server 分布式缓存。 无论选择哪一种实现，应用都使用通用的 IDistributedCache 接口与缓存交互。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后在<code>UserMgr.Infrastructure</code>项目中创建一个<code>MockSmsCodeSender.cs</code>来实现<code>ISmsCodeSender</code>这个接口，用来发送短信验证码，这里只是模拟实现。很多云服务提供厂商，会提供发送短信的接口。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.Infrastructure</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MockSmsCodeSender</span> : <span class="title">ISmsCodeSender</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">SendCodeAsync</span>(<span class="params">PhoneNumber phoneNumber, <span class="built_in">string</span> code</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;向<span class="subst">&#123;phoneNumber.PnoneNumber&#125;</span>发送验证码<span class="subst">&#123;code&#125;</span>&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="18、-工作单元"><a href="#18、-工作单元" class="headerlink" title="18、  工作单元"></a>18、  工作单元</h1><p>关于工作单元，我们前面也给大家做过介绍。</p>
<p>这里的工作单元和以前是一样的。（保证所有的操作要么都成功，要么都失败。）</p>
<p>在<code>DDD</code>的设计思想中，工作单元是由应用服务层来完成的，其他层不应该调用<code>SaveChangesAsync</code>方法来保存对数据的修改操作。</p>
<p>原因：就是因为应用层可以保证一次请求的完整实现。</p>
<p>我们把<code>Web API</code>的控制器当成应用服务，而且对于大部分应用场景来讲，一次对控制器中方法的调用就对应一个工作单元，因此我们可以开发一个在控制器的方法调用结束后自动调用<code>SaveChangesAsync</code>的机制。这样就能大大简化应用服务层代码的编写，从而避免对<code>SaveChangesAsync</code>方法的重复调用。当然，对于特殊的应用服务层代码，我们可能仍然需要手动决定调用<code>SaveChangesAsync</code>方法的时机。</p>
<p>创建一个<code>WebApi</code>项目，叫做<code>UserMgr.WebApi</code>,并且把该项目设置为启动的项目。</p>
<p>同时让该项目引用其他两个项目</p>
<p>在该<code>UserMgr.WebApi</code>项目中创建一个目录<code>Attributes</code>,在该目录下面创建一个<code>UnitOfWorkAttribute.cs</code>类，该类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.WebApi.Attributes</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Method)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitOfWorkAttribute</span>:<span class="title">Attribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> Type[] DbContextTypes &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnitOfWorkAttribute</span>(<span class="params">Type[] dbContextTypes</span>)</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.DbContextTypes = dbContextTypes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时在该<code>WebApi</code>项目中再创建一个文件夹，叫做<code>Filters</code>,在该文件夹中创建一个类叫做<code>UnitOfWorkFilter.cs</code>,该类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Controllers;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc.Filters;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> UserMgr.WebApi.Attributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.WebApi.Filters</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitOfWorkFilter</span> : <span class="title">IAsyncActionFilter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">OnActionExecutionAsync</span>(<span class="params">ActionExecutingContext context, ActionExecutionDelegate next</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> next();<span class="comment">// 执行完控制器中的方法了</span></span><br><span class="line">            <span class="keyword">if</span> (result.Exception != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">// 如果该条件成立，表示控制器中方法执行出现了错误，所以就没有必要执行SaveChanges方法了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下面要获取添加在控制器方法上的Attribute</span></span><br><span class="line">            <span class="keyword">var</span> actionDesc = context.ActionDescriptor <span class="keyword">as</span> ControllerActionDescriptor;</span><br><span class="line">            <span class="keyword">if</span> (actionDesc == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">// 表示无法转换，也会终止</span></span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">var</span> unAttr =  actionDesc.MethodInfo.GetCustomAttribute&lt;UnitOfWorkAttribute&gt;();</span><br><span class="line">            <span class="keyword">if</span> (unAttr == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">// 如果该条件成立，表示所执行的控制器的方法上没有添加UnitOfWorkAttribute，这里就会终止，没有必要在执行下面的SaveChanges方法了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从UnitOfWorkAttribute中的DbContextTypes数组中获取所保存的DbContext</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> dbCxtType <span class="keyword">in</span> unAttr.DbContextTypes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// -----------我们知道DbContext都是注入到容器中，所以这里需要从容器中获取,需要再WebApi项目中安装EFCore的包</span></span><br><span class="line">                <span class="keyword">var</span> dbCtx = context.HttpContext.RequestServices.GetService(dbCxtType) <span class="keyword">as</span> DbContext;</span><br><span class="line">                <span class="keyword">if</span> (dbCtx != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">await</span> dbCtx.SaveChangesAsync();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面修改<code>Program.cs</code>文件进行配置</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------注入DbContext,同时获取数据库链接字符串</span></span><br><span class="line">builder.Services.AddDbContext&lt;UserDbContext&gt;(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> connStr = builder.Configuration.GetConnectionString(<span class="string">&quot;StrConn&quot;</span>)!;</span><br><span class="line">    opt.UseSqlServer(connStr);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// --------------------完成Filter的注册</span></span><br><span class="line">builder.Services.Configure&lt;MvcOptions&gt;(c =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    c.Filters.Add&lt;UnitOfWorkFilter&gt;();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br></pre></td></tr></table></figure>

<p>下面，修改<code>appsettings.json</code>文件，添加数据库链接字符串</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;AllowedHosts&quot;: &quot;*&quot;,</span><br><span class="line">  &quot;ConnectionStrings&quot;: &#123;</span><br><span class="line">    &quot;StrConn&quot;: &quot;server=localhost;database=DDDApp;uid=sa;pwd=123456;TrustServerCertificate=true&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面要做的就是数据的迁移操作</p>
<p>在【程序包管理器控制台中】指定的是<code>[UserMgr.Infrastructure]</code>项目，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Add-Migration Init</span><br><span class="line">Update-database</span><br></pre></td></tr></table></figure>

<p>最后在控制器的对应方法上添加特性</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.WebApi.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">UnitOfWork(new Type[</span>] &#123; <span class="keyword">typeof</span>(UserDbContext)&#125;)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetUsers</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Ok(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里创建一个<code>UsersController</code>控制器</p>
<h1 id="19、应用层的实现"><a href="#19、应用层的实现" class="headerlink" title="19、应用层的实现"></a>19、应用层的实现</h1><h2 id="19-1、完成各项服务注入"><a href="#19-1、完成各项服务注入" class="headerlink" title="19.1、完成各项服务注入"></a>19.1、完成各项服务注入</h2><p>1、应用层主要进行的是数据的校验，请求数据的获取，领域服务返回结果的处理，并没有复杂的业务逻辑，因为主要的业务逻辑都被封装在领域层。</p>
<p>2、应用层是非常薄的一层，主要完成安全认证，权限校验，数据校验，事务控制，工作单元控制，领域服务等调用。从理论上来讲应用层中不应该有业务逻辑。</p>
<p>3、可以在应用层中监听领域事件（注意：这里是进行监听，事件的处理是在领域层完成的）</p>
<p>下面现在应用层，也就是<code>WebApi</code>项目中安装：</p>
<p><code>MediatR</code>包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package MediatR.Extensions.Microsoft.DependencyInjection</span><br></pre></td></tr></table></figure>

<p>并且在<code>Program.cs</code>文件中将其添加到容器中。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成MeditatR的注入</span></span><br><span class="line">builder.Services.AddMediatR(Assembly.GetExecutingAssembly());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br></pre></td></tr></table></figure>

<p>下面好需要将其他服务进行注册</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成MeditatR的注入</span></span><br><span class="line">builder.Services.AddMediatR(Assembly.GetExecutingAssembly());</span><br><span class="line">builder.Services.AddScoped&lt;UserDomainService&gt;(); <span class="comment">// 注入 UserDomainService   </span></span><br><span class="line">builder.Services.AddScoped&lt;IUserRepository, UserRepository&gt;(); <span class="comment">// 注入</span></span><br><span class="line">builder.Services.AddScoped&lt;ISmsCodeSender, MockSmsCodeSender&gt;(); <span class="comment">// 注入</span></span><br><span class="line">builder.Services.AddDistributedMemoryCache();<span class="comment">// 注入缓存，这里后面需要使用Redis</span></span><br></pre></td></tr></table></figure>

<p>这里我们先手动注入，当然，大家也可以使用前面我们所讲解的自动注入的方式。</p>
<h2 id="19-2-添加用户"><a href="#19-2-添加用户" class="headerlink" title="19.2  添加用户"></a>19.2  添加用户</h2><p>在<code>UsersController.cs</code>控制器中添加如下代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">   [<span class="meta">ApiController</span>]</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UsersController</span> : <span class="title">ControllerBase</span></span><br><span class="line">   &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// ----注入IUserRepository，UserDbContext</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">readonly</span> IUserRepository _userRepository;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">readonly</span> UserDbContext _userDbContext;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">UsersController</span>(<span class="params">IUserRepository userRepository,UserDbContext userDbContext</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>._userDbContext = userDbContext;</span><br><span class="line">           _userRepository = userRepository;   </span><br><span class="line">       &#125;    </span><br><span class="line">      </span><br><span class="line">       [<span class="meta">HttpGet</span>]</span><br><span class="line">       <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetUsers</span>()</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> Ok(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//------------------------- 添加用户</span></span><br><span class="line">       [<span class="meta">UnitOfWork(new Type[</span>] &#123; <span class="keyword">typeof</span>(UserDbContext) &#125;)] <span class="comment">// 保存用户信息</span></span><br><span class="line">       [<span class="meta">HttpPost</span>]</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">AddNewUser</span>(<span class="params">AddUserRequest req</span>) <span class="comment">// 需要定义AddUserRequest</span></span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 判断手机号码是否被占用</span></span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">await</span> _userRepository.FindOneAsync(req.PhoneNumber) != <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> BadRequest(<span class="string">&quot;手机号已经存在&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 创建User对象，需要传递手机号码</span></span><br><span class="line">           <span class="keyword">var</span> user = <span class="keyword">new</span> User(req.PhoneNumber);</span><br><span class="line">           <span class="comment">// 一定要调用ChangePassword方法，对密码进行加密</span></span><br><span class="line">           user.ChangePassword(req.Password);</span><br><span class="line">           <span class="comment">// 将用户信息添加到上下文中</span></span><br><span class="line">           _userDbContext.Users.Add(user);</span><br><span class="line">           <span class="keyword">return</span> Ok(<span class="string">&quot;添加用户完成&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到，在控制器（应用层）中直接使用了数据仓储和<code>DbContext</code>上下文，这里这样做的原因是：考虑到新增用户是简单的业务逻辑，所以这里就没有必要拘泥于<code>DDD</code>的设计原则，当然，也可以按照我们以前的方式进行设计。</p>
<p>同时在<code>WebApi</code>项目中创建<code>Dto</code>目录，在该目录中创建<code>AddUserRequest.cs</code>类，该类中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserMgr.Domain.ValueObjects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.WebApi.Dto</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AddUserRequest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> PhoneNumber PhoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;    </span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Password &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="19-3-用户登录"><a href="#19-3-用户登录" class="headerlink" title="19.3  用户登录"></a>19.3  用户登录</h2><p>这里创建一个新的控制器<code>LoginController.cs</code>，该控制器中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Http;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Mvc;</span><br><span class="line"><span class="keyword">using</span> UserMgr.Domain;</span><br><span class="line"><span class="keyword">using</span> UserMgr.Infrastructure;</span><br><span class="line"><span class="keyword">using</span> UserMgr.WebApi.Attributes;</span><br><span class="line"><span class="keyword">using</span> UserMgr.WebApi.Dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.WebApi.Controllers</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="string">&quot;api/[controller]&quot;</span>)</span>]</span><br><span class="line">    [<span class="meta">ApiController</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoginController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意-------UserDomainService</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> UserDomainService domainService;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">LoginController</span>(<span class="params">UserDomainService domainService</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.domainService = domainService;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//-------------完成用户登录</span></span><br><span class="line">        [<span class="meta">HttpPost</span>]</span><br><span class="line">        [<span class="meta">UnitOfWork(new Type[</span>] &#123; <span class="keyword">typeof</span>(UserDbContext) &#125;)]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">LoginByPhoneAndPwd</span>(<span class="params">LoginByPhoneAndPwdRequest req</span>) <span class="comment">// 需要定义LoginByPhoneAndPwdRequest</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (req.Password?.Length &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> BadRequest(<span class="string">&quot;密码的长度不能小于3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> phoneNum = req.PhoneNumber;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">await</span> domainService.CheckLoginAsync(phoneNum!, req.Password!);</span><br><span class="line">            <span class="keyword">switch</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.OK:</span><br><span class="line">                    <span class="keyword">return</span> Ok(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.PhoneNumberNotFound:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;手机号或者密码错误&quot;</span>);<span class="comment">//避免泄密</span></span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.Lockout:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;用户被锁定，请稍后再试&quot;</span>);</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.NoPassword:</span><br><span class="line">                <span class="keyword">case</span> UserAccessResult.PasswordError:</span><br><span class="line">                    <span class="keyword">return</span> BadRequest(<span class="string">&quot;手机号或者密码错误&quot;</span>);</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看到在应用服务中，只有信息的校验，对领域服务的调用，和领域服务返回结果的处理，没有其他的业务。</p>
<p>在<code>Dto</code>目录中创建<code>LoginByPhoneAndPwdRequest.cs</code>类，该类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UserMgr.Domain.ValueObjects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.WebApi.Dto</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoginByPhoneAndPwdRequest</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> PhoneNumber? PhoneNumber &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span>? Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还要有事件处理程序。</p>
<p>在<code>WebApi</code>项目中创建<code>Events</code>文件夹，在该文件夹中添加<code>UserAccessResultEventHandler.cs</code>类，该类中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MediatR;</span><br><span class="line"><span class="keyword">using</span> UserMgr.Domain;</span><br><span class="line"><span class="keyword">using</span> UserMgr.Domain.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UserMgr.WebApi.Events</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserAccessResultEventHandler</span> : <span class="title">INotificationHandler</span>&lt;<span class="title">UserAccessResultEvent</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里需要注入IUserRepository，用来保存用户登录的时候的信息。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IUserRepository repository;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UserAccessResultEventHandler</span>(<span class="params">IUserRepository repository</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.repository = repository;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">Handle</span>(<span class="params">UserAccessResultEvent notification, CancellationToken cancellationToken</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = notification.UserAccessResult;</span><br><span class="line">            <span class="keyword">var</span> phoneNum = notification.PhoneNumber;</span><br><span class="line">            <span class="built_in">string</span> msg;</span><br><span class="line">            <span class="keyword">switch</span> (result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Domain.UserAccessResult.OK:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登陆成功&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Domain.UserAccessResult.PhoneNumberNotFound:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登陆失败，因为用户不存在&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Domain.UserAccessResult.PasswordError:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登陆失败，密码错误&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Domain.UserAccessResult.NoPassword:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登陆失败，没有设置密码&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Domain.UserAccessResult.Lockout:</span><br><span class="line">                    msg = <span class="string">$&quot;<span class="subst">&#123;phoneNum&#125;</span>登陆失败，被锁定&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> repository.AddNewLoginHistoryAsync(phoneNum, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：由于这里是一个类，而不是具体的控制器，所以想保存数据，就需要注入<code>IUserRepository</code>，用来保存用户登录的时候的信息。</p>
<p>而不能使用<code>Filter</code>过滤器</p>
<p>最后还有一个问题需要注意：</p>
<p>在<code>UserMgr.Infrastructure</code>项目中的<code>UserRepository.cs</code>仓储中的<code>FindOneAsync方法中，要通过include关联UserAccessFail，才能够查询到用户登录失败的信息</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;User?&gt; FindOneAsync(PhoneNumber phoneNumber)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 添加了include</span></span><br><span class="line">  User? user =  <span class="keyword">await</span> dbCtx.Users.Include(u=&gt;u.UserAccessFail).FirstOrDefaultAsync(u =&gt; u.PhoneNumber.RegionNumber == phoneNumber.RegionNumber &amp;&amp; u.PhoneNumber.PnoneNumber == phoneNumber.PnoneNumber);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 根据用户的编号查询用户</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;userId&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;exception cref=&quot;NotImplementedException&quot;&gt;</span><span class="doctag">&lt;/exception&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;User?&gt; FindOneAsync(<span class="built_in">long</span> userId)</span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">// 添加了include</span></span><br><span class="line">    User? user = <span class="keyword">await</span> dbCtx.Users.Include(u=&gt;u.UserAccessFail).FirstOrDefaultAsync(u=&gt;u.Id==userId);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目进行测试。</p>
<p>先添加用户信息</p>
<p>然后再进行用户的登录。</p>
<p>其他的功能大家可以自行实现</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.kilgour.top">kilgour</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.kilgour.top/2024/09/03/%E8%80%81%E7%8E%8B-24%E3%80%81DDD/">http://www.kilgour.top/2024/09/03/%E8%80%81%E7%8E%8B-24%E3%80%81DDD/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.kilgour.top" target="_blank">Kilgour Notes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/08/15/%E8%80%81%E7%8E%8B-23%E3%80%81WPF/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kilgour</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kilg0ur"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DDD"><span class="toc-number">1.</span> <span class="toc-text">DDD</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">1、架构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">1.1  架构设计的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%9E%B6%E6%9E%84%E6%98%AF%E8%BF%9B%E5%8C%96%E8%80%8C%E6%9D%A5%E7%9A%84"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 架构是进化而来的</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">2、什么是微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 单体架构优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 微服务架构优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AF%AF%E5%8C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">2.3  微服务误区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFDDD"><span class="toc-number">4.</span> <span class="toc-text">3、什么是DDD</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E9%A2%86%E5%9F%9F%E4%B8%8E%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">4、领域与领域模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 什么是领域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">4.2  什么是领域模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%95%8C%E9%99%90%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">6.</span> <span class="toc-text">5、通用语言与界限上下文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%80%BC%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">6、实体与值对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%AE%9E%E4%BD%93%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.0.1.</span> <span class="toc-text">6.1 实体对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%80%BC%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.0.2.</span> <span class="toc-text">6.2 值对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E8%81%9A%E5%90%88%E4%B8%8E%E8%81%9A%E5%90%88%E6%A0%B9"><span class="toc-number">8.</span> <span class="toc-text">7、聚合与聚合根</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">9.</span> <span class="toc-text">8、领域服务与应用服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E4%B8%8E%E9%9B%86%E6%88%90%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">9、领域事件与集成事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">10、贫血模型与充血模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81EF-Core-%E5%AF%B9%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">12.</span> <span class="toc-text">11、EF Core 对实体类属性操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81-EF-Core%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">13.</span> <span class="toc-text">12、 EF Core中实现充血模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%89%B9%E5%BE%81%E8%AF%B4%E6%98%8E"><span class="toc-number">13.1.</span> <span class="toc-text">12.1  充血模型实体类特征说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E5%AE%9E%E7%8E%B0%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">13.2.</span> <span class="toc-text">12.2 实现充血模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81EF-Core%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%80%BC%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.</span> <span class="toc-text">13、EF Core中实现值对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">14.1.</span> <span class="toc-text">13.1   枚举类型的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8"><span class="toc-number">14.2.</span> <span class="toc-text">13.2  值对象类型存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81-%E8%81%9A%E5%90%88%E5%9C%A8-Net%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.</span> <span class="toc-text">14、 聚合在.Net中的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E3%80%81%E4%BD%BF%E7%94%A8MediatR%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6"><span class="toc-number">16.</span> <span class="toc-text">15、使用MediatR实现领域事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16%E3%80%81EF-Core%E4%B8%AD%E5%8F%91%E5%B8%83%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%88%E9%80%82%E6%97%B6%E6%9C%BA"><span class="toc-number">17.</span> <span class="toc-text">16、EF Core中发布领域事件的合适时机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17%E3%80%81DDD%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="toc-number">18.</span> <span class="toc-text">17、DDD实战案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E9%A1%B9%E7%9B%AE%E5%88%86%E5%B1%82"><span class="toc-number">18.1.</span> <span class="toc-text">17.1 项目分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.2.</span> <span class="toc-text">17.2 领域模型的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.3.</span> <span class="toc-text">17.3  领域服务的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-4-%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.4.</span> <span class="toc-text">17.4  基础设施的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-1%E3%80%81%E5%AE%9E%E4%BD%93%E7%B1%BB%E9%85%8D%E7%BD%AE"><span class="toc-number">18.4.1.</span> <span class="toc-text">17.4.1、实体类配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-2-%E5%AE%9E%E7%8E%B0%E5%85%B7%E4%BD%93%E7%9A%84%E4%BB%93%E5%82%A8"><span class="toc-number">18.4.2.</span> <span class="toc-text">17.4.2 实现具体的仓储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E3%80%81-%E5%B7%A5%E4%BD%9C%E5%8D%95%E5%85%83"><span class="toc-number">19.</span> <span class="toc-text">18、  工作单元</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">20.</span> <span class="toc-text">19、应用层的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#19-1%E3%80%81%E5%AE%8C%E6%88%90%E5%90%84%E9%A1%B9%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%85%A5"><span class="toc-number">20.1.</span> <span class="toc-text">19.1、完成各项服务注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-2-%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7"><span class="toc-number">20.2.</span> <span class="toc-text">19.2  添加用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-3-%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95"><span class="toc-number">20.3.</span> <span class="toc-text">19.3  用户登录</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By kilgour</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">2</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>