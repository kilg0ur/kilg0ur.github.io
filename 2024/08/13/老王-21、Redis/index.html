<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kilgour Notes | Kilgour Notes</title><meta name="author" content="kilgour"><meta name="copyright" content="kilgour"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis1、Redis简介redis是一个键值对的数据库。  值不仅可以是字符串，也可以是其他的类型，例如List集合Hash类型等。 从以上存储的数据结构可以看出与传统的SQLServer还是有很大的区别的，没有表，字段等。 像这种键值对结构的数据库我们统称为nosql数据库。 2、什么是NoSqlSQL: 关系型数据库 NoSql非关系型数据库   以上图展示的就是关系性数据库中表与表之间的">
<meta property="og:type" content="article">
<meta property="og:title" content="Kilgour Notes">
<meta property="og:url" content="http://www.kilgour.top/2024/08/13/%E8%80%81%E7%8E%8B-21%E3%80%81Redis/index.html">
<meta property="og:site_name" content="Kilgour Notes">
<meta property="og:description" content="Redis1、Redis简介redis是一个键值对的数据库。  值不仅可以是字符串，也可以是其他的类型，例如List集合Hash类型等。 从以上存储的数据结构可以看出与传统的SQLServer还是有很大的区别的，没有表，字段等。 像这种键值对结构的数据库我们统称为nosql数据库。 2、什么是NoSqlSQL: 关系型数据库 NoSql非关系型数据库   以上图展示的就是关系性数据库中表与表之间的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover11.jpeg">
<meta property="article:published_time" content="2024-08-12T16:01:28.399Z">
<meta property="article:modified_time" content="2024-08-13T03:49:41.969Z">
<meta property="article:author" content="kilgour">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover11.jpeg"><link rel="shortcut icon" href="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/logo.png"><link rel="canonical" href="http://www.kilgour.top/2024/08/13/%E8%80%81%E7%8E%8B-21%E3%80%81Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kilgour Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-13 11:49:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/panarama.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover11.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Kilgour Notes"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/logo.png"/><span class="site-name">Kilgour Notes</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-12T16:01:28.399Z" title="发表于 2024-08-13 00:01:28">2024-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-13T03:49:41.969Z" title="更新于 2024-08-13 11:49:41">2024-08-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h1 id="1、Redis简介"><a href="#1、Redis简介" class="headerlink" title="1、Redis简介"></a>1、<code>Redis</code>简介</h1><p><code>redis</code>是一个键值对的数据库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130002332.png"></p>
<p>值不仅可以是字符串，也可以是其他的类型，例如<code>List</code>集合<code>Hash</code>类型等。</p>
<p>从以上存储的数据结构可以看出与传统的<code>SQLServer</code>还是有很大的区别的，没有表，字段等。</p>
<p>像这种键值对结构的数据库我们统称为<code>nosql</code>数据库。</p>
<h1 id="2、什么是NoSql"><a href="#2、什么是NoSql" class="headerlink" title="2、什么是NoSql"></a>2、什么是<code>NoSql</code></h1><p><code>SQL</code>: 关系型数据库</p>
<p><code>NoSql</code>非关系型数据库</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130008688.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130009731.png"></p>
<p>以上图展示的就是关系性数据库中表与表之间的关系。（关联的），这里想删除编号为1的用户或者是编号为10的商品是不允许的。</p>
<p>而<code>NoSql</code>是没有上面这种非常强的关系，那么如果想展示这种关系，应该怎样处理呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130008015.png"></p>
<p><code>NoSql</code>是通过一个<code>Josn</code>嵌套的方式来组织对应的关系。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130002860.png"></p>
<p>关系型数据库是通过<code>sql</code>语句进行查询，而且大部分的关系型数据库的<code>sql</code>语句基本上是一样的。</p>
<p>而不同的<code>NoSQL</code>查询的语句是不一样的。如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130011329.png"></p>
<p>对比<code>Sql</code>语句，<code>NoSql</code>查询语句都比较简单，但是缺点就是使用不同的<code>NoSql</code>数据库需要学习不同的语法。</p>
<p>还有一点不同的是关于事务的处理</p>
<p><code>sql</code>关系型数据库都有事务的处理，满足<code>ACID</code>特性，但是<code>NOSQL</code>数据库，无法满足事务的<code>ACID</code>，所以你项目要求数据比较安全，就不需要使用<code>Nosql</code>数据库。</p>
<p>关系型数据库是将数据存储到磁盘中，而<code>NoSql</code>是存储在内存中。存储在内存中的好处就是性能非常高，在性能要求比较高的场合都可以使用<code>NoSql</code>数据库。</p>
<p>使用场景：</p>
<p> 关系型数据库：（1）数据结构固定，（2）相关的业务对数据安全性一致性要求比较高 </p>
<p>这种情况都需要使用关系型数据库。</p>
<p><code>NOSQL</code>:(1)数据结构不固定，（2）对一致性，安全性要求不高 （3）对性能要求高</p>
<p>当然，在项目中，关系型数据库与<code>NoSQL</code>数据库也可以结合来使用</p>
<p>例如：订单数据是安全性要求较高的数据，需要使用关系型数据库，但是订单是经常查询的为了提升查询的效率，我们又可以将订单的数据在同步到<code>NOsql</code>数据库中。</p>
<h1 id="3、认识Redis"><a href="#3、认识Redis" class="headerlink" title="3、认识Redis"></a>3、认识<code>Redis</code></h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130002273.png"></p>
<h1 id="4、安装Redis"><a href="#4、安装Redis" class="headerlink" title="4、安装Redis"></a>4、安装<code>Redis</code></h1><p><code>windows</code>安装<code>https://github.com/tporadowski/redis/releases</code></p>
<p>通过以上链接的地址，下载对应的安装包。</p>
<p>下载完以后，进行安装</p>
<p>安装成功，以管理员身份启动<code>cmd</code></p>
<p>然后通过<code>cd</code>命令，跳转到所安装到的目录。</p>
<p>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.windows.conf</span><br></pre></td></tr></table></figure>

<p>将<code>redis</code>服务启动起来。</p>
<p>当我们把控制台窗口关闭以后，整个<code>redis</code>服务就停止了，所以我们可以将其作为<code>windows</code>服务来进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-install redis.windows.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">win+r </span><br><span class="line">services.msc可以看到服务安装成功</span><br></pre></td></tr></table></figure>

<p>现在服务端已经启动了，</p>
<p>我们就可以启动一个客户端程序链接服务端程序了。</p>
<p><code>redis-cli.exe</code> 这是客户端程序</p>
<p>开启一个新的<code>cmd</code>窗口</p>
<p>然后直接输入<code>redis-cli.exe</code>这个命令就可以链接上对应的服务端。</p>
<p>当然，这里我们的服务是安装在本地电脑上，所以显示的<code>ip</code>地址就是127.0.0.1，端口号是6379（默认的端口号）</p>
<p>当然，如果需要链接其他电脑上的<code>redis</code>服务，需要采用如下的链接方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>

<p>注意：<code>-h</code>之间是没有空格的。</p>
<p>链接上服务以后，就可以对<code>redis</code>服务进行操作了。</p>
<p>例如：执行<code>set</code>命令来存储数据，<code>set name zhangsan</code></p>
<p>表示以<code>name</code>表示的就是<code>key</code>，<code>zhangsan</code>就是<code>value</code>，也就是值了。</p>
<p>如果要获取就需要使用<code>get</code>命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get name</span><br></pre></td></tr></table></figure>

<h1 id="5、图形化桌面客户端"><a href="#5、图形化桌面客户端" class="headerlink" title="5、图形化桌面客户端"></a>5、图形化桌面客户端</h1><p>针对客户端，可以从网上下载免费的图形化桌面客户端，这样操作起来更加的方便。</p>
<p>下载地址:<code>[AnotherRedisDesktopManager 发行版 - Gitee.com](https://gitee.com/qishibo/AnotherRedisDesktopManager/releases)</code></p>
<p>安装好以后，启动图形化的客户端程序，链接上<code>redis</code>服务端以后，可以看到<code>redis</code>默认16个数据库。</p>
<p>而我们前面存储的<code>key为name,值为zhangsan</code>的这个数据默认是在编号为<code>0</code>的这个数据库，也就是第一个数据库。</p>
<p>现在我们也可以继续向第一个数据库中添加数据，这时候，我们可以通过图形化的客户端添加，也可以通过命令来添加。</p>
<p>现在我们通过图形化窗口向编号为<code>1</code>的数据库中添加了<code>key 为name</code>，值为<code>lisi</code>的数据。</p>
<p>如果，我们向获取应该怎样处理呢？</p>
<p>我们可以在<code>cmd</code>客户端中，通过执行<code>select 1</code>,表示选择编号为1的数据库，然后再执行<code>get name</code>，这时候获取到的值就是<code>lisi</code></p>
<p>注意：数据库的数量，可以在<code>redis.windows-service.conf</code>这个配置文件中进行调整。</p>
<p>以后，操作<code>redis</code>的时候，可以使用图形化客户端，比较方便，但是在学习的时候，还是使用<code>redis-cli.exe</code>这个客户端。</p>
<h1 id="6、Redis常见命令"><a href="#6、Redis常见命令" class="headerlink" title="6、Redis常见命令"></a>6、<code>Redis</code>常见命令</h1><p><code>Reids</code>是一个<code>key-value</code>的数据库，<code>key</code>一般是<code>string</code>类型，但是<code>value</code>的类型多种多样</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130002307.png"></p>
<p>在上面的图中列举了<code>value</code>的类型，这里列举了8个，但是还有其他的。这里最常用的就是前5种类型。</p>
<p>注意：<code>Hash</code>类型是一个<code>hash</code>表，这里是通过字符串的形式进行描述</p>
<h2 id="6-1-通用命令"><a href="#6-1-通用命令" class="headerlink" title="6.1  通用命令"></a>6.1  通用命令</h2><p> <strong>（1）<code>keys</code>命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys *  // 获取所有的key</span><br><span class="line">keys n* // 获取以n开头的key</span><br></pre></td></tr></table></figure>

<p>由于<code>keys</code>指令是通过模糊的方式来进行查询，所以当<code>redis</code>中的数据量比较大的时候，查询性能比较慢，由于是单线程，所以在生产的服务器上执行该命令的时候，会阻塞其他命令的执行，所以说在生产服务器上不要使用该命令来查询。</p>
<p>为了后面其他命令的演示，先通过<code>mset</code>命令一次性插入多个<code>key</code>和对应的<code>value</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset  k1 aa k2 bb k3 cc k4 dd</span><br></pre></td></tr></table></figure>

<p><strong>（2） <code>del</code>命令</strong></p>
<p><code>del</code>命令是删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del name // 删除key为name的内容</span><br><span class="line">del k1 k2 // del命令也可以一次性删除多个key的内容</span><br></pre></td></tr></table></figure>

<p><code>del</code>命令返回的结果是一个整数的数字，表示删除的<code>key</code>的数量</p>
<p><strong>（3）<code>exists</code>命令</strong></p>
<p>该命令判断，指定的<code>key</code>是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists name // 判断name这个key是否存在，如果存在返回的是1，否则返回的是0</span><br></pre></td></tr></table></figure>

<p><strong>（4）<code>expire</code>命令</strong></p>
<p>该命令的作用是给一个<code>key</code>设置有效期，有效期到期以后该<code>key</code>会自动的被删除掉。</p>
<p>我们知道<code>redis</code>中的数据默认是存储在内存中的，如果我们不设置有效期，会导致<code>redis</code>中存储的数据量会越来越多。</p>
<p>会导致内存被占满。所以需要<code>expire</code>命令来设置有效期</p>
<p>例如：<code>redis</code>中存储短信验证码，我们可以设置有效期就是5分钟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire age 20 // 表示age这个key的有效期是20秒钟</span><br></pre></td></tr></table></figure>

<p>设置完以后，可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl age // 这里通过ttL命令来查看age这个key剩余的秒数</span><br></pre></td></tr></table></figure>

<p>如果以上<code>TTL</code>指令输出的值是-2，表示<code>age</code>这个指令已经到期了，然后执行<code>keys *</code>的时候，就查看不到<code>age</code>这个指令了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set name zhangsan</span><br></pre></td></tr></table></figure>

<p>我们执行了以上命令，重新创建了一个<code>key</code>是<code>name</code>，并且值是<code>zhangsan</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL name</span><br></pre></td></tr></table></figure>

<p>这时候通过<code>TTL</code>来查看<code>name</code>的有效期，发现输出的值是-1，表示<code>name</code>是永久有效。</p>
<p>建议：在<code>redis</code>中，根据实际情况，最好设置<code>key</code>的有效期</p>
<h2 id="6-2-String类型"><a href="#6-2-String类型" class="headerlink" title="6.2 String类型"></a>6.2 <code>String</code>类型</h2><p><code>String</code>类型，也就是字符串类型，是<code>Redis</code>中最简单的存储类型</p>
<p>其中<code>value</code>就是字符串，不过根据字符串的格式不同，又可以分为3类</p>
<p><code>string</code>:普通字符串</p>
<p><code>int</code> 整数类型，可以做自增，自减操作（数字型字符串）</p>
<p><code>float</code>: 浮点类型，可以做自增，自减操作</p>
<p>以上都是字符串，底层都是通过字节数组的形式来进行存储的，只不过编码的方式不同。数值类型的字符串直接转换成二进制后作为字节数组来存储。字符串就是转成成字节码然后再进行存储</p>
<p>字符串类型的最大空间不能超过<code>512M</code></p>
<p><code>String 常见命令</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130003002.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130003503.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130003788.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130003402.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130010117.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130003519.png"></p>
<h2 id="6-3-Key的层级格式"><a href="#6-3-Key的层级格式" class="headerlink" title="6.3  Key的层级格式"></a>6.3  <code>Key</code>的层级格式</h2><p><code>Redis</code>没有类似<code>MySQL</code>中的<code>Table</code>的概念，我们是如何区分不同类型的<code>key</code>呢？</p>
<p>例如：需要存储用户，商品信息到<code>redis</code>中，有一个用户的<code>id</code>是1，有一个商品的<code>id</code>恰好也是1</p>
<p>都是<code>id</code>怎样区分呢？</p>
<p>我们可以在<code>id</code>的基础上拼接一些其他的字符串来进行区分，当然，这些字符串也不是随便进行区分的。</p>
<p><code>Redis</code>的<code>key</code>允许有多个单词进行拼接形成层级结构，多个单词之间使用<code>:</code>进行分割。例如以下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名称:业务名:类型:id</span><br></pre></td></tr></table></figure>

<p>当然，不一定非要按照以上的规则进行拼接，大家根据公司中的实际要求来即可。</p>
<p>例如：我们的项目名称叫做<code>XYZ</code>，有<code>user</code>和<code>product</code>两种不同的数据类型，我们可以这样定义<code>key</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user 相关的key: XYZ:user:1 // 1表示的就是第一个用户的编号</span><br><span class="line">product相关的key:XYZ:product:1</span><br></pre></td></tr></table></figure>

<p>以上这是<code>key</code>的定义。</p>
<p>当<code>key</code>定义好以后，怎样存储对应的值呢？</p>
<p>不管是用户也好，还是<code>prodcut</code>，在存储相关的信息的时候，我们一般存储的都是<code>c#</code>对象，问题是对象怎样存储呢？</p>
<p>我们知道<code>c#</code>对象不是字符串，但是完全可以序列化成<code>json</code>格式的字符串来进行存储</p>
<p>如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130004645.png"></p>
<p>执行完以上的命令以后，我们可以看一下对应的图形客户端，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130003949.png"></p>
<p>单击<code>刷新按钮</code>以后，可以看到在编号为0的数据库中，存储的内容形成了层级的关系。</p>
<h2 id="6-4-Hash-类型"><a href="#6-4-Hash-类型" class="headerlink" title="6.4 Hash 类型"></a>6.4 <code>Hash</code> 类型</h2><p><code>Hash</code>类型，也叫做散列，其<code>value</code>是一个无序字典</p>
<p><code>String</code>结构是将对象序列化为<code>JSON</code>字符串后存储，当需要修改对象中某个字段的时候很不方便。</p>
<table>
<thead>
<tr>
<th>KEY</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>XYZ:user:1</td>
<td>{name:”zhangsan”,age:21}</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果要修改<code>age</code>，只能是将整个字符串替换掉。</p>
<p><code>Hash</code>结构可以将对象中的每个字段独立存储，可以针对单个字段做<code>CRUD</code>的操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130004007.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130004889.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130004342.png"></p>
<p>可以返回到<code>图形客户端</code>查看对应的结构。</p>
<p>如果再执行：<code> hset XYZ:user:3 age 22</code>,就是对<code>age</code>这个字段的值进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hget XYZ:user:3 name</span><br></pre></td></tr></table></figure>

<p>通过<code>hget</code>指令，获取了<code> XYZ:user:3</code>这个键下面的<code>name</code>这个字段的值。</p>
<p>下面通过<code>HMSET</code>指令进行批量的添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset XYZ:user:4 name wangwu</span><br></pre></td></tr></table></figure>

<p>这里是通过<code>hmset</code>向<code>XYZ:user:4</code>这个<code>key</code>中添加了<code>name</code>这个字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset XYZ:user:4 name lisi age 20 sex man</span><br></pre></td></tr></table></figure>

<p>这里是通过<code>hmset</code>指令向<code>XYZ:user:4</code>这个<code>key</code>中添加了<code>name,age,sex</code>这三个字段，并且确定了对应的值。</p>
<p>返回到图形客户端中查看效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget XYZ:user:4 name age sex</span><br></pre></td></tr></table></figure>

<p>以上是通过<code>hmget</code>这个指令获取<code>XYZ:user:4</code>这个<code>key</code>对应的<code>name.age,sex</code>这三个字段的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall XYZ:user:4</span><br></pre></td></tr></table></figure>

<p>通过<code>hgetall</code>指令，获取<code>XYZ:user:4</code>这个<code>key</code>中所有的字段，以及字段的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkeys XYZ:user:4</span><br></pre></td></tr></table></figure>

<p>通过<code>hkeys</code>指令，获取<code>XYZ:user:4</code>这个<code>key</code>中所有的字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hvals XYZ:user:4</span><br></pre></td></tr></table></figure>

<p>通过<code>hvals</code>获取<code>XYZ:user:4</code>这个<code>key</code>中所有的字段的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hincrby XYZ:user:4 age 2</span><br></pre></td></tr></table></figure>

<p>通过<code> hincrby</code>这个指令，可以让<code> XYZ:user:4</code>这个<code>key</code>中的<code>age</code>字段的值加2</p>
<h2 id="6-5-List类型"><a href="#6-5-List类型" class="headerlink" title="6.5 List类型"></a>6.5 <code>List</code>类型</h2><p><strong>列表</strong>（list）类型是用来存储多个 <strong>有序</strong> 的 <strong>字符串</strong>。在 Redis 中，可以对列表的 <strong>两端</strong> 进行 <strong>插入</strong>（push）和 <strong>弹出</strong>（pop）操作，还可以获取 <strong>指定范围</strong> 的 <strong>元素列表</strong>、获取 <strong>指定索引下标</strong> 的 <strong>元素</strong> 等。</p>
<p><strong>列表</strong> 是一种比较 <strong>灵活</strong> 的 <strong>数据结构</strong>，它可以充当 <strong>栈</strong> 和 <strong>队列</strong> 的角色，在实际开发上有很多应用场景。</p>
<p><code>List</code>类型一般用于对顺序有要求的场景，例如：朋友圈中的点赞功能，点赞是有先后顺序的，还有就是评论，谁先评论的，谁后评论的，这些都是有顺序的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130005314.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130005414.png"></p>
<p>这里首先通过<code>lpush</code>指令，向<code>users</code>这个<code>key</code>表示的列表左侧插入多个元素</p>
<p>可以返回到图形客户端，查看一下<code>users</code>这个<code>key</code>中插入值的顺序是3,2,1。</p>
<p>这里可以想象一下，假如列表中有一个0，执行上面的<code>lpush</code>的时候，先在0左侧插入1，然后是2，最后是3.</p>
<p>同理<code>rpush</code>也是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpop users</span><br></pre></td></tr></table></figure>

<p><code>lpop</code>表示从<code>users</code>这个<code>key</code>中获取左侧的第一个元素，同时会删除该元素，这里可以返回到图形客户端进行查看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpop users</span><br></pre></td></tr></table></figure>

<p><code>rpop</code>表示从<code>users</code>这个<code>key</code>中获取右侧的第一个元素，同时也会删除该元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange users 1 2</span><br></pre></td></tr></table></figure>

<p>返回的是<code>1,2</code>这个范围的元素</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130006626.png"></p>
<p>在上面的代码中，通过<code>blpop</code>来获取<code>user5</code>这个<code>key</code>中的内容，等待的时间是100秒。</p>
<p>在这里开启另外一个客户端程序</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130005796.png"></p>
<p>然后通过<code>lpush</code>添加数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130005557.png"></p>
<p>在等待了47秒以后，获取到了数据。</p>
<p>这就是所谓的阻塞式获取</p>
<p>问题：</p>
<p>第一：如何使用<code>List</code>结构模拟一个栈？</p>
<p>添加数据的时候，通过<code>lpush</code>，取数据的时候通过<code>lpop</code> 模拟的是栈</p>
<p>第二：如何利用<code>List</code>结构模拟一个队列？</p>
<p><code>lpush</code>添加数据，然后通过<code>rpop</code>获取数据，模拟的就是队列</p>
<p>栈：先进后出</p>
<p>队列：先进先出</p>
<h2 id="6-6-Set类型"><a href="#6-6-Set类型" class="headerlink" title="6.6 Set类型"></a>6.6 <code>Set</code>类型</h2><p><strong>集合</strong>（set）类型也是用来保存多个 <strong>字符串元素</strong>，但和 <strong>列表类型</strong> 不一样的是，集合中 <strong>不允许有重复元素</strong>，并且集合中的元素是 <strong>无序的</strong>，不能通过 <strong>索引下标</strong> 获取元素。</p>
<p>同时支持，交集，并集，差集等功能</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130006546.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130006028.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408131145138.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130006595.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130006831.png"></p>
<p>练习：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130009800.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007854.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007135.png"></p>
<h2 id="6-7-SortedSet类型"><a href="#6-7-SortedSet类型" class="headerlink" title="6.7 SortedSet类型"></a>6.7 <code>SortedSet</code>类型</h2><p><code>SortedSet</code>是一个可排序的<code>Set</code>集合，<code>SortedSet</code>中的每一个元素都带有一个<code>score</code>属性，可以基于<code>score</code>属性对元素进行排序。</p>
<p>因为<code>SortedSet</code>的可排序性，经常被用来实现排行榜这样的功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130009529.png"></p>
<p>注意：所有的排名默认都是升序的，如果要降序则在命令的<code>Z</code>后面添加<code>REV</code>即可。</p>
<p>练习：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007551.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007967.png"></p>
<p><code>stus</code>表示的是<code>key</code> </p>
<p>数字就是<code>score</code>成绩</p>
<p>名字就是<code>member</code>,也就是成员。</p>
<p>执行完以后，可以看一下图形客户端，发现数据默认都是升序排序的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007421.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130009490.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007173.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZRANK stus Rose  //  升序</span><br><span class="line">ZREVRANK stus Rouse // 降序  注意：是从0开始计算的</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题：统计80分以下的学生人数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130009723.png"></p>
<p>问题：给<code>Amy</code>同学加2分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007512.png"></p>
<p>问题：查询成绩前3名的同学</p>
<p>注意：这里需要倒序查询（因为默认存储的时候是升序）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007447.png"></p>
<p>问题：查询出成绩80分以下的所有学生</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007040.png"></p>
<h1 id="7、缓存应用"><a href="#7、缓存应用" class="headerlink" title="7、缓存应用"></a>7、缓存应用</h1><h2 id="7-1-缓存描述"><a href="#7-1-缓存描述" class="headerlink" title="7.1  缓存描述"></a>7.1  缓存描述</h2><p>我们知道<code>redis</code>的性能非常高，所以我们一般会使用<code>redis</code>来做分布式的缓存应用。</p>
<p><code>Redis</code>官网中提供了各种语言的客户端：<code>https://redis.io/clients</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408131121975.png"></p>
<p>如果用户访问量不大，不使用缓存也是可以的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007226.png"></p>
<h2 id="7-2-Net-core中使用Redis"><a href="#7-2-Net-core中使用Redis" class="headerlink" title="7.2 .Net core中使用Redis"></a>7.2 <code>.Net core</code>中使用<code>Redis</code></h2><p>在<code>.Net Core</code>中提供了统一的分布式缓存服务器的操作接口<code>IDistributedCache</code>,用法与内存缓存类似</p>
<p>分布式缓存，由于是在其他的服务器中，与<code>Web</code>应用不是在同一个服务器中，就要设计到网络通信的问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130010208.png"></p>
<p>使用方式如下：</p>
<p>新建一个<code>WebApi</code>项目</p>
<p>第一：安装<code>Microsoft.Extensions.Caching.StackExchangeRedis</code>  ：</p>
<p><code>Install-Package  Microsoft.Extensions.Caching.StackExchangeRedis</code></p>
<p>第二：注册相关的服务</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddStackExchangeRedisCache(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    opt.Configuration = <span class="string">&quot;localhost&quot;</span>; <span class="comment">// 指定redis服务器的地址</span></span><br><span class="line">    opt.InstanceName = <span class="string">&quot;cacheApp&quot;</span>; <span class="comment">// 为了与其他的redis数据库区分，添加了响应的前缀</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br></pre></td></tr></table></figure>

<p>创建一个<code>TestsController.cs</code>控制器，该控制器中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestsController</span> : <span class="title">ControllerBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCache _distributedCache;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestsController</span>(<span class="params"> IDistributedCache distributedCache</span>)</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>._distributedCache = distributedCache;    </span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">HttpGet</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Test</span>(<span class="params"><span class="built_in">long</span> id</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span>? s = <span class="keyword">await</span> _distributedCache.GetStringAsync(<span class="string">&quot;Book&quot;</span> + id);</span><br><span class="line">            <span class="keyword">if</span> (s==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;查询数据库&quot;</span>);</span><br><span class="line">                Book book = <span class="keyword">new</span> Book() &#123; Id = <span class="number">1</span>, Title = <span class="string">&quot;.net core&quot;</span>, Author = <span class="string">&quot;zhangsan&quot;</span>, Description = <span class="string">&quot;.net core入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;;</span><br><span class="line">               <span class="keyword">await</span> _distributedCache.SetStringAsync(<span class="string">&quot;Book&quot;</span>+id,JsonSerializer.Serialize(book));</span><br><span class="line">                <span class="keyword">return</span> Ok(book);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;查询缓存&quot;</span>);</span><br><span class="line">                Book book =  JsonSerializer.Deserialize&lt;Book&gt;(s)!;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (book == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> NotFound(<span class="string">&quot;不存在!!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> Ok(book);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码以后，查看图形客户端。</p>
<h2 id="7-3-缓存更新策略"><a href="#7-3-缓存更新策略" class="headerlink" title="7.3  缓存更新策略"></a>7.3  缓存更新策略</h2><p>当数据库中的数据发生了改变，对应的缓存中的数据也要进行更新，才能保存数据的一致性。</p>
<p><code>超时剔除</code>：这种更新策略的一致性是一般的，原因是取决于设置的过期时间，如果过期时间设置比较长，对应的用户在这段时间从缓存中获取的有可能还是旧数据，维护成本比较低，就是在添加缓存的时候，指定过期时间就可以了，不需要过多的编码。</p>
<p><code>主动更新</code>：在更新数据库中的相应数据的时候，顺便更新缓存中的数据，所以相对来讲数据的一致性比较好，但是维护成本比较高，因为，需要我们自己编写更新缓存中数据的代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007006.png"></p>
<p>关于主动更新策略，有两种主要使用方式：</p>
<p>第一种方式：由缓存的调用者，在更新数据库的同时更新缓存</p>
<p>第二种方式：调用者只操作缓存，由其他的线程异步的将缓存数据持久化到数据库中，这种方式的好处：例如，我们在缓存中做了10次写操作，而10次完成以后，可以作为一次写操作，将其存储到数据库中。提升了写数据库的效率。</p>
<p>但是这种方式的问题：实现起来比较复杂。</p>
<p>所以第一种方式是首选。</p>
<p>选择了第一种方式以后，还需要考虑如下问题：</p>
<p>举个例子：假如我更新了100次数据库，然后又同时更新了100次缓存，但是在更新的时候并没有人来查这个数据，那么我更新这100次缓存好像也没啥用吧，相当于前99次都是无用功，只有最后一次才是有用的。这就是无效写操作过多的原因。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007766.png"></p>
<p>关于第三个问题：以上两种方式都可以，下面在对这种方式做一个对比，来深入理解一下</p>
<p>下面先来看一下：先删除缓存，再操作数据库这种情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130010693.png"></p>
<p>缓存和数据库中都存储了10，并且有两个线程。假设线程1更新缓存</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007109.png"></p>
<p>这时候线程1，将缓存中的数据清除了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007951.png"></p>
<p>同时线程1将20更新到数据库中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007608.png"></p>
<p>这时候线程2，正好进行查询，这时候查询缓存未命中，直接去查询数据库</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408131146477.png"></p>
<p>线程2，查询完数据库以后，会将从数据库中查询出的数据写导入到缓存中。</p>
<p>以上情况是正常的情况。</p>
<p>下面我们再来看一下比较特殊的情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130010744.png"></p>
<p>假如，线程1，已经将缓存中的数据删除了，然后去更新数据库，但是更新的业务比较复杂，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007968.png"></p>
<p>这时候正好又来了一个线程2，去查询缓存，但是没有被命中，只能去查询数据库，这时候查询出来的是数据库中旧的值。</p>
<p>同时还要把数据写入到缓存中，但是这时候写入到缓存中的数据也是旧的值，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007892.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007548.png"></p>
<p>这时候，线程1更新数据库的操作完成了，这时候数据库中的值是20，但是缓存中的值是10。</p>
<p>这时候，数据库和缓存中的数据就不一致了，这就是多线程安全问题。</p>
<p><strong>下面我们再来看一下：先操作数据库，再删除缓存的情况</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130007462.png"></p>
<p>在上图中，假设线程2，先更新数据库，这时候数据库中存储的值是20，缓存中存储的是10.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130010693.png"></p>
<p>线程2，更新完数据库以后，紧接着会删除缓存，这时候缓存中的数据没有了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408131146029.png"></p>
<p>这时候，线程1来查询缓存，但是没有命中，只能去查询数据库，然后在向缓存中写入数据。这时候，缓存中的数据是最新的。</p>
<p><strong>以上是正常的情况，下面再来看一下特殊的情况</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130011397.png"></p>
<p>现在假设缓存中没有数据，线程1，查询缓存没有命中，查询数据库，得到的数据是10</p>
<p>这时候线程2更新数据库，将数据库中的数据修改成20,如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130008908.png"></p>
<p>更新完数据库以后，删除缓存，但是缓存中本来就没有数据，所以这次操作什么都没有做。</p>
<p>这时候，线程1，开始写缓存。如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130011167.png"></p>
<p>这时候，向缓存中写入的数据是线程1最开始查询出来的旧数据，也就是10，这时候缓存中的数据就是10.</p>
<p>从而导致了缓存与数据库中的数据不一致的情况。</p>
<p>问题是：这种先操作数据库，再删除缓存的操作发生的概率大吗?</p>
<p>相比于【先删除缓存，再操作数据库】这种情况来讲，要小的多。</p>
<p>因为在线1完成了第一不操作以后，再到第四步操作，所需要的时间，比线程2 完成第二步操作和第三步操作需要的时间相对来讲要短。</p>
<p>所以，推荐使用【先操作数据库，再删除缓存】这种方式。当然，这种方式也会出现意外情况，为了避免这种情况，我们可以再添加上超时剔除作为兜底的方案。我们可以在写入缓存的时候，添加超时时间，这样即使写入了旧数据，到了指定的时间，缓存中的数据也会失效。</p>
<h2 id="7-4-缓存更新策略应用"><a href="#7-4-缓存更新策略应用" class="headerlink" title="7.4 缓存更新策略应用"></a>7.4 缓存更新策略应用</h2><p>需求1：根据<code>id</code>查询图书的信息，如果缓存没有命中，则查询数据库，将数据结果写入到缓存中，并设置超时时间。</p>
<p>修改<code>TestsController.cs</code>中的代码，在该控制器中添加了<code>Test2</code>方法，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;cache&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Test2</span>(<span class="params"><span class="built_in">long</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>? s = <span class="keyword">await</span> _distributedCache.GetStringAsync(<span class="string">&quot;Book&quot;</span> + id);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;查询数据库&quot;</span>);</span><br><span class="line">                Book book = <span class="keyword">new</span> Book() &#123; Id = <span class="number">1</span>, Title = <span class="string">&quot;.net core&quot;</span>, Author = <span class="string">&quot;zhangsan&quot;</span>, Description = <span class="string">&quot;.net core入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;;</span><br><span class="line"><span class="comment">// 设置过期时间</span></span><br><span class="line">                <span class="keyword">var</span> options = <span class="keyword">new</span> DistributedCacheEntryOptions().SetSlidingExpiration(TimeSpan.FromSeconds(<span class="number">20</span>));</span><br><span class="line">                <span class="keyword">await</span> _distributedCache.SetStringAsync(<span class="string">&quot;Book&quot;</span> + id, JsonSerializer.Serialize(book),options);</span><br><span class="line">                <span class="keyword">return</span> Ok(book);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;查询缓存&quot;</span>);</span><br><span class="line">                Book book = JsonSerializer.Deserialize&lt;Book&gt;(s)!;</span><br><span class="line">                <span class="keyword">if</span> (book == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> NotFound(<span class="string">&quot;不存在!!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> Ok(book);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>以上<code>Test2</code>方法中的代码与前面所写的<code>Test</code>方法中的代码基本上是一样的，这里只不过添加了过期时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果想设置缓存过期时间则通过DistributedCacheEntryOptions，它可以设置滑动过期时间(SlidingExpiration)、绝对过期时间(AbsoluteExpiration)和相对于现在的绝对过期时间(AbsoluteExpirationRelativeToNow)。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行完上面的代码以后，查看图形客户端，重点查看<code>key</code>中的表示过期时间的字段</p>
<p>需求2：根据<code>id</code>修改图书信息，先修改数据库，再删除缓存</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Test3</span>(<span class="params"><span class="built_in">long</span> id</span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">           </span><br><span class="line">           List&lt;Book&gt; books = <span class="keyword">new</span> List&lt;Book&gt;() &#123;</span><br><span class="line">               <span class="keyword">new</span> Book() &#123; Id = <span class="number">1</span>, Title = <span class="string">&quot;.Net Core&quot;</span>, Author = <span class="string">&quot;zhangsan&quot;</span>, Description = <span class="string">&quot;.net core入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> Book() &#123; Id = <span class="number">2</span>, Title = <span class="string">&quot;Vue&quot;</span>, Author = <span class="string">&quot;lisi&quot;</span>, Description = <span class="string">&quot;Vue入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> Book() &#123; Id = <span class="number">3</span>, Title = <span class="string">&quot;React&quot;</span>, Author = <span class="string">&quot;wangwu&quot;</span>, Description = <span class="string">&quot;React入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">           &#125;;</span><br><span class="line">          Book book = books.FirstOrDefault(b=&gt;b.Id==id)!;</span><br><span class="line">           <span class="keyword">if</span>(book!=<span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               book.Price = <span class="number">90</span>;<span class="comment">// 这里相当于更新数据库</span></span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 立即执行数据库的更新。</span></span><br><span class="line">               </span><br><span class="line">               <span class="keyword">await</span> _distributedCache.RemoveAsync(<span class="string">&quot;Book&quot;</span>+id); <span class="comment">// 删除缓存</span></span><br><span class="line">               <span class="keyword">return</span> Ok(book);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> NotFound(<span class="string">$&quot;编号<span class="subst">&#123;id&#125;</span>的书不存在&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>在测试上面的代码的时候，查看一下图形客户端，看一下那个编号的图书是存储在<code>redis</code>中的，在测试的时候就输入对应的编号。</p>
<p>这样可以看到对应的编号的书的价格修改了，同时缓存也被删除了。</p>
<h2 id="7-5-缓存穿透"><a href="#7-5-缓存穿透" class="headerlink" title="7.5 缓存穿透"></a>7.5 缓存穿透</h2><p>缓存穿透：指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p>
<p>常见的解决方案：</p>
<p>缓存空对象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130008851.png"></p>
<p>客户端请求<code>redis</code>，<code>redis</code>中没有对应的数据，这时候会请求数据库，数据库中也没有对应的数据。</p>
<p>这时候会将空值缓存到<code>redis</code>中，下次请求的时候，就会被命中，只不过这时候得到的是空值。</p>
<p>例如：请求编号为100的书，缓存中没有，请求数据库，数据库中也没有编号为100的图书信息，这时候，会在<code>redis</code>中存储一个编号100为<code>key</code>对应的值是空值，下次再请求编号为100的图书，直接从<code>redis</code>中返回空值。这时候不会再请求数据库了。</p>
<p>这种方式的优点就是：简单方便</p>
<p>缺点：会造成一定的内存消耗，例如：用户随意请求了很多不存在的编号，这样<code>redis</code>中就缓存了很多的<code>null</code>，这就会造成一定的内存资源的浪费，当然为了解决这个问题，我们可以设置过期时间。这样就可以解决内存资源浪费的问题。</p>
<p>还有一点就是，这种方式有可能造成短期数据不一致的情况，例如：用户请求了编号为100的图书，缓存中不存在，数据库中不存在，这时候<code>redis</code>缓存了编号100对应的值就是空值，而且假设缓存设置的过期时间是5分钟，在这时候，管理员恰好录入了编号为100的图书，而其他用户请求编号为100的图书的时候，在5分钟内得到的结果还是空值。</p>
<p>当然，这里我们可以使用我们前面介绍的方式来解决这个问题，就是再向数据库中添加图书的时候，顺便更新对应的缓存。</p>
<p>具体代码实现，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;/cache2&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Test4</span>(<span class="params"><span class="built_in">long</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>? s = <span class="keyword">await</span> _distributedCache.GetStringAsync(<span class="string">&quot;Book&quot;</span> + id);<span class="comment">// 10002</span></span><br><span class="line">            <span class="comment">// 10002  Book10002  &quot;null&quot;</span></span><br><span class="line">            <span class="comment">// 10003</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s==<span class="literal">null</span>)  </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ----------缓存中没有数据，查询数据库</span></span><br><span class="line">                List&lt;Book&gt; books = <span class="keyword">new</span> List&lt;Book&gt;() </span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">new</span> Book() &#123; Id = <span class="number">1</span>, Title = <span class="string">&quot;.Net Core&quot;</span>, Author = <span class="string">&quot;zhangsan&quot;</span>, Description = <span class="string">&quot;.net core入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> Book() &#123; Id = <span class="number">2</span>, Title = <span class="string">&quot;Vue&quot;</span>, Author = <span class="string">&quot;lisi&quot;</span>, Description = <span class="string">&quot;Vue入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                  <span class="keyword">new</span> Book() &#123; Id = <span class="number">3</span>, Title = <span class="string">&quot;React&quot;</span>, Author = <span class="string">&quot;wangwu&quot;</span>, Description = <span class="string">&quot;React入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                 &#125;;</span><br><span class="line">                Book book = books.FirstOrDefault(b =&gt; b.Id == id)!;</span><br><span class="line">                <span class="keyword">if</span>(book!=<span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//--------------- 从数据库中查询到了数据，将其写入缓存</span></span><br><span class="line">                    <span class="keyword">var</span> options = <span class="keyword">new</span> DistributedCacheEntryOptions().SetAbsoluteExpiration(TimeSpan.FromSeconds(<span class="number">300</span>));</span><br><span class="line">                    <span class="keyword">await</span> _distributedCache.SetStringAsync(<span class="string">&quot;Book&quot;</span> + id, JsonSerializer.Serialize(book), options);</span><br><span class="line">                    <span class="keyword">return</span> Ok(book);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//--------- 如果数据库中也不存在，将空值写入到redis中(这里是一个null字符串)</span></span><br><span class="line">                    <span class="keyword">var</span> options = <span class="keyword">new</span> DistributedCacheEntryOptions().SetAbsoluteExpiration(TimeSpan.FromSeconds(<span class="number">100</span>));</span><br><span class="line">                    <span class="keyword">await</span> _distributedCache.SetStringAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="string">&quot;null&quot;</span>, options); <span class="comment">// Book10002,&quot;null&quot;</span></span><br><span class="line">                    <span class="keyword">return</span> NotFound(<span class="string">$&quot;没有找到编号<span class="subst">&#123;id&#125;</span>的图书&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//------------------ 缓存中有数据，还需要判断是否为空字符串</span></span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">&quot;null&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> NotFound(<span class="string">$&quot;没有找到编号<span class="subst">&#123;id&#125;</span>的图书&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 缓存中有数据，并且不是空字符串</span></span><br><span class="line">                    Book book = JsonSerializer.Deserialize&lt;Book&gt;(s)!;</span><br><span class="line">                    <span class="keyword">return</span> Ok(book);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，可以打上断点进行测试。</p>
<p>当然，为了防止缓存穿透，除了上面提到的方法，还可以增强<code>id</code>的复杂度，避免被猜测出<code>id</code>规律。</p>
<p>同时进行权限校验，不是所有的方法，用户都可以请求</p>
<h2 id="7-6-缓存雪崩"><a href="#7-6-缓存雪崩" class="headerlink" title="7.6  缓存雪崩"></a>7.6  缓存雪崩</h2><p>缓存雪崩：是指在同一时间段大量的缓存<code>key</code>同时失效或者<code>redis</code>服务宕机，导致大量请求到达数据库，带来巨大的压力。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130010588.png"></p>
<p>针对大量缓存过期的问题：</p>
<p>实际应用中，我们一般都是提前把数据库中的数据导入到<code>redis</code>缓存中，这样就会导致，导入数据的过期时间是一样的。</p>
<p>所以就会出现在同一时间段大量缓存过期的情况。</p>
<p>针对这种情况的处理，我们一般就是给不同的<code>Key</code>的过期时间在加上一个随机的值。例如：10–20分钟之间的随机值，这样就不会导致在同一时刻大量缓存过期的情况。（这个大家可以自己编码）</p>
<p>针对<code>Redis</code>宕机的情况，一般的解决方案就是利用<code>Redis</code>集群提高服务的可用性。</p>
<h2 id="7-7-缓存击穿问题分析"><a href="#7-7-缓存击穿问题分析" class="headerlink" title="7.7 缓存击穿问题分析"></a>7.7 缓存击穿问题分析</h2><p><strong>缓存击穿问题</strong>：也叫做热点<code>Key</code>问题，就是一个被<strong>高并发访问</strong>并且缓存重要业务数据的 ，较复杂的<code>Key</code>突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<p>简单理解：缓存击穿问题常见的是两种情况</p>
<p>第一种情况：就是一个缓存的<code>Key</code>访问非常频繁，但是如果这个缓存失效了，就有可能给数据带来巨大的压力。</p>
<p>第二种情况：我们知道，当缓存失效后，会查询数据库，但是有的情况把数据从数据库中查询出来以后，并不是立即写入缓存，因为有可能还需要进行一些其他的业务处理操作，而这些业务的处理有可能需要时间比较长，在这一个比较长的时间段内，<code>redis</code>中是没有缓存对应的数据的，而这时候恰好有很多请求，这时候只能请求数据库。</p>
<p>针对<code>缓存击穿</code>的问题，我们可以通过【互斥锁来解决】</p>
<p>如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130008330.png"></p>
<p>线程1，没有从缓存中查询到数据以后，会得到一个锁，这时候开始查询数据库，进行数据的处理，当然这个过程有可能业务比较复杂，需要等待一段时间，而这时候线程2发来请求，发现缓存中没有数据，这时候线程2也会尝试获取互斥锁，但是这时候线程2获取失败了，在等待了一段时间后，会再次查询缓存，重新尝试获取互斥锁。不断重复这个过程。</p>
<p>直到线程1，把数据写入到缓存，释放了锁以后，线程2在查询缓存的时候，才会获取到缓存中最新的数据。</p>
<p>这种互斥锁相对比较简单，但是问题是性能比较低。</p>
<p>假如有1000个线程，也就是1000个请求者，这时候只有1个线程获取到了互斥锁，并且在处理的过程中比较耗时，这时候剩余的线程只能进行休眠，重试的过程，也就是等待的过程。</p>
<h2 id="7-8-利用互斥锁解决缓存击穿问题"><a href="#7-8-利用互斥锁解决缓存击穿问题" class="headerlink" title="7.8 利用互斥锁解决缓存击穿问题"></a>7.8 利用互斥锁解决缓存击穿问题</h2><p>业务的流程如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130011041.png"></p>
<p>关键是这个锁怎样确定呢？</p>
<p>这里我们可以通过<code>setnx</code>方法来实现，这个方法我们前面也介绍过，在设置字符串的<code>key</code>的时候，会做检查，如果<code>key</code>不存在，才会给指定的<code>key</code>设置值，如果存在，则不做任何更改。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/202408130008688.png"></p>
<p>怎样释放锁呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del lock</span><br></pre></td></tr></table></figure>

<p>就是通过<code>del</code>把<code>lock</code>这<code>key</code>删除掉旧可以了。就相当于释放了锁。</p>
<p>这里有一个问题就是：假设线程1获取到锁了以后，进行其他的业务处理，但是在处理的过程中出现了异常，有可能就会导致锁无法释放，所以为了避免这种情况的出现，我们可以在创建锁的时候，指定过期时间。</p>
<p>下面修改<code>TestsController.cs</code>控制器中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task&lt;<span class="built_in">bool</span>&gt; <span class="title">tryLoack</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里使用了GetStringAsync方法模拟了setnx方法。</span></span><br><span class="line">  <span class="built_in">string</span> ? s = <span class="keyword">await</span> _distributedCache.GetStringAsync(key); <span class="comment">// lock:book:10001</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> options = <span class="keyword">new</span> DistributedCacheEntryOptions().SetAbsoluteExpiration(TimeSpan.FromSeconds(<span class="number">100</span>));</span><br><span class="line">        <span class="comment">// 这里可以随意存储值</span></span><br><span class="line">        <span class="comment">// lock:book:1 --- 1</span></span><br><span class="line">        <span class="keyword">await</span> _distributedCache.SetStringAsync(key, <span class="string">&quot;1&quot;</span>, options);  <span class="comment">// lock:book:10001   1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解锁操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">unloack</span>(<span class="params"><span class="built_in">string</span> key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> _distributedCache.RemoveAsync(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面创建一个新的方法<code>Test5</code>,代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> 缓存击穿问题</span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;id&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">       <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"></span><br><span class="line">       [<span class="meta">HttpGet(<span class="string">&quot;/cache3&quot;</span>)</span>]</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Test5</span>(<span class="params"><span class="built_in">long</span> id</span>)<span class="comment">// 10001</span></span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">string</span>? s = <span class="keyword">await</span> _distributedCache.GetStringAsync(<span class="string">&quot;Book&quot;</span> + id);<span class="comment">//Book10001</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 1.-----------------------------------------尝试获取互斥锁</span></span><br><span class="line">               <span class="built_in">string</span> lockKey = <span class="string">&quot;lock:book:&quot;</span>+id; <span class="comment">// lock:book:10001</span></span><br><span class="line">               <span class="built_in">bool</span> isLock =<span class="keyword">await</span> tryLoack(lockKey);</span><br><span class="line">               <span class="comment">//2. -----------------------判断是否获取锁成功</span></span><br><span class="line">               <span class="keyword">if</span> (isLock)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">//3.----------------------如果获取失败，则休眠并且重试</span></span><br><span class="line">                   <span class="keyword">await</span> Task.Delay(<span class="number">5000</span>);</span><br><span class="line">                   <span class="keyword">await</span> Test5(id);</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 4.------------------如果获取锁成功，则根据id查询数据库，如下代码</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 缓存中没有数据，查询数据库</span></span><br><span class="line">               List&lt;Book&gt; books = <span class="keyword">new</span> List&lt;Book&gt;()</span><br><span class="line">               &#123;</span><br><span class="line">               <span class="keyword">new</span> Book() &#123; Id = <span class="number">1</span>, Title = <span class="string">&quot;.Net Core&quot;</span>, Author = <span class="string">&quot;zhangsan&quot;</span>, Description = <span class="string">&quot;.net core入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                <span class="keyword">new</span> Book() &#123; Id = <span class="number">2</span>, Title = <span class="string">&quot;Vue&quot;</span>, Author = <span class="string">&quot;lisi&quot;</span>, Description = <span class="string">&quot;Vue入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> Book() &#123; Id = <span class="number">3</span>, Title = <span class="string">&quot;React&quot;</span>, Author = <span class="string">&quot;wangwu&quot;</span>, Description = <span class="string">&quot;React入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                &#125;;</span><br><span class="line">           </span><br><span class="line">               Book book = books.FirstOrDefault(b =&gt; b.Id == id)!;</span><br><span class="line">               <span class="keyword">if</span> (book != <span class="literal">null</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 从数据库中查询到了数据，将其写入缓存</span></span><br><span class="line">                   <span class="keyword">var</span> options = <span class="keyword">new</span> DistributedCacheEntryOptions().SetAbsoluteExpiration(TimeSpan.FromSeconds(<span class="number">300</span>));</span><br><span class="line">                   <span class="keyword">await</span> _distributedCache.SetStringAsync(<span class="string">&quot;Book&quot;</span> + id, JsonSerializer.Serialize(book), options);</span><br><span class="line">				</span><br><span class="line">                   <span class="comment">//5. --------------===============释放互斥锁</span></span><br><span class="line">                   unloack(lockKey);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">return</span> Ok(book);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 如果数据库中也不存在，将空值写入到redis中</span></span><br><span class="line">                   <span class="keyword">var</span> options = <span class="keyword">new</span> DistributedCacheEntryOptions().SetAbsoluteExpiration(TimeSpan.FromSeconds(<span class="number">100</span>));</span><br><span class="line">                   <span class="keyword">await</span> _distributedCache.SetStringAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="string">&quot;null&quot;</span>, options);</span><br><span class="line">                   <span class="keyword">return</span> NotFound(<span class="string">$&quot;没有找到编号<span class="subst">&#123;id&#125;</span>的图书&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// 缓存中有数据，还需要判断是否为空字符串</span></span><br><span class="line">               <span class="keyword">if</span> (s == <span class="string">&quot;null&quot;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> NotFound(<span class="string">$&quot;没有找到编号<span class="subst">&#123;id&#125;</span>的图书&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">// 缓存中有数据，并且不是空字符串</span></span><br><span class="line">                   Book book = JsonSerializer.Deserialize&lt;Book&gt;(s)!;</span><br><span class="line">                   <span class="keyword">return</span> Ok(book);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>注意上面的业务逻辑步骤<code>1,2,3,4,5</code>, 关于第4步与以前是一样的，不做代码上的修改。</p>
<p>启动程序进行测试，可以查询编号为1的图书，当然<code>redis</code>缓存中不能有编号为1图书的信息。</p>
<p>然后打上断点，查看代码的执行流程。</p>
<h2 id="7-9-封装分布式缓存操作的帮助类"><a href="#7-9-封装分布式缓存操作的帮助类" class="headerlink" title="7.9 封装分布式缓存操作的帮助类"></a>7.9 封装分布式缓存操作的帮助类</h2><p>先创建一个<code>Common</code>类库项目，在该类库项目中进行帮助类的封装。</p>
<p>首先安装对应的包</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">		&lt;PackageReference Include=<span class="string">&quot;Microsoft.Extensions.Caching.StackExchangeRedis&quot;</span> Version=<span class="string">&quot;7.0.5&quot;</span> /&gt;</span><br><span class="line">	&lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure>

<p>创建<code>IDistributedCacheHelper.cs</code>接口，该接口中的代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDistributedCacheHelper</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       TResult? GetOrCreate&lt;TResult&gt;(<span class="built_in">string</span> cacheKey, Func&lt;DistributedCacheEntryOptions, TResult?&gt; valueFactory, <span class="built_in">int</span> expireSeconds = <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">       Task&lt;TResult?&gt; GetOrCreateAsync&lt;TResult&gt;(<span class="built_in">string</span> cacheKey, Func&lt;DistributedCacheEntryOptions, Task&lt;TResult?&gt;&gt; valueFactory, <span class="built_in">int</span> expireSeconds = <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">string</span> cacheKey</span>)</span>;</span><br><span class="line">       <span class="function">Task <span class="title">RemoveAsync</span>(<span class="params"><span class="built_in">string</span> cacheKey</span>)</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>创建实现上面接口的类<code>DistributedCacheHelper.cs</code>（这里解决了缓存穿透，缓存雪崩问题，但是缓存击穿没有添加，大家可以自行更改）</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Caching.Distributed;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Common</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DistributedCacheHelper</span>:<span class="title">IDistributedCacheHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCache distCache;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DistributedCacheHelper</span>(<span class="params">IDistributedCache distCache</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.distCache = distCache;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DistributedCacheEntryOptions <span class="title">CreateOptions</span>(<span class="params"><span class="built_in">int</span> baseExpireSeconds</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里随机产生过期时间，是为了解决缓存雪崩的问题</span></span><br><span class="line">            <span class="comment">// NextDouble方法是针对Random的扩展方法</span></span><br><span class="line">            <span class="built_in">double</span> sec = Random.Shared.NextDouble(baseExpireSeconds, baseExpireSeconds * <span class="number">2</span>);</span><br><span class="line">            TimeSpan expiration = TimeSpan.FromSeconds(sec);</span><br><span class="line">            DistributedCacheEntryOptions options = <span class="keyword">new</span> DistributedCacheEntryOptions();</span><br><span class="line">            options.AbsoluteExpirationRelativeToNow = expiration;</span><br><span class="line">            <span class="keyword">return</span> options;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> TResult? GetOrCreate&lt;TResult&gt;(<span class="built_in">string</span> cacheKey, Func&lt;DistributedCacheEntryOptions, TResult?&gt; valueFactory, <span class="built_in">int</span> expireSeconds = <span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>? jsonStr = distCache.GetString(cacheKey);</span><br><span class="line">            <span class="comment">//缓存中不存在</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(jsonStr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> options = CreateOptions(expireSeconds);</span><br><span class="line">                TResult? result = valueFactory(options);<span class="comment">//如果数据源中也没有查到，可能会返回null</span></span><br><span class="line">                <span class="comment">//null会被json序列化为字符串&quot;null&quot;，所以可以防范“缓存穿透”</span></span><br><span class="line">                <span class="built_in">string</span> jsonOfResult = JsonSerializer.Serialize(result,</span><br><span class="line">                    <span class="keyword">typeof</span>(TResult));</span><br><span class="line">                distCache.SetString(cacheKey, jsonOfResult, options);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//&quot;null&quot;会被反序列化为null</span></span><br><span class="line">                <span class="comment">//TResult如果是引用类型，就有为null的可能性；如果TResult是值类型</span></span><br><span class="line">                <span class="comment">//在写入的时候肯定写入的是0、1之类的值，反序列化出来不会是null</span></span><br><span class="line">                <span class="comment">//所以如果 obj 这里为null，那么存进去的时候一定是引用类型</span></span><br><span class="line">                distCache.Refresh(cacheKey);<span class="comment">//刷新，以便于滑动过期时间延期</span></span><br><span class="line">                <span class="keyword">return</span> JsonSerializer.Deserialize&lt;TResult&gt;(jsonStr)!;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// book100,</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="title">Task</span>&lt;<span class="title">TResult</span>?&gt; <span class="title">GetOrCreateAsync</span>&lt;<span class="title">TResult</span>&gt;(<span class="params"><span class="built_in">string</span> cacheKey, Func&lt;DistributedCacheEntryOptions, Task&lt;TResult?&gt;&gt; valueFactory, <span class="built_in">int</span> expireSeconds = <span class="number">60</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>? jsonStr = <span class="keyword">await</span> distCache.GetStringAsync(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">string</span>.IsNullOrEmpty(jsonStr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> options = CreateOptions(expireSeconds);</span><br><span class="line">                TResult? result = <span class="keyword">await</span> valueFactory(options);</span><br><span class="line">                <span class="built_in">string</span> jsonOfResult = JsonSerializer.Serialize(result,</span><br><span class="line">                    <span class="keyword">typeof</span>(TResult));</span><br><span class="line">                <span class="keyword">await</span> distCache.SetStringAsync(cacheKey, jsonOfResult, options);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">await</span> distCache.RefreshAsync(cacheKey);</span><br><span class="line">                <span class="keyword">return</span> JsonSerializer.Deserialize&lt;TResult&gt;(jsonStr)!;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">string</span> cacheKey</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            distCache.Remove(cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Task <span class="title">RemoveAsync</span>(<span class="params"><span class="built_in">string</span> cacheKey</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> distCache.RemoveAsync(cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同时在<code>Common</code>这个类库项目中，创建一个<code>RandomExtensions.cs</code>类，该类扩展<code>Random</code></p>
<p>代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Common</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">RandomExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>  Returns a random integer that is within a specified range.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;random&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;minValue&quot;&gt;</span>The inclusive lower bound of the random number returned.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;maxValue&quot;&gt;</span>The exclusive upper bound of the random number returned. maxValue must be greater than or equal to minValue.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">NextDouble</span>(<span class="params"><span class="keyword">this</span> Random random, <span class="built_in">double</span> minValue, <span class="built_in">double</span> maxValue</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (minValue &gt;= maxValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="keyword">nameof</span>(minValue), <span class="string">&quot;minValue cannot be bigger than maxValue&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            <span class="built_in">double</span> x = random.NextDouble();</span><br><span class="line">            <span class="keyword">return</span> x * maxValue + (<span class="number">1</span> - x) * minValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>WebApi</code>项目中引用<code>Common</code>项目</p>
<p>然后在<code>Program.cs</code>文件中，将<code>DistributedCacheHelper</code>这个帮助类添加到容器中</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">builder.Services.AddStackExchangeRedisCache(opt =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    opt.Configuration = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    opt.InstanceName = <span class="string">&quot;cacheApp&quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line">builder.Services.AddScoped&lt;IDistributedCacheHelper, DistributedCacheHelper&gt;();</span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br></pre></td></tr></table></figure>

<p>修改<code>TestsController.cs</code>控制器中的代码，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestsController</span> : <span class="title">ControllerBase</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCache _distributedCache;</span><br><span class="line">    <span class="comment">//---------------完成DistributedCacheHelper帮助类的注入操作</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">readonly</span> IDistributedCacheHelper _distributedHelper;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">TestsController</span>(<span class="params"> IDistributedCache distributedCache,IDistributedCacheHelper distributedCacheHelper</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>._distributedCache = distributedCache;    </span><br><span class="line">         <span class="keyword">this</span>._distributedHelper = distributedCacheHelper;</span><br><span class="line">       &#125;</span><br><span class="line">       [<span class="meta">HttpGet</span>]</span><br></pre></td></tr></table></figure>

<p>下面再控制器中创建对应的方法进行测试，代码如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="string">&quot;/cache6&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">Test6</span>(<span class="params"><span class="built_in">long</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用帮助类中的GetOrCreateAsync方法</span></span><br><span class="line">            <span class="keyword">var</span> book = <span class="keyword">await</span> _distributedHelper.GetOrCreateAsync(<span class="string">&quot;Book&quot;</span> + id, <span class="keyword">async</span>(e) =&gt; &#123;</span><br><span class="line">                e.SlidingExpiration = TimeSpan.FromSeconds(<span class="number">10</span>);  <span class="comment">// 这里也可以指定相对过期时间</span></span><br><span class="line">                <span class="comment">// 查询数据库</span></span><br><span class="line">                List&lt;Book&gt; books = <span class="keyword">new</span> List&lt;Book&gt;()</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">new</span> Book() &#123; Id = <span class="number">1</span>, Title = <span class="string">&quot;.Net Core&quot;</span>, Author = <span class="string">&quot;zhangsan&quot;</span>, Description = <span class="string">&quot;.net core入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                 <span class="keyword">new</span> Book() &#123; Id = <span class="number">2</span>, Title = <span class="string">&quot;Vue&quot;</span>, Author = <span class="string">&quot;lisi&quot;</span>, Description = <span class="string">&quot;Vue入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                  <span class="keyword">new</span> Book() &#123; Id = <span class="number">3</span>, Title = <span class="string">&quot;React&quot;</span>, Author = <span class="string">&quot;wangwu&quot;</span>, Description = <span class="string">&quot;React入门与精通&quot;</span>, Price = <span class="number">80</span> &#125;,</span><br><span class="line">                 &#125;;</span><br><span class="line">                </span><br><span class="line">                Book book = books.FirstOrDefault(b =&gt; b.Id == id)!;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> book;</span><br><span class="line">            &#125;, <span class="number">90</span>); <span class="comment">// 指定绝对过期时间</span></span><br><span class="line">            <span class="keyword">if</span> (book == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> NotFound(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Ok(book);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动程序进行测试。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://www.kilgour.top">kilgour</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.kilgour.top/2024/08/13/%E8%80%81%E7%8E%8B-21%E3%80%81Redis/">http://www.kilgour.top/2024/08/13/%E8%80%81%E7%8E%8B-21%E3%80%81Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.kilgour.top" target="_blank">Kilgour Notes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover11.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/15/%E8%80%81%E7%8E%8B-22%E3%80%81Git/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/08/10/%E6%8A%80%E6%9C%AF%E6%A0%88/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/kilg0ur/picture/master/picture/cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/5.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">kilgour</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/kilg0ur"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">1.</span> <span class="toc-text">Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81Redis%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">1、Redis简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFNoSql"><span class="toc-number">3.</span> <span class="toc-text">2、什么是NoSql</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E8%AE%A4%E8%AF%86Redis"><span class="toc-number">4.</span> <span class="toc-text">3、认识Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E5%AE%89%E8%A3%85Redis"><span class="toc-number">5.</span> <span class="toc-text">4、安装Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%A1%8C%E9%9D%A2%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.</span> <span class="toc-text">5、图形化桌面客户端</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81Redis%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">7.</span> <span class="toc-text">6、Redis常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">7.1.</span> <span class="toc-text">6.1  通用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-String%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 String类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-Key%E7%9A%84%E5%B1%82%E7%BA%A7%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">6.3  Key的层级格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-Hash-%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 Hash 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-List%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.5.</span> <span class="toc-text">6.5 List类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-Set%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.6.</span> <span class="toc-text">6.6 Set类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-SortedSet%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.7.</span> <span class="toc-text">6.7 SortedSet类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E7%BC%93%E5%AD%98%E5%BA%94%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">7、缓存应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%BC%93%E5%AD%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">7.1  缓存描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Net-core%E4%B8%AD%E4%BD%BF%E7%94%A8Redis"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 .Net core中使用Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">8.3.</span> <span class="toc-text">7.3  缓存更新策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%BA%94%E7%94%A8"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 缓存更新策略应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">8.5.</span> <span class="toc-text">7.5 缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">8.6.</span> <span class="toc-text">7.6  缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">8.7.</span> <span class="toc-text">7.7 缓存击穿问题分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-%E5%88%A9%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span class="toc-number">8.8.</span> <span class="toc-text">7.8 利用互斥锁解决缓存击穿问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9-%E5%B0%81%E8%A3%85%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B8%AE%E5%8A%A9%E7%B1%BB"><span class="toc-number">8.9.</span> <span class="toc-text">7.9 封装分布式缓存操作的帮助类</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By kilgour</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">2</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><!-- hexo injector body_end end --></body></html>